<!doctype html>
<html lang="en-US">
<head>
  <meta charset="utf-8">
  <meta name="Description" content="An example usage of x-pwgen.">
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <base href="/">

  <title>x-pwgen</title>
  <style>
    :root {
      --x-pwgen-font-family: monospace;
      --x-pwgen-font-size: 1rem;
      --x-pwgen-li-padding: 0.75rem 0 0 0;

      --mdc-theme-primary: #ccc;
      --mdc-theme-secondary: #ccc;
      --mdc-theme-text-primary-on-background: #fff;
      --mdc-theme-text-primary-on-dark: #000;
    }

    html, body {
      height: 100%;
      margin: 0;
    }

    h1 {
      font-size: 1.5rem;
    }

    a {
      color: #222;
    }

    section > p {
      margin: 0;
      padding: 0.5rem 1rem 0.5rem 1rem;
    }

    mwc-formfield {
      display: block;
    }

    x-pwgen {
      overflow-wrap: break-word;
    }

    mwc-slider {
      padding: 0 1rem 0 1rem;
    }

    #grid-container {
      align-items: center;
      display: grid;
      grid-template-areas: "top" "middle" "bottom";
      grid-template-columns: 1fr;
      grid-template-rows: auto 1fr auto;
      height: 100%;
      justify-items: center;
    }

    #top {
      grid-area: top;
      text-align: center;
      width: 100%;
    }

    #branding {
      display: flex;
      max-height: 5rem;
    }

    #branding > section {
      flex: 1;
    }

    #badge {
      text-align: right;
    }

    #middle {
      align-self: center;
      font-weight: bold;
      grid-area: middle;
      padding-bottom: 1.5rem;
    }

    #bottom {
      background-color: #333;
      grid-area: bottom;
      margin-top: 1rem;
      width: 20rem;
      min-height: 6rem;
    }

    #buttons {
      display: flex;
    }

    #buttons > mwc-formfield {
      flex: 1;
      text-align: center;
    }
  </style>
  <script type="module">
    // https://kherrick.github.io/x-pwgen-components/dist/esm/XPwgenUtilities.js

    window.__copyButtonClickHandler = (event) => {
      window['x-pwgen-components'].utilities.clipboardPolyfill.writeText(
        document.querySelector('x-pwgen')
          .shadowRoot.querySelector('#container > ul')
          .innerText
      )
    }
  </script>
</head>
<body>
  <section id="grid-container">
    <section id="top">
      <section id="branding">
        <section></section>
        <section id="title"><h1>
          <a href="/">
            pwgen
          </a>
        </h1></section>
        <section id="badge">
          <!-- left blank intentionally -->
        </section>
      </section>
      <section>
        <p>
          A password generator compiled as Wasm for use on the CLI, in a custom element, or as a module. <a href="https://github.com/kherrick/pwgen/">Learn More</a>.
        </p>
      </section>
    </section>
    <section id="middle">
      <x-pwgen flags="-sync"></x-pwgen>
    </section>
    <section id="bottom">
      <mwc-formfield label="Number of Passwords">
        <mwc-slider
          id="number-of-passwords"
          markers=""
          max="5"
          min="1"
          onchange="document.querySelector('x-pwgen').number = this.value"
          pin=""
          step="1"
          value="1"
        ></mwc-slider>
      </mwc-formfield>
      <mwc-formfield label="Length">
        <mwc-slider
          id="password-length"
          markers=""
          max="30"
          min="1"
          onchange="document.querySelector('x-pwgen').length = this.value"
          pin=""
          step="1"
          value="20"
        ></mwc-slider>
      </mwc-formfield>
      <section id="buttons">
        <mwc-formfield label="">
          <mwc-button onclick="window.__copyButtonClickHandler(event)">
            <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><path d="M19 21H8V7h11m0-2H8a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2m-3-4H4a2 2 0 0 0-2 2v14h2V3h12V1z" fill="#626262"/></svg>&nbsp;Copy
          </mwc-button>
        </mwc-formfield>
        <mwc-formfield label="">
          <mwc-button onclick="document.querySelector('x-pwgen').generate()">
            Generate
          </mwc-button>
        </mwc-formfield>
      </section>
    </section>
  </section>
  <script type="module">
    var pwgen = (function() {
      var _scriptDir = '';

      return (
        function(pwgen) {
          pwgen = pwgen || {};

          "use strict;";
          var Module = typeof pwgen !== "undefined" ? pwgen : {};
          var moduleOverrides = {};
          var key;
          for (key in Module) {
            if (Module.hasOwnProperty(key)) {
              moduleOverrides[key] = Module[key]
            }
          }
          var arguments_ = [];
          var thisProgram = "./this.program";
          var quit_ = function(status, toThrow) {
            throw toThrow
          };
          var ENVIRONMENT_IS_WEB = true;
          var ENVIRONMENT_IS_WORKER = false;
          var scriptDirectory = "";

          function locateFile(path) {
            if (Module["locateFile"]) {
              return Module["locateFile"](path, scriptDirectory)
            }
            return scriptDirectory + path
          }
          var read_, readAsync, readBinary, setWindowTitle;
          if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
            if (ENVIRONMENT_IS_WORKER) {
              scriptDirectory = self.location.href
            } else if (document.currentScript) {
              scriptDirectory = document.currentScript.src
            }
            if (_scriptDir) {
              scriptDirectory = _scriptDir
            }
            if (scriptDirectory.indexOf("blob:") !== 0) {
              scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1)
            } else {
              scriptDirectory = ""
            }
            read_ = function shell_read(url) {
              var xhr = new XMLHttpRequest;
              xhr.open("GET", url, false);
              xhr.send(null);
              return xhr.responseText
            };
            if (ENVIRONMENT_IS_WORKER) {
              readBinary = function readBinary(url) {
                var xhr = new XMLHttpRequest;
                xhr.open("GET", url, false);
                xhr.responseType = "arraybuffer";
                xhr.send(null);
                return new Uint8Array(xhr.response)
              }
            }
            readAsync = function readAsync(url, onload, onerror) {
              var xhr = new XMLHttpRequest;
              xhr.open("GET", url, true);
              xhr.responseType = "arraybuffer";
              xhr.onload = function xhr_onload() {
                if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                  onload(xhr.response);
                  return
                }
                onerror()
              };
              xhr.onerror = onerror;
              xhr.send(null)
            };
            setWindowTitle = function(title) {
              document.title = title
            }
          } else {}
          var out = Module["print"] || console.log.bind(console);
          var err = Module["printErr"] || console.warn.bind(console);
          for (key in moduleOverrides) {
            if (moduleOverrides.hasOwnProperty(key)) {
              Module[key] = moduleOverrides[key]
            }
          }
          moduleOverrides = null;
          if (Module["arguments"]) arguments_ = Module["arguments"];
          if (Module["thisProgram"]) thisProgram = Module["thisProgram"];
          if (Module["quit"]) quit_ = Module["quit"];

          function dynamicAlloc(size) {
            var ret = HEAP32[DYNAMICTOP_PTR >> 2];
            var end = ret + size + 15 & -16;
            if (end > _emscripten_get_heap_size()) {
              abort()
            }
            HEAP32[DYNAMICTOP_PTR >> 2] = end;
            return ret
          }

          function getNativeTypeSize(type) {
            switch (type) {
              case "i1":
              case "i8":
                return 1;
              case "i16":
                return 2;
              case "i32":
                return 4;
              case "i64":
                return 8;
              case "float":
                return 4;
              case "double":
                return 8;
              default: {
                if (type[type.length - 1] === "*") {
                  return 4
                } else if (type[0] === "i") {
                  var bits = parseInt(type.substr(1));
                  assert(bits % 8 === 0, "getNativeTypeSize invalid bits " + bits + ", type " + type);
                  return bits / 8
                } else {
                  return 0
                }
              }
            }
          }
          var asm2wasmImports = {
            "f64-rem": function(x, y) {
              return x % y
            },
            "debugger": function() {}
          };
          var functionPointers = new Array(0);
          var wasmBinary;
          if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];
          var noExitRuntime;
          if (Module["noExitRuntime"]) noExitRuntime = Module["noExitRuntime"];
          if (typeof WebAssembly !== "object") {
            err("no native wasm support detected")
          }

          function setValue(ptr, value, type, noSafe) {
            type = type || "i8";
            if (type.charAt(type.length - 1) === "*") type = "i32";
            switch (type) {
              case "i1":
                HEAP8[ptr >> 0] = value;
                break;
              case "i8":
                HEAP8[ptr >> 0] = value;
                break;
              case "i16":
                HEAP16[ptr >> 1] = value;
                break;
              case "i32":
                HEAP32[ptr >> 2] = value;
                break;
              case "i64":
                tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];
                break;
              case "float":
                HEAPF32[ptr >> 2] = value;
                break;
              case "double":
                HEAPF64[ptr >> 3] = value;
                break;
              default:
                abort("invalid type for setValue: " + type)
            }
          }
          var wasmMemory;
          var wasmTable;
          var ABORT = false;
          var EXITSTATUS = 0;

          function assert(condition, text) {
            if (!condition) {
              abort("Assertion failed: " + text)
            }
          }
          var ALLOC_NONE = 3;

          function allocate(slab, types, allocator, ptr) {
            var zeroinit, size;
            if (typeof slab === "number") {
              zeroinit = true;
              size = slab
            } else {
              zeroinit = false;
              size = slab.length
            }
            var singleType = typeof types === "string" ? types : null;
            var ret;
            if (allocator == ALLOC_NONE) {
              ret = ptr
            } else {
              ret = [_malloc, stackAlloc, dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length))
            }
            if (zeroinit) {
              var stop;
              ptr = ret;
              assert((ret & 3) == 0);
              stop = ret + (size & ~3);
              for (; ptr < stop; ptr += 4) {
                HEAP32[ptr >> 2] = 0
              }
              stop = ret + size;
              while (ptr < stop) {
                HEAP8[ptr++ >> 0] = 0
              }
              return ret
            }
            if (singleType === "i8") {
              if (slab.subarray || slab.slice) {
                HEAPU8.set(slab, ret)
              } else {
                HEAPU8.set(new Uint8Array(slab), ret)
              }
              return ret
            }
            var i = 0,
              type, typeSize, previousType;
            while (i < size) {
              var curr = slab[i];
              type = singleType || types[i];
              if (type === 0) {
                i++;
                continue
              }
              if (type == "i64") type = "i32";
              setValue(ret + i, curr, type);
              if (previousType !== type) {
                typeSize = getNativeTypeSize(type);
                previousType = type
              }
              i += typeSize
            }
            return ret
          }
          var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : undefined;

          function UTF8ArrayToString(u8Array, idx, maxBytesToRead) {
            var endIdx = idx + maxBytesToRead;
            var endPtr = idx;
            while (u8Array[endPtr] && !(endPtr >= endIdx)) ++endPtr;
            if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {
              return UTF8Decoder.decode(u8Array.subarray(idx, endPtr))
            } else {
              var str = "";
              while (idx < endPtr) {
                var u0 = u8Array[idx++];
                if (!(u0 & 128)) {
                  str += String.fromCharCode(u0);
                  continue
                }
                var u1 = u8Array[idx++] & 63;
                if ((u0 & 224) == 192) {
                  str += String.fromCharCode((u0 & 31) << 6 | u1);
                  continue
                }
                var u2 = u8Array[idx++] & 63;
                if ((u0 & 240) == 224) {
                  u0 = (u0 & 15) << 12 | u1 << 6 | u2
                } else {
                  u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u8Array[idx++] & 63
                }
                if (u0 < 65536) {
                  str += String.fromCharCode(u0)
                } else {
                  var ch = u0 - 65536;
                  str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023)
                }
              }
            }
            return str
          }

          function UTF8ToString(ptr, maxBytesToRead) {
            return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : ""
          }

          function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
            if (!(maxBytesToWrite > 0)) return 0;
            var startIdx = outIdx;
            var endIdx = outIdx + maxBytesToWrite - 1;
            for (var i = 0; i < str.length; ++i) {
              var u = str.charCodeAt(i);
              if (u >= 55296 && u <= 57343) {
                var u1 = str.charCodeAt(++i);
                u = 65536 + ((u & 1023) << 10) | u1 & 1023
              }
              if (u <= 127) {
                if (outIdx >= endIdx) break;
                outU8Array[outIdx++] = u
              } else if (u <= 2047) {
                if (outIdx + 1 >= endIdx) break;
                outU8Array[outIdx++] = 192 | u >> 6;
                outU8Array[outIdx++] = 128 | u & 63
              } else if (u <= 65535) {
                if (outIdx + 2 >= endIdx) break;
                outU8Array[outIdx++] = 224 | u >> 12;
                outU8Array[outIdx++] = 128 | u >> 6 & 63;
                outU8Array[outIdx++] = 128 | u & 63
              } else {
                if (outIdx + 3 >= endIdx) break;
                outU8Array[outIdx++] = 240 | u >> 18;
                outU8Array[outIdx++] = 128 | u >> 12 & 63;
                outU8Array[outIdx++] = 128 | u >> 6 & 63;
                outU8Array[outIdx++] = 128 | u & 63
              }
            }
            outU8Array[outIdx] = 0;
            return outIdx - startIdx
          }

          function stringToUTF8(str, outPtr, maxBytesToWrite) {
            return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite)
          }

          function lengthBytesUTF8(str) {
            var len = 0;
            for (var i = 0; i < str.length; ++i) {
              var u = str.charCodeAt(i);
              if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
              if (u <= 127) ++len;
              else if (u <= 2047) len += 2;
              else if (u <= 65535) len += 3;
              else len += 4
            }
            return len
          }
          var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : undefined;

          function allocateUTF8OnStack(str) {
            var size = lengthBytesUTF8(str) + 1;
            var ret = stackAlloc(size);
            stringToUTF8Array(str, HEAP8, ret, size);
            return ret
          }
          var WASM_PAGE_SIZE = 65536;

          function alignUp(x, multiple) {
            if (x % multiple > 0) {
              x += multiple - x % multiple
            }
            return x
          }
          var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;

          function updateGlobalBufferAndViews(buf) {
            buffer = buf;
            Module["HEAP8"] = HEAP8 = new Int8Array(buf);
            Module["HEAP16"] = HEAP16 = new Int16Array(buf);
            Module["HEAP32"] = HEAP32 = new Int32Array(buf);
            Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
            Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
            Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
            Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
            Module["HEAPF64"] = HEAPF64 = new Float64Array(buf)
          }
          var DYNAMIC_BASE = 5252848,
            DYNAMICTOP_PTR = 9936;
          var INITIAL_TOTAL_MEMORY = Module["TOTAL_MEMORY"] || 16777216;
          if (Module["wasmMemory"]) {
            wasmMemory = Module["wasmMemory"]
          } else {
            wasmMemory = new WebAssembly.Memory({
              "initial": INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE
            })
          }
          if (wasmMemory) {
            buffer = wasmMemory.buffer
          }
          INITIAL_TOTAL_MEMORY = buffer.byteLength;
          updateGlobalBufferAndViews(buffer);
          HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;

          function callRuntimeCallbacks(callbacks) {
            while (callbacks.length > 0) {
              var callback = callbacks.shift();
              if (typeof callback == "function") {
                callback();
                continue
              }
              var func = callback.func;
              if (typeof func === "number") {
                if (callback.arg === undefined) {
                  Module["dynCall_v"](func)
                } else {
                  Module["dynCall_vi"](func, callback.arg)
                }
              } else {
                func(callback.arg === undefined ? null : callback.arg)
              }
            }
          }
          var __ATPRERUN__ = [];
          var __ATINIT__ = [];
          var __ATMAIN__ = [];
          var __ATEXIT__ = [];
          var __ATPOSTRUN__ = [];
          var runtimeInitialized = false;
          var runtimeExited = false;

          function preRun() {
            if (Module["preRun"]) {
              if (typeof Module["preRun"] == "function") Module["preRun"] = [Module["preRun"]];
              while (Module["preRun"].length) {
                addOnPreRun(Module["preRun"].shift())
              }
            }
            callRuntimeCallbacks(__ATPRERUN__)
          }

          function initRuntime() {
            runtimeInitialized = true;
            if (!Module["noFSInit"] && !FS.init.initialized) FS.init();
            TTY.init();
            callRuntimeCallbacks(__ATINIT__)
          }

          function preMain() {
            FS.ignorePermissions = false;
            callRuntimeCallbacks(__ATMAIN__)
          }

          function exitRuntime() {
            callRuntimeCallbacks(__ATEXIT__);
            FS.quit();
            TTY.shutdown();
            runtimeExited = true
          }

          function postRun() {
            if (Module["postRun"]) {
              if (typeof Module["postRun"] == "function") Module["postRun"] = [Module["postRun"]];
              while (Module["postRun"].length) {
                addOnPostRun(Module["postRun"].shift())
              }
            }
            callRuntimeCallbacks(__ATPOSTRUN__)
          }

          function addOnPreRun(cb) {
            __ATPRERUN__.unshift(cb)
          }

          function addOnPostRun(cb) {
            __ATPOSTRUN__.unshift(cb)
          }
          var Math_abs = Math.abs;
          var Math_ceil = Math.ceil;
          var Math_floor = Math.floor;
          var Math_min = Math.min;
          var runDependencies = 0;
          var runDependencyWatcher = null;
          var dependenciesFulfilled = null;

          function getUniqueRunDependency(id) {
            return id
          }

          function addRunDependency(id) {
            runDependencies++;
            if (Module["monitorRunDependencies"]) {
              Module["monitorRunDependencies"](runDependencies)
            }
          }

          function removeRunDependency(id) {
            runDependencies--;
            if (Module["monitorRunDependencies"]) {
              Module["monitorRunDependencies"](runDependencies)
            }
            if (runDependencies == 0) {
              if (runDependencyWatcher !== null) {
                clearInterval(runDependencyWatcher);
                runDependencyWatcher = null
              }
              if (dependenciesFulfilled) {
                var callback = dependenciesFulfilled;
                dependenciesFulfilled = null;
                callback()
              }
            }
          }
          Module["preloadedImages"] = {};
          Module["preloadedAudios"] = {};

          // var dataURIPrefix = "data:application/octet-stream;base64,";
          var dataURIPrefix = "data:application/wasm;base64,";

          function isDataURI(filename) {
            return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0
          }

          // var wasmBinaryFile = "pwgen.wasm";
          // -- pwgen.wasm
          var wasmBinaryFile = "data:application/wasm;base64,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AkcEQCAAIAFrEDlBf0YEQEEADwsLQZDEACgCACIBBEAgACABNgIEBUGMxAAgAjYCAAtBkMQAIAI2AgAgACADQQF0QQFyNgIACyAAQQhqCwgAIAAgARB4C4MBAgJ/AX4gAKchAiAAQv////8PVgRAA0AgAUF/aiIBIAAgAEIKgCIEQgp+fadB/wFxQTByOgAAIABC/////58BVgRAIAQhAAwBCwsgBKchAgsgAgRAA0AgAUF/aiIBIAIgAkEKbiIDQQpsa0EwcjoAACACQQpPBEAgAyECDAELCwsgAQuYAgEEfyAAIAJqIQQgAUH/AXEhAyACQcMATgRAA0AgAEEDcQRAIAAgAzoAACAAQQFqIQAMAQsLIANBCHQgA3IgA0EQdHIgA0EYdHIhASAEQXxxIgVBQGohBgNAIAAgBkwEQCAAIAE2AgAgACABNgIEIAAgATYCCCAAIAE2AgwgACABNgIQIAAgATYCFCAAIAE2AhggACABNgIcIAAgATYCICAAIAE2AiQgACABNgIoIAAgATYCLCAAIAE2AjAgACABNgI0IAAgATYCOCAAIAE2AjwgAEFAayEADAELCwNAIAAgBUgEQCAAIAE2AgAgAEEEaiEADAELCwsDQCAAIARIBEAgACADOgAAIABBAWohAAwBCwsgBCACawvGAwEDfyACQYDAAE4EQCAAIAEgAhASGiAADwsgACEEIAAgAmohAyAAQQNxIAFBA3FGBEADQCAAQQNxBEAgAkUEQCAEDwsgACABLAAAOgAAIABBAWohACABQQFqIQEgAkEBayECDAELCyADQXxxIgJBQGohBQNAIAAgBUwEQCAAIAEoAgA2AgAgACABKAIENgIEIAAgASgCCDYCCCAAIAEoAgw2AgwgACABKAIQNgIQIAAgASgCFDYCFCAAIAEoAhg2AhggACABKAIcNgIcIAAgASgCIDYCICAAIAEoAiQ2AiQgACABKAIoNgIoIAAgASgCLDYCLCAAIAEoAjA2AjAgACABKAI0NgI0IAAgASgCODYCOCAAIAEoAjw2AjwgAEFAayEAIAFBQGshAQwBCwsDQCAAIAJIBEAgACABKAIANgIAIABBBGohACABQQRqIQEMAQsLBSADQQRrIQIDQCAAIAJIBEAgACABLAAAOgAAIAAgASwAAToAASAAIAEsAAI6AAIgACABLAADOgAD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AiEAIwJBEGokAiAAQf8sNgIAQYAZIAAoAgBBBEEAQX8QAiAAJAILGwECfyMCIQIgACMCaiQCIwJBD2pBcHEkAiACCwvPKygAQYAICwKEDgBBjAgLBmEAAACQDgBBnAgLBmMAAACbDgBBrAgLBm4AAACkDgBBvAgLJnkAAACsDgAAAQAAAAAAAABOAAAAug4AAAEAAAAAAAAAcgAAAMcOAEHsCAsGcwAAAM4OAEH8CAsGaAAAANMOAEGMCQsGMAAAAN8OAEGcCQsWQQAAAO0OAAABAAAAAAAAAEgAAADyDgBBvAkLBkIAAAD8DgBBzAkLAXYAQeAJC8ECXhMAAAIAAABgEwAABgAAAGMTAAAGAAAAZhMAAAYAAABpEwAAAQAAAGsTAAABAAAAbRMAAAUAAABwEwAAAQAAAHITAAACAAAAdBMAAAYAAAB3EwAABgAAAHoTAAABAAAAfBMAAAEAAAB+EwAADQAAAIETAAABAAAAgxMAAAIAAACFEwAABgAAAIgTAAABAAAAihMAAAEAAACMEwAAAQAAAI4TAAABAAAAkBMAAAEAAACSEwAADQAAAJUTAAACAAAAlxMAAAYAAACaEwAABgAAAJ0TAAABAAAAnxMAAAUAAACiEwAABQAAAKUTAAABAAAApxMAAAEAAACpEwAABQAAAKwTAAABAAAArhMAAAUAAACxEwAAAgAAALMTAAABAAAAtRMAAAEAAAC3EwAAAQAAALkTAAABAAAAuxMAAAEAAACAAEHgDAvRAwIAAMADAADABAAAwAUAAMAGAADABwAAwAgAAMAJAADACgAAwAsAAMAMAADADQAAwA4AAMAPAADAEAAAwBEAAMASAADAEwAAwBQAAMAVAADAFgAAwBcAAMAYAADAGQAAwBoAAMAbAADAHAAAwB0AAMAeAADAHwAAwAAAALMBAADDAgAAwwMAAMMEAADDBQAAwwYAAMMHAADDCAAAwwkAAMMKAADDCwAAwwwAAMMNAADTDgAAww8AAMMAAAy7AQAMwwIADMMDAAzDBAAM0wAAAAD/////////////////////////////////////////////////////////////////AAECAwQFBgcICf////////8KCwwNDg8QERITFBUWFxgZGhscHR4fICEiI////////woLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIj/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wBBwBALGBEACgAREREAAAAABQAAAAAAAAkAAAAACwBB4BALIREADwoREREDCgcAARMJCwsAAAkGCwAACwAGEQAAABEREQBBkRELAQsAQZoRCxgRAAoKERERAAoAAAIACQsAAAAJAAsAAAsAQcsRCwEMAEHXEQsVDAAAAAAMAAAAAAkMAAAAAAAMAAAMAEGFEgsBDgBBkRILFQ0AAAAEDQAAAAAJDgAAAAAADgAADgBBvxILARAAQcsSCx4PAAAAAA8AAAAACRAAAAAAABAAABAAABIAAAASEhIAQYITCw4SAAAAEhISAAAAAAAACQBBsxMLAQsAQb8TCxUKAAAAAAoAAAAACQsAAAAAAAsAAAsAQe0TCwEMAEH5EwsoDAAAAAAMAAAAAAkMAAAAAAAMAAAMAAAwMTIzNDU2Nzg5QUJDREVGBQBBrBQLAQEAQcQUCwoBAAAAAQAAABwiAEHcFAsBAgBB6xQLBf//////AEGwFQsBBQBBvBULAQEAQdQVCw4CAAAAAQAAALgcAAAABABB7BULAQEAQfsVCwUK/////wBBwBYLugP4DQAAWhkAAPgNAAB5GQAA+A0AAJgZAAD4DQAAtxkAAPgNAADWGQAA+A0AAPUZAAD4DQAAFBoAAPgNAAAzGgAA+A0AAFIaAAD4DQAAcRoAAPgNAACQGgAA+A0AAK8aAAD4DQAAzhoAAGQOAADhGgAAAAAAAAEAAADACwAAAAAAAPgNAAAgGwAAZA4AAEYbAAAAAAAAAQAAAMALAAAAAAAAZA4AAIUbAAAAAAAAAQAAAMALAAAAAAAAIA4AABccAAAIDAAAAAAAACAOAADEGwAAGAwAAAAAAAD4DQAA5RsAACAOAADyGwAA+AsAAAAAAAAgDgAAORwAAAgMAAAAAAAASA4AALMTAABIDgAAaRMAAEgOAABrEwAASA4AAIETAABIDgAAXhMAAEgOAACnEwAASA4AAKwTAABIDgAAgxMAAEgOAACIEwAASA4AAIwTAABIDgAAjhMAAEgOAAB6EwAASA4AAHATAAAgDgAAYRwAAPgLAAAAAAAACAAAAP////8GDwAAvRMAAMgTAADjEwAA/hMAAB8UAAAvFAAA/v///0AVAAAUAAAAAQAAAAEAAAAgCgAAsAoAALAKAEG4GwsC1CEAQfQbC5Id+AsAAAEAAAACAAAAAwAAAAQAAAADAAAAAQAAAAEAAAABAAAAAAAAACAMAAABAAAABQAAAAMAAAAEAAAAAwAAAAIAAAACAAAAAgAAAAAAAAAwDAAAAQAAAAYAAAADAAAABAAAAAQAAAAAAAAAqAwAAAEAAAAHAAAAAwAAAAQAAAADAAAAAwAAAAMAAAADAAAAYWx0LXBob25pY3MAY2FwaXRhbGl6ZQBudW1lcmFscwBzeW1ib2xzAG51bS1wYXNzd29yZHMAcmVtb3ZlLWNoYXJzAHNlY3VyZQBoZWxwAG5vLW51bWVyYWxzAG5vLWNhcGl0YWxpemUAc2hhMQBhbWJpZ3VvdXMAbm8tdm93ZWxzADAxQWFCQ2NuTjpzcjpoSDp2eQBJbnZhbGlkIG51bWJlciBvZiBwYXNzd29yZHM6ICVzCgBJbnZhbGlkIHBhc3N3b3JkIGxlbmd0aDogJXMKAENvdWxkbid0IG1hbGxvYyBwYXNzd29yZCBidWZmZXIuCgAlcyAAVXNhZ2U6IHB3Z2VuIFsgT1BUSU9OUyBdIFsgcHdfbGVuZ3RoIF0gWyBudW1fcHcgXQoKAE9wdGlvbnMgc3VwcG9ydGVkIGJ5IHB3Z2VuOgoAICAtYyBvciAtLWNhcGl0YWxpemUKAAlJbmNsdWRlIGF0IGxlYXN0IG9uZSBjYXBpdGFsIGxldHRlciBpbiB0aGUgcGFzc3dvcmQKACAgLUEgb3IgLS1uby1jYXBpdGFsaXplCgAJRG9uJ3QgaW5jbHVkZSBjYXBpdGFsIGxldHRlcnMgaW4gdGhlIHBhc3N3b3JkCgAgIC1uIG9yIC0tbnVtZXJhbHMKAAlJbmNsdWRlIGF0IGxlYXN0IG9uZSBudW1iZXIgaW4gdGhlIHBhc3N3b3JkCgAgIC0wIG9yIC0tbm8tbnVtZXJhbHMKAAlEb24ndCBpbmNsdWRlIG51bWJlcnMgaW4gdGhlIHBhc3N3b3JkCgAgIC15IG9yIC0tc3ltYm9scwoACUluY2x1ZGUgYXQgbGVhc3Qgb25lIHNwZWNpYWwgc3ltYm9sIGluIHRoZSBwYXNzd29yZAoAICAtciA8Y2hhcnM+IG9yIC0tcmVtb3ZlLWNoYXJzPTxjaGFycz4KAAlSZW1vdmUgY2hhcmFjdGVycyBmcm9tIHRoZSBzZXQgb2YgY2hhcmFjdGVycyB0byBnZW5lcmF0ZSBwYXNzd29yZHMKACAgLXMgb3IgLS1zZWN1cmUKAAlHZW5lcmF0ZSBjb21wbGV0ZWx5IHJhbmRvbSBwYXNzd29yZHMKACAgLUIgb3IgLS1hbWJpZ3VvdXMKAAlEb24ndCBpbmNsdWRlIGFtYmlndW91cyBjaGFyYWN0ZXJzIGluIHRoZSBwYXNzd29yZAoAICAtaCBvciAtLWhlbHAKAAlQcmludCBhIGhlbHAgbWVzc2FnZQoAICAtSCBvciAtLXNoYTE9cGF0aC90by9maWxlWyNzZWVkXQoACVVzZSBzaGExIGhhc2ggb2YgZ2l2ZW4gZmlsZSBhcyBhIChub3Qgc28pIHJhbmRvbSBnZW5lcmF0b3IKACAgLUMKCVByaW50IHRoZSBnZW5lcmF0ZWQgcGFzc3dvcmRzIGluIGNvbHVtbnMKACAgLTEKCURvbid0IHByaW50IHRoZSBnZW5lcmF0ZWQgcGFzc3dvcmRzIGluIGNvbHVtbnMKACAgLXYgb3IgLS1uby12b3dlbHMKAAlEbyBub3QgdXNlIGFueSB2b3dlbHMgc28gYXMgdG8gYXZvaWQgYWNjaWRlbnRhbCBuYXN0eSB3b3JkcwoAYQBhZQBhaABhaQBiAGMAY2gAZABlAGVlAGVpAGYAZwBnaABoAGkAaWUAagBrAGwAbQBuAG5nAG8Ab2gAb28AcABwaABxdQByAHMAc2gAdAB0aAB1AHYAdwB4AHkAegAwMTIzNDU2Nzg5AEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaAGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6ACEiIyQlJicoKSorLC0uLzo7PD0+P0BbXF1eX2B7fH1+AEI4RzZJMWwwT1FEUzVaMgAwMWFlaW91eUFFSU9VWQBDb3VsZG4ndCBtYWxsb2MgcHdfcmFuZCBidWZmZXIuCgBFcnJvcjogTm8gZGlnaXRzIGxlZnQgaW4gdGhlIHZhbGlkIHNldAoARXJyb3I6IE5vIHVwcGVyIGNhc2UgbGV0dGVycyBsZWZ0IGluIHRoZSB2YWxpZCBzZXQKAEVycm9yOiBObyBzeW1ib2xzIGxlZnQgaW4gdGhlIHZhbGlkIHNldAoARXJyb3I6IE5vIGNoYXJhY3RlcnMgbGVmdCBpbiB0aGUgdmFsaWQgc2V0CgBObyBlbnRyb3B5IGF2YWlsYWJsZSEKAC9kZXYvdXJhbmRvbQAvZGV2L3JhbmRvbQBwd2dlbgBDb3VsZG4ndCBtYWxsb2Mgc2hhMV9zZWVkIGJ1ZmZlci4KAHJiAENvdWxkbid0IG9wZW4gZmlsZTogJXMuCgAAAQIEBwMGBQAtKyAgIDBYMHgAKG51bGwpAC0wWCswWCAwWC0weCsweCAweABpbmYASU5GAG5hbgBOQU4ALgA6IG9wdGlvbiBkb2VzIG5vdCB0YWtlIGFuIGFyZ3VtZW50OiAAOiBvcHRpb24gcmVxdWlyZXMgYW4gYXJndW1lbnQ6IAA6IHVucmVjb2duaXplZCBvcHRpb246IAA6IG9wdGlvbiBpcyBhbWJpZ3VvdXM6IAByd2EAdm9pZABib29sAGNoYXIAc2lnbmVkIGNoYXIAdW5zaWduZWQgY2hhcgBzaG9ydAB1bnNpZ25lZCBzaG9ydABpbnQAdW5zaWduZWQgaW50AGxvbmcAdW5zaWduZWQgbG9uZwBmbG9hdABkb3VibGUAc3RkOjpzdHJpbmcAc3RkOjpiYXNpY19zdHJpbmc8dW5zaWduZWQgY2hhcj4Ac3RkOjp3c3RyaW5nAGVtc2NyaXB0ZW46OnZhbABlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8bG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgbG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGZsb2F0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxkb3VibGU+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGxvbmcgZG91YmxlPgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0llRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZEVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWZFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ltRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbEVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWpFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lpRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJdEVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXNFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0loRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJYUVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWNFRQBOMTBlbXNjcmlwdGVuM3ZhbEUATlN0M19fMjEyYmFzaWNfc3RyaW5nSXdOU18xMWNoYXJfdHJhaXRzSXdFRU5TXzlhbGxvY2F0b3JJd0VFRUUATlN0M19fMjIxX19iYXNpY19zdHJpbmdfY29tbW9uSUxiMUVFRQBOU3QzX18yMTJiYXNpY19zdHJpbmdJaE5TXzExY2hhcl90cmFpdHNJaEVFTlNfOWFsbG9jYXRvckloRUVFRQBOU3QzX18yMTJiYXNpY19zdHJpbmdJY05TXzExY2hhcl90cmFpdHNJY0VFTlNfOWFsbG9jYXRvckljRUVFRQBOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQBTdDl0eXBlX2luZm8ATjEwX19jeHhhYml2MTIwX19zaV9jbGFzc190eXBlX2luZm9FAE4xMF9fY3h4YWJpdjExN19fY2xhc3NfdHlwZV9pbmZvRQBOMTBfX2N4eGFiaXYxMjNfX2Z1bmRhbWVudGFsX3R5cGVfaW5mb0UATjEwX19jeHhhYml2MTIxX192bWlfY2xhc3NfdHlwZV9pbmZvRQ==";
          if (!isDataURI(wasmBinaryFile)) {
            wasmBinaryFile = locateFile(wasmBinaryFile)
          }

          function getBinary() {
            try {
              if (wasmBinary) {
                return new Uint8Array(wasmBinary)
              }
              if (readBinary) {
                return readBinary(wasmBinaryFile)
              } else {
                throw "both async and sync fetching of the wasm failed"
              }
            } catch (err) {
              abort(err)
            }
          }

          function getBinaryPromise() {
            if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === "function") {
              return fetch(wasmBinaryFile, {
                credentials: "same-origin"
              }).then(function(response) {
                if (!response["ok"]) {
                  throw "failed to load wasm binary file at '" + wasmBinaryFile + "'"
                }
                return response["arrayBuffer"]()
              }).catch(function() {
                return getBinary()
              })
            }
            return new Promise(function(resolve, reject) {
              resolve(getBinary())
            })
          }

          function createWasm(env) {
            var info = {
              "env": env,
              "global": {
                "NaN": NaN,
                Infinity: Infinity
              },
              "global.Math": Math,
              "asm2wasm": asm2wasmImports
            };

            function receiveInstance(instance, module) {
              var exports = instance.exports;
              Module["asm"] = exports;
              removeRunDependency("wasm-instantiate")
            }
            addRunDependency("wasm-instantiate");

            function receiveInstantiatedSource(output) {
              receiveInstance(output["instance"])
            }

            function instantiateArrayBuffer(receiver) {
              return getBinaryPromise().then(function(binary) {
                return WebAssembly.instantiate(binary, info)
              }).then(receiver, function(reason) {
                err("failed to asynchronously prepare wasm: " + reason);
                abort(reason)
              })
            }

            function instantiateAsync() {
              if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && typeof fetch === "function") {
                fetch(wasmBinaryFile, {
                  credentials: "same-origin"
                }).then(function(response) {
                  var result = WebAssembly.instantiateStreaming(response, info);
                  return result.then(receiveInstantiatedSource, function(reason) {
                    err("wasm streaming compile failed: " + reason);
                    err("falling back to ArrayBuffer instantiation");
                    instantiateArrayBuffer(receiveInstantiatedSource)
                  })
                })
              } else {
                return instantiateArrayBuffer(receiveInstantiatedSource)
              }
            }
            if (Module["instantiateWasm"]) {
              try {
                var exports = Module["instantiateWasm"](info, receiveInstance);
                return exports
              } catch (e) {
                err("Module.instantiateWasm callback failed with error: " + e);
                return false
              }
            }
            instantiateAsync();
            return {}
          }
          Module["asm"] = function(global, env, providedBuffer) {
            env["memory"] = wasmMemory;
            env["table"] = wasmTable = new WebAssembly.Table({
              "initial": 42,
              "maximum": 42,
              "element": "anyfunc"
            });
            env["__memory_base"] = 1024;
            env["__table_base"] = 0;
            var exports = createWasm(env);
            return exports
          };
          var tempDouble;
          var tempI64;
          __ATINIT__.push({
            func: function() {
              __GLOBAL__sub_I_bind_cpp()
            }
          });

          function demangle(func) {
            return func
          }

          function demangleAll(text) {
            var regex = /\b__Z[\w\d_]+/g;
            return text.replace(regex, function(x) {
              var y = demangle(x);
              return x === y ? x : y + " [" + x + "]"
            })
          }

          function jsStackTrace() {
            var err = new Error;
            if (!err.stack) {
              try {
                throw new Error(0)
              } catch (e) {
                err = e
              }
              if (!err.stack) {
                return "(no stack trace available)"
              }
            }
            return err.stack.toString()
          }

          function stackTrace() {
            var js = jsStackTrace();
            if (Module["extraStackTrace"]) js += "\n" + Module["extraStackTrace"]();
            return demangleAll(js)
          }

          function ___lock() {}
          var PATH = {
            splitPath: function(filename) {
              var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
              return splitPathRe.exec(filename).slice(1)
            },
            normalizeArray: function(parts, allowAboveRoot) {
              var up = 0;
              for (var i = parts.length - 1; i >= 0; i--) {
                var last = parts[i];
                if (last === ".") {
                  parts.splice(i, 1)
                } else if (last === "..") {
                  parts.splice(i, 1);
                  up++
                } else if (up) {
                  parts.splice(i, 1);
                  up--
                }
              }
              if (allowAboveRoot) {
                for (; up; up--) {
                  parts.unshift("..")
                }
              }
              return parts
            },
            normalize: function(path) {
              var isAbsolute = path.charAt(0) === "/",
                trailingSlash = path.substr(-1) === "/";
              path = PATH.normalizeArray(path.split("/").filter(function(p) {
                return !!p
              }), !isAbsolute).join("/");
              if (!path && !isAbsolute) {
                path = "."
              }
              if (path && trailingSlash) {
                path += "/"
              }
              return (isAbsolute ? "/" : "") + path
            },
            dirname: function(path) {
              var result = PATH.splitPath(path),
                root = result[0],
                dir = result[1];
              if (!root && !dir) {
                return "."
              }
              if (dir) {
                dir = dir.substr(0, dir.length - 1)
              }
              return root + dir
            },
            basename: function(path) {
              if (path === "/") return "/";
              var lastSlash = path.lastIndexOf("/");
              if (lastSlash === -1) return path;
              return path.substr(lastSlash + 1)
            },
            extname: function(path) {
              return PATH.splitPath(path)[3]
            },
            join: function() {
              var paths = Array.prototype.slice.call(arguments, 0);
              return PATH.normalize(paths.join("/"))
            },
            join2: function(l, r) {
              return PATH.normalize(l + "/" + r)
            }
          };

          function ___setErrNo(value) {
            if (Module["___errno_location"]) HEAP32[Module["___errno_location"]() >> 2] = value;
            return value
          }
          var PATH_FS = {
            resolve: function() {
              var resolvedPath = "",
                resolvedAbsolute = false;
              for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
                var path = i >= 0 ? arguments[i] : FS.cwd();
                if (typeof path !== "string") {
                  throw new TypeError("Arguments to path.resolve must be strings")
                } else if (!path) {
                  return ""
                }
                resolvedPath = path + "/" + resolvedPath;
                resolvedAbsolute = path.charAt(0) === "/"
              }
              resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter(function(p) {
                return !!p
              }), !resolvedAbsolute).join("/");
              return (resolvedAbsolute ? "/" : "") + resolvedPath || "."
            },
            relative: function(from, to) {
              from = PATH_FS.resolve(from).substr(1);
              to = PATH_FS.resolve(to).substr(1);

              function trim(arr) {
                var start = 0;
                for (; start < arr.length; start++) {
                  if (arr[start] !== "") break
                }
                var end = arr.length - 1;
                for (; end >= 0; end--) {
                  if (arr[end] !== "") break
                }
                if (start > end) return [];
                return arr.slice(start, end - start + 1)
              }
              var fromParts = trim(from.split("/"));
              var toParts = trim(to.split("/"));
              var length = Math.min(fromParts.length, toParts.length);
              var samePartsLength = length;
              for (var i = 0; i < length; i++) {
                if (fromParts[i] !== toParts[i]) {
                  samePartsLength = i;
                  break
                }
              }
              var outputParts = [];
              for (var i = samePartsLength; i < fromParts.length; i++) {
                outputParts.push("..")
              }
              outputParts = outputParts.concat(toParts.slice(samePartsLength));
              return outputParts.join("/")
            }
          };
          var TTY = {
            ttys: [],
            init: function() {},
            shutdown: function() {},
            register: function(dev, ops) {
              TTY.ttys[dev] = {
                input: [],
                output: [],
                ops: ops
              };
              FS.registerDevice(dev, TTY.stream_ops)
            },
            stream_ops: {
              open: function(stream) {
                var tty = TTY.ttys[stream.node.rdev];
                if (!tty) {
                  throw new FS.ErrnoError(19)
                }
                stream.tty = tty;
                stream.seekable = false
              },
              close: function(stream) {
                stream.tty.ops.flush(stream.tty)
              },
              flush: function(stream) {
                stream.tty.ops.flush(stream.tty)
              },
              read: function(stream, buffer, offset, length, pos) {
                if (!stream.tty || !stream.tty.ops.get_char) {
                  throw new FS.ErrnoError(6)
                }
                var bytesRead = 0;
                for (var i = 0; i < length; i++) {
                  var result;
                  try {
                    result = stream.tty.ops.get_char(stream.tty)
                  } catch (e) {
                    throw new FS.ErrnoError(5)
                  }
                  if (result === undefined && bytesRead === 0) {
                    throw new FS.ErrnoError(11)
                  }
                  if (result === null || result === undefined) break;
                  bytesRead++;
                  buffer[offset + i] = result
                }
                if (bytesRead) {
                  stream.node.timestamp = Date.now()
                }
                return bytesRead
              },
              write: function(stream, buffer, offset, length, pos) {
                if (!stream.tty || !stream.tty.ops.put_char) {
                  throw new FS.ErrnoError(6)
                }
                try {
                  for (var i = 0; i < length; i++) {
                    stream.tty.ops.put_char(stream.tty, buffer[offset + i])
                  }
                } catch (e) {
                  throw new FS.ErrnoError(5)
                }
                if (length) {
                  stream.node.timestamp = Date.now()
                }
                return i
              }
            },
            default_tty_ops: {
              get_char: function(tty) {
                if (!tty.input.length) {
                  var result = null;
                  if (typeof window != "undefined" && typeof window.prompt == "function") {
                    result = window.prompt("Input: ");
                    if (result !== null) {
                      result += "\n"
                    }
                  } else if (typeof readline == "function") {
                    result = readline();
                    if (result !== null) {
                      result += "\n"
                    }
                  }
                  if (!result) {
                    return null
                  }
                  tty.input = intArrayFromString(result, true)
                }
                return tty.input.shift()
              },
              put_char: function(tty, val) {
                if (val === null || val === 10) {
                  out(UTF8ArrayToString(tty.output, 0));
                  tty.output = []
                } else {
                  if (val != 0) tty.output.push(val)
                }
              },
              flush: function(tty) {
                if (tty.output && tty.output.length > 0) {
                  out(UTF8ArrayToString(tty.output, 0));
                  tty.output = []
                }
              }
            },
            default_tty1_ops: {
              put_char: function(tty, val) {
                if (val === null || val === 10) {
                  err(UTF8ArrayToString(tty.output, 0));
                  tty.output = []
                } else {
                  if (val != 0) tty.output.push(val)
                }
              },
              flush: function(tty) {
                if (tty.output && tty.output.length > 0) {
                  err(UTF8ArrayToString(tty.output, 0));
                  tty.output = []
                }
              }
            }
          };
          var MEMFS = {
            ops_table: null,
            mount: function(mount) {
              return MEMFS.createNode(null, "/", 16384 | 511, 0)
            },
            createNode: function(parent, name, mode, dev) {
              if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
                throw new FS.ErrnoError(1)
              }
              if (!MEMFS.ops_table) {
                MEMFS.ops_table = {
                  dir: {
                    node: {
                      getattr: MEMFS.node_ops.getattr,
                      setattr: MEMFS.node_ops.setattr,
                      lookup: MEMFS.node_ops.lookup,
                      mknod: MEMFS.node_ops.mknod,
                      rename: MEMFS.node_ops.rename,
                      unlink: MEMFS.node_ops.unlink,
                      rmdir: MEMFS.node_ops.rmdir,
                      readdir: MEMFS.node_ops.readdir,
                      symlink: MEMFS.node_ops.symlink
                    },
                    stream: {
                      llseek: MEMFS.stream_ops.llseek
                    }
                  },
                  file: {
                    node: {
                      getattr: MEMFS.node_ops.getattr,
                      setattr: MEMFS.node_ops.setattr
                    },
                    stream: {
                      llseek: MEMFS.stream_ops.llseek,
                      read: MEMFS.stream_ops.read,
                      write: MEMFS.stream_ops.write,
                      allocate: MEMFS.stream_ops.allocate,
                      mmap: MEMFS.stream_ops.mmap,
                      msync: MEMFS.stream_ops.msync
                    }
                  },
                  link: {
                    node: {
                      getattr: MEMFS.node_ops.getattr,
                      setattr: MEMFS.node_ops.setattr,
                      readlink: MEMFS.node_ops.readlink
                    },
                    stream: {}
                  },
                  chrdev: {
                    node: {
                      getattr: MEMFS.node_ops.getattr,
                      setattr: MEMFS.node_ops.setattr
                    },
                    stream: FS.chrdev_stream_ops
                  }
                }
              }
              var node = FS.createNode(parent, name, mode, dev);
              if (FS.isDir(node.mode)) {
                node.node_ops = MEMFS.ops_table.dir.node;
                node.stream_ops = MEMFS.ops_table.dir.stream;
                node.contents = {}
              } else if (FS.isFile(node.mode)) {
                node.node_ops = MEMFS.ops_table.file.node;
                node.stream_ops = MEMFS.ops_table.file.stream;
                node.usedBytes = 0;
                node.contents = null
              } else if (FS.isLink(node.mode)) {
                node.node_ops = MEMFS.ops_table.link.node;
                node.stream_ops = MEMFS.ops_table.link.stream
              } else if (FS.isChrdev(node.mode)) {
                node.node_ops = MEMFS.ops_table.chrdev.node;
                node.stream_ops = MEMFS.ops_table.chrdev.stream
              }
              node.timestamp = Date.now();
              if (parent) {
                parent.contents[name] = node
              }
              return node
            },
            getFileDataAsRegularArray: function(node) {
              if (node.contents && node.contents.subarray) {
                var arr = [];
                for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);
                return arr
              }
              return node.contents
            },
            getFileDataAsTypedArray: function(node) {
              if (!node.contents) return new Uint8Array;
              if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);
              return new Uint8Array(node.contents)
            },
            expandFileStorage: function(node, newCapacity) {
              var prevCapacity = node.contents ? node.contents.length : 0;
              if (prevCapacity >= newCapacity) return;
              var CAPACITY_DOUBLING_MAX = 1024 * 1024;
              newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) | 0);
              if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);
              var oldContents = node.contents;
              node.contents = new Uint8Array(newCapacity);
              if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
              return
            },
            resizeFileStorage: function(node, newSize) {
              if (node.usedBytes == newSize) return;
              if (newSize == 0) {
                node.contents = null;
                node.usedBytes = 0;
                return
              }
              if (!node.contents || node.contents.subarray) {
                var oldContents = node.contents;
                node.contents = new Uint8Array(new ArrayBuffer(newSize));
                if (oldContents) {
                  node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)))
                }
                node.usedBytes = newSize;
                return
              }
              if (!node.contents) node.contents = [];
              if (node.contents.length > newSize) node.contents.length = newSize;
              else
                while (node.contents.length < newSize) node.contents.push(0);
              node.usedBytes = newSize
            },
            node_ops: {
              getattr: function(node) {
                var attr = {};
                attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
                attr.ino = node.id;
                attr.mode = node.mode;
                attr.nlink = 1;
                attr.uid = 0;
                attr.gid = 0;
                attr.rdev = node.rdev;
                if (FS.isDir(node.mode)) {
                  attr.size = 4096
                } else if (FS.isFile(node.mode)) {
                  attr.size = node.usedBytes
                } else if (FS.isLink(node.mode)) {
                  attr.size = node.link.length
                } else {
                  attr.size = 0
                }
                attr.atime = new Date(node.timestamp);
                attr.mtime = new Date(node.timestamp);
                attr.ctime = new Date(node.timestamp);
                attr.blksize = 4096;
                attr.blocks = Math.ceil(attr.size / attr.blksize);
                return attr
              },
              setattr: function(node, attr) {
                if (attr.mode !== undefined) {
                  node.mode = attr.mode
                }
                if (attr.timestamp !== undefined) {
                  node.timestamp = attr.timestamp
                }
                if (attr.size !== undefined) {
                  MEMFS.resizeFileStorage(node, attr.size)
                }
              },
              lookup: function(parent, name) {
                throw FS.genericErrors[2]
              },
              mknod: function(parent, name, mode, dev) {
                return MEMFS.createNode(parent, name, mode, dev)
              },
              rename: function(old_node, new_dir, new_name) {
                if (FS.isDir(old_node.mode)) {
                  var new_node;
                  try {
                    new_node = FS.lookupNode(new_dir, new_name)
                  } catch (e) {}
                  if (new_node) {
                    for (var i in new_node.contents) {
                      throw new FS.ErrnoError(39)
                    }
                  }
                }
                delete old_node.parent.contents[old_node.name];
                old_node.name = new_name;
                new_dir.contents[new_name] = old_node;
                old_node.parent = new_dir
              },
              unlink: function(parent, name) {
                delete parent.contents[name]
              },
              rmdir: function(parent, name) {
                var node = FS.lookupNode(parent, name);
                for (var i in node.contents) {
                  throw new FS.ErrnoError(39)
                }
                delete parent.contents[name]
              },
              readdir: function(node) {
                var entries = [".", ".."];
                for (var key in node.contents) {
                  if (!node.contents.hasOwnProperty(key)) {
                    continue
                  }
                  entries.push(key)
                }
                return entries
              },
              symlink: function(parent, newname, oldpath) {
                var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
                node.link = oldpath;
                return node
              },
              readlink: function(node) {
                if (!FS.isLink(node.mode)) {
                  throw new FS.ErrnoError(22)
                }
                return node.link
              }
            },
            stream_ops: {
              read: function(stream, buffer, offset, length, position) {
                var contents = stream.node.contents;
                if (position >= stream.node.usedBytes) return 0;
                var size = Math.min(stream.node.usedBytes - position, length);
                if (size > 8 && contents.subarray) {
                  buffer.set(contents.subarray(position, position + size), offset)
                } else {
                  for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i]
                }
                return size
              },
              write: function(stream, buffer, offset, length, position, canOwn) {
                canOwn = false;
                if (!length) return 0;
                var node = stream.node;
                node.timestamp = Date.now();
                if (buffer.subarray && (!node.contents || node.contents.subarray)) {
                  if (canOwn) {
                    node.contents = buffer.subarray(offset, offset + length);
                    node.usedBytes = length;
                    return length
                  } else if (node.usedBytes === 0 && position === 0) {
                    node.contents = new Uint8Array(buffer.subarray(offset, offset + length));
                    node.usedBytes = length;
                    return length
                  } else if (position + length <= node.usedBytes) {
                    node.contents.set(buffer.subarray(offset, offset + length), position);
                    return length
                  }
                }
                MEMFS.expandFileStorage(node, position + length);
                if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position);
                else {
                  for (var i = 0; i < length; i++) {
                    node.contents[position + i] = buffer[offset + i]
                  }
                }
                node.usedBytes = Math.max(node.usedBytes, position + length);
                return length
              },
              llseek: function(stream, offset, whence) {
                var position = offset;
                if (whence === 1) {
                  position += stream.position
                } else if (whence === 2) {
                  if (FS.isFile(stream.node.mode)) {
                    position += stream.node.usedBytes
                  }
                }
                if (position < 0) {
                  throw new FS.ErrnoError(22)
                }
                return position
              },
              allocate: function(stream, offset, length) {
                MEMFS.expandFileStorage(stream.node, offset + length);
                stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length)
              },
              mmap: function(stream, buffer, offset, length, position, prot, flags) {
                if (!FS.isFile(stream.node.mode)) {
                  throw new FS.ErrnoError(19)
                }
                var ptr;
                var allocated;
                var contents = stream.node.contents;
                if (!(flags & 2) && (contents.buffer === buffer || contents.buffer === buffer.buffer)) {
                  allocated = false;
                  ptr = contents.byteOffset
                } else {
                  if (position > 0 || position + length < stream.node.usedBytes) {
                    if (contents.subarray) {
                      contents = contents.subarray(position, position + length)
                    } else {
                      contents = Array.prototype.slice.call(contents, position, position + length)
                    }
                  }
                  allocated = true;
                  var fromHeap = buffer.buffer == HEAP8.buffer;
                  ptr = _malloc(length);
                  if (!ptr) {
                    throw new FS.ErrnoError(12)
                  }(fromHeap ? HEAP8 : buffer).set(contents, ptr)
                }
                return {
                  ptr: ptr,
                  allocated: allocated
                }
              },
              msync: function(stream, buffer, offset, length, mmapFlags) {
                if (!FS.isFile(stream.node.mode)) {
                  throw new FS.ErrnoError(19)
                }
                if (mmapFlags & 2) {
                  return 0
                }
                var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
                return 0
              }
            }
          };
          var FS = {
            root: null,
            mounts: [],
            devices: {},
            streams: [],
            nextInode: 1,
            nameTable: null,
            currentPath: "/",
            initialized: false,
            ignorePermissions: true,
            trackingDelegate: {},
            tracking: {
              openFlags: {
                READ: 1,
                WRITE: 2
              }
            },
            ErrnoError: null,
            genericErrors: {},
            filesystems: null,
            syncFSRequests: 0,
            handleFSError: function(e) {
              if (!(e instanceof FS.ErrnoError)) throw e + " : " + stackTrace();
              return ___setErrNo(e.errno)
            },
            lookupPath: function(path, opts) {
              path = PATH_FS.resolve(FS.cwd(), path);
              opts = opts || {};
              if (!path) return {
                path: "",
                node: null
              };
              var defaults = {
                follow_mount: true,
                recurse_count: 0
              };
              for (var key in defaults) {
                if (opts[key] === undefined) {
                  opts[key] = defaults[key]
                }
              }
              if (opts.recurse_count > 8) {
                throw new FS.ErrnoError(40)
              }
              var parts = PATH.normalizeArray(path.split("/").filter(function(p) {
                return !!p
              }), false);
              var current = FS.root;
              var current_path = "/";
              for (var i = 0; i < parts.length; i++) {
                var islast = i === parts.length - 1;
                if (islast && opts.parent) {
                  break
                }
                current = FS.lookupNode(current, parts[i]);
                current_path = PATH.join2(current_path, parts[i]);
                if (FS.isMountpoint(current)) {
                  if (!islast || islast && opts.follow_mount) {
                    current = current.mounted.root
                  }
                }
                if (!islast || opts.follow) {
                  var count = 0;
                  while (FS.isLink(current.mode)) {
                    var link = FS.readlink(current_path);
                    current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
                    var lookup = FS.lookupPath(current_path, {
                      recurse_count: opts.recurse_count
                    });
                    current = lookup.node;
                    if (count++ > 40) {
                      throw new FS.ErrnoError(40)
                    }
                  }
                }
              }
              return {
                path: current_path,
                node: current
              }
            },
            getPath: function(node) {
              var path;
              while (true) {
                if (FS.isRoot(node)) {
                  var mount = node.mount.mountpoint;
                  if (!path) return mount;
                  return mount[mount.length - 1] !== "/" ? mount + "/" + path : mount + path
                }
                path = path ? node.name + "/" + path : node.name;
                node = node.parent
              }
            },
            hashName: function(parentid, name) {
              var hash = 0;
              for (var i = 0; i < name.length; i++) {
                hash = (hash << 5) - hash + name.charCodeAt(i) | 0
              }
              return (parentid + hash >>> 0) % FS.nameTable.length
            },
            hashAddNode: function(node) {
              var hash = FS.hashName(node.parent.id, node.name);
              node.name_next = FS.nameTable[hash];
              FS.nameTable[hash] = node
            },
            hashRemoveNode: function(node) {
              var hash = FS.hashName(node.parent.id, node.name);
              if (FS.nameTable[hash] === node) {
                FS.nameTable[hash] = node.name_next
              } else {
                var current = FS.nameTable[hash];
                while (current) {
                  if (current.name_next === node) {
                    current.name_next = node.name_next;
                    break
                  }
                  current = current.name_next
                }
              }
            },
            lookupNode: function(parent, name) {
              var err = FS.mayLookup(parent);
              if (err) {
                throw new FS.ErrnoError(err, parent)
              }
              var hash = FS.hashName(parent.id, name);
              for (var node = FS.nameTable[hash]; node; node = node.name_next) {
                var nodeName = node.name;
                if (node.parent.id === parent.id && nodeName === name) {
                  return node
                }
              }
              return FS.lookup(parent, name)
            },
            createNode: function(parent, name, mode, rdev) {
              if (!FS.FSNode) {
                FS.FSNode = function(parent, name, mode, rdev) {
                  if (!parent) {
                    parent = this
                  }
                  this.parent = parent;
                  this.mount = parent.mount;
                  this.mounted = null;
                  this.id = FS.nextInode++;
                  this.name = name;
                  this.mode = mode;
                  this.node_ops = {};
                  this.stream_ops = {};
                  this.rdev = rdev
                };
                FS.FSNode.prototype = {};
                var readMode = 292 | 73;
                var writeMode = 146;
                Object.defineProperties(FS.FSNode.prototype, {
                  read: {
                    get: function() {
                      return (this.mode & readMode) === readMode
                    },
                    set: function(val) {
                      val ? this.mode |= readMode : this.mode &= ~readMode
                    }
                  },
                  write: {
                    get: function() {
                      return (this.mode & writeMode) === writeMode
                    },
                    set: function(val) {
                      val ? this.mode |= writeMode : this.mode &= ~writeMode
                    }
                  },
                  isFolder: {
                    get: function() {
                      return FS.isDir(this.mode)
                    }
                  },
                  isDevice: {
                    get: function() {
                      return FS.isChrdev(this.mode)
                    }
                  }
                })
              }
              var node = new FS.FSNode(parent, name, mode, rdev);
              FS.hashAddNode(node);
              return node
            },
            destroyNode: function(node) {
              FS.hashRemoveNode(node)
            },
            isRoot: function(node) {
              return node === node.parent
            },
            isMountpoint: function(node) {
              return !!node.mounted
            },
            isFile: function(mode) {
              return (mode & 61440) === 32768
            },
            isDir: function(mode) {
              return (mode & 61440) === 16384
            },
            isLink: function(mode) {
              return (mode & 61440) === 40960
            },
            isChrdev: function(mode) {
              return (mode & 61440) === 8192
            },
            isBlkdev: function(mode) {
              return (mode & 61440) === 24576
            },
            isFIFO: function(mode) {
              return (mode & 61440) === 4096
            },
            isSocket: function(mode) {
              return (mode & 49152) === 49152
            },
            flagModes: {
              "r": 0,
              "rs": 1052672,
              "r+": 2,
              "w": 577,
              "wx": 705,
              "xw": 705,
              "w+": 578,
              "wx+": 706,
              "xw+": 706,
              "a": 1089,
              "ax": 1217,
              "xa": 1217,
              "a+": 1090,
              "ax+": 1218,
              "xa+": 1218
            },
            modeStringToFlags: function(str) {
              var flags = FS.flagModes[str];
              if (typeof flags === "undefined") {
                throw new Error("Unknown file open mode: " + str)
              }
              return flags
            },
            flagsToPermissionString: function(flag) {
              var perms = ["r", "w", "rw"][flag & 3];
              if (flag & 512) {
                perms += "w"
              }
              return perms
            },
            nodePermissions: function(node, perms) {
              if (FS.ignorePermissions) {
                return 0
              }
              if (perms.indexOf("r") !== -1 && !(node.mode & 292)) {
                return 13
              } else if (perms.indexOf("w") !== -1 && !(node.mode & 146)) {
                return 13
              } else if (perms.indexOf("x") !== -1 && !(node.mode & 73)) {
                return 13
              }
              return 0
            },
            mayLookup: function(dir) {
              var err = FS.nodePermissions(dir, "x");
              if (err) return err;
              if (!dir.node_ops.lookup) return 13;
              return 0
            },
            mayCreate: function(dir, name) {
              try {
                var node = FS.lookupNode(dir, name);
                return 17
              } catch (e) {}
              return FS.nodePermissions(dir, "wx")
            },
            mayDelete: function(dir, name, isdir) {
              var node;
              try {
                node = FS.lookupNode(dir, name)
              } catch (e) {
                return e.errno
              }
              var err = FS.nodePermissions(dir, "wx");
              if (err) {
                return err
              }
              if (isdir) {
                if (!FS.isDir(node.mode)) {
                  return 20
                }
                if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
                  return 16
                }
              } else {
                if (FS.isDir(node.mode)) {
                  return 21
                }
              }
              return 0
            },
            mayOpen: function(node, flags) {
              if (!node) {
                return 2
              }
              if (FS.isLink(node.mode)) {
                return 40
              } else if (FS.isDir(node.mode)) {
                if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
                  return 21
                }
              }
              return FS.nodePermissions(node, FS.flagsToPermissionString(flags))
            },
            MAX_OPEN_FDS: 4096,
            nextfd: function(fd_start, fd_end) {
              fd_start = fd_start || 0;
              fd_end = fd_end || FS.MAX_OPEN_FDS;
              for (var fd = fd_start; fd <= fd_end; fd++) {
                if (!FS.streams[fd]) {
                  return fd
                }
              }
              throw new FS.ErrnoError(24)
            },
            getStream: function(fd) {
              return FS.streams[fd]
            },
            createStream: function(stream, fd_start, fd_end) {
              if (!FS.FSStream) {
                FS.FSStream = function() {};
                FS.FSStream.prototype = {};
                Object.defineProperties(FS.FSStream.prototype, {
                  object: {
                    get: function() {
                      return this.node
                    },
                    set: function(val) {
                      this.node = val
                    }
                  },
                  isRead: {
                    get: function() {
                      return (this.flags & 2097155) !== 1
                    }
                  },
                  isWrite: {
                    get: function() {
                      return (this.flags & 2097155) !== 0
                    }
                  },
                  isAppend: {
                    get: function() {
                      return this.flags & 1024
                    }
                  }
                })
              }
              var newStream = new FS.FSStream;
              for (var p in stream) {
                newStream[p] = stream[p]
              }
              stream = newStream;
              var fd = FS.nextfd(fd_start, fd_end);
              stream.fd = fd;
              FS.streams[fd] = stream;
              return stream
            },
            closeStream: function(fd) {
              FS.streams[fd] = null
            },
            chrdev_stream_ops: {
              open: function(stream) {
                var device = FS.getDevice(stream.node.rdev);
                stream.stream_ops = device.stream_ops;
                if (stream.stream_ops.open) {
                  stream.stream_ops.open(stream)
                }
              },
              llseek: function() {
                throw new FS.ErrnoError(29)
              }
            },
            major: function(dev) {
              return dev >> 8
            },
            minor: function(dev) {
              return dev & 255
            },
            makedev: function(ma, mi) {
              return ma << 8 | mi
            },
            registerDevice: function(dev, ops) {
              FS.devices[dev] = {
                stream_ops: ops
              }
            },
            getDevice: function(dev) {
              return FS.devices[dev]
            },
            getMounts: function(mount) {
              var mounts = [];
              var check = [mount];
              while (check.length) {
                var m = check.pop();
                mounts.push(m);
                check.push.apply(check, m.mounts)
              }
              return mounts
            },
            syncfs: function(populate, callback) {
              if (typeof populate === "function") {
                callback = populate;
                populate = false
              }
              FS.syncFSRequests++;
              if (FS.syncFSRequests > 1) {
                console.log("warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work")
              }
              var mounts = FS.getMounts(FS.root.mount);
              var completed = 0;

              function doCallback(err) {
                FS.syncFSRequests--;
                return callback(err)
              }

              function done(err) {
                if (err) {
                  if (!done.errored) {
                    done.errored = true;
                    return doCallback(err)
                  }
                  return
                }
                if (++completed >= mounts.length) {
                  doCallback(null)
                }
              }
              mounts.forEach(function(mount) {
                if (!mount.type.syncfs) {
                  return done(null)
                }
                mount.type.syncfs(mount, populate, done)
              })
            },
            mount: function(type, opts, mountpoint) {
              var root = mountpoint === "/";
              var pseudo = !mountpoint;
              var node;
              if (root && FS.root) {
                throw new FS.ErrnoError(16)
              } else if (!root && !pseudo) {
                var lookup = FS.lookupPath(mountpoint, {
                  follow_mount: false
                });
                mountpoint = lookup.path;
                node = lookup.node;
                if (FS.isMountpoint(node)) {
                  throw new FS.ErrnoError(16)
                }
                if (!FS.isDir(node.mode)) {
                  throw new FS.ErrnoError(20)
                }
              }
              var mount = {
                type: type,
                opts: opts,
                mountpoint: mountpoint,
                mounts: []
              };
              var mountRoot = type.mount(mount);
              mountRoot.mount = mount;
              mount.root = mountRoot;
              if (root) {
                FS.root = mountRoot
              } else if (node) {
                node.mounted = mount;
                if (node.mount) {
                  node.mount.mounts.push(mount)
                }
              }
              return mountRoot
            },
            unmount: function(mountpoint) {
              var lookup = FS.lookupPath(mountpoint, {
                follow_mount: false
              });
              if (!FS.isMountpoint(lookup.node)) {
                throw new FS.ErrnoError(22)
              }
              var node = lookup.node;
              var mount = node.mounted;
              var mounts = FS.getMounts(mount);
              Object.keys(FS.nameTable).forEach(function(hash) {
                var current = FS.nameTable[hash];
                while (current) {
                  var next = current.name_next;
                  if (mounts.indexOf(current.mount) !== -1) {
                    FS.destroyNode(current)
                  }
                  current = next
                }
              });
              node.mounted = null;
              var idx = node.mount.mounts.indexOf(mount);
              node.mount.mounts.splice(idx, 1)
            },
            lookup: function(parent, name) {
              return parent.node_ops.lookup(parent, name)
            },
            mknod: function(path, mode, dev) {
              var lookup = FS.lookupPath(path, {
                parent: true
              });
              var parent = lookup.node;
              var name = PATH.basename(path);
              if (!name || name === "." || name === "..") {
                throw new FS.ErrnoError(22)
              }
              var err = FS.mayCreate(parent, name);
              if (err) {
                throw new FS.ErrnoError(err)
              }
              if (!parent.node_ops.mknod) {
                throw new FS.ErrnoError(1)
              }
              return parent.node_ops.mknod(parent, name, mode, dev)
            },
            create: function(path, mode) {
              mode = mode !== undefined ? mode : 438;
              mode &= 4095;
              mode |= 32768;
              return FS.mknod(path, mode, 0)
            },
            mkdir: function(path, mode) {
              mode = mode !== undefined ? mode : 511;
              mode &= 511 | 512;
              mode |= 16384;
              return FS.mknod(path, mode, 0)
            },
            mkdirTree: function(path, mode) {
              var dirs = path.split("/");
              var d = "";
              for (var i = 0; i < dirs.length; ++i) {
                if (!dirs[i]) continue;
                d += "/" + dirs[i];
                try {
                  FS.mkdir(d, mode)
                } catch (e) {
                  if (e.errno != 17) throw e
                }
              }
            },
            mkdev: function(path, mode, dev) {
              if (typeof dev === "undefined") {
                dev = mode;
                mode = 438
              }
              mode |= 8192;
              return FS.mknod(path, mode, dev)
            },
            symlink: function(oldpath, newpath) {
              if (!PATH_FS.resolve(oldpath)) {
                throw new FS.ErrnoError(2)
              }
              var lookup = FS.lookupPath(newpath, {
                parent: true
              });
              var parent = lookup.node;
              if (!parent) {
                throw new FS.ErrnoError(2)
              }
              var newname = PATH.basename(newpath);
              var err = FS.mayCreate(parent, newname);
              if (err) {
                throw new FS.ErrnoError(err)
              }
              if (!parent.node_ops.symlink) {
                throw new FS.ErrnoError(1)
              }
              return parent.node_ops.symlink(parent, newname, oldpath)
            },
            rename: function(old_path, new_path) {
              var old_dirname = PATH.dirname(old_path);
              var new_dirname = PATH.dirname(new_path);
              var old_name = PATH.basename(old_path);
              var new_name = PATH.basename(new_path);
              var lookup, old_dir, new_dir;
              try {
                lookup = FS.lookupPath(old_path, {
                  parent: true
                });
                old_dir = lookup.node;
                lookup = FS.lookupPath(new_path, {
                  parent: true
                });
                new_dir = lookup.node
              } catch (e) {
                throw new FS.ErrnoError(16)
              }
              if (!old_dir || !new_dir) throw new FS.ErrnoError(2);
              if (old_dir.mount !== new_dir.mount) {
                throw new FS.ErrnoError(18)
              }
              var old_node = FS.lookupNode(old_dir, old_name);
              var relative = PATH_FS.relative(old_path, new_dirname);
              if (relative.charAt(0) !== ".") {
                throw new FS.ErrnoError(22)
              }
              relative = PATH_FS.relative(new_path, old_dirname);
              if (relative.charAt(0) !== ".") {
                throw new FS.ErrnoError(39)
              }
              var new_node;
              try {
                new_node = FS.lookupNode(new_dir, new_name)
              } catch (e) {}
              if (old_node === new_node) {
                return
              }
              var isdir = FS.isDir(old_node.mode);
              var err = FS.mayDelete(old_dir, old_name, isdir);
              if (err) {
                throw new FS.ErrnoError(err)
              }
              err = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
              if (err) {
                throw new FS.ErrnoError(err)
              }
              if (!old_dir.node_ops.rename) {
                throw new FS.ErrnoError(1)
              }
              if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
                throw new FS.ErrnoError(16)
              }
              if (new_dir !== old_dir) {
                err = FS.nodePermissions(old_dir, "w");
                if (err) {
                  throw new FS.ErrnoError(err)
                }
              }
              try {
                if (FS.trackingDelegate["willMovePath"]) {
                  FS.trackingDelegate["willMovePath"](old_path, new_path)
                }
              } catch (e) {
                console.log("FS.trackingDelegate['willMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message)
              }
              FS.hashRemoveNode(old_node);
              try {
                old_dir.node_ops.rename(old_node, new_dir, new_name)
              } catch (e) {
                throw e
              } finally {
                FS.hashAddNode(old_node)
              }
              try {
                if (FS.trackingDelegate["onMovePath"]) FS.trackingDelegate["onMovePath"](old_path, new_path)
              } catch (e) {
                console.log("FS.trackingDelegate['onMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message)
              }
            },
            rmdir: function(path) {
              var lookup = FS.lookupPath(path, {
                parent: true
              });
              var parent = lookup.node;
              var name = PATH.basename(path);
              var node = FS.lookupNode(parent, name);
              var err = FS.mayDelete(parent, name, true);
              if (err) {
                throw new FS.ErrnoError(err)
              }
              if (!parent.node_ops.rmdir) {
                throw new FS.ErrnoError(1)
              }
              if (FS.isMountpoint(node)) {
                throw new FS.ErrnoError(16)
              }
              try {
                if (FS.trackingDelegate["willDeletePath"]) {
                  FS.trackingDelegate["willDeletePath"](path)
                }
              } catch (e) {
                console.log("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message)
              }
              parent.node_ops.rmdir(parent, name);
              FS.destroyNode(node);
              try {
                if (FS.trackingDelegate["onDeletePath"]) FS.trackingDelegate["onDeletePath"](path)
              } catch (e) {
                console.log("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message)
              }
            },
            readdir: function(path) {
              var lookup = FS.lookupPath(path, {
                follow: true
              });
              var node = lookup.node;
              if (!node.node_ops.readdir) {
                throw new FS.ErrnoError(20)
              }
              return node.node_ops.readdir(node)
            },
            unlink: function(path) {
              var lookup = FS.lookupPath(path, {
                parent: true
              });
              var parent = lookup.node;
              var name = PATH.basename(path);
              var node = FS.lookupNode(parent, name);
              var err = FS.mayDelete(parent, name, false);
              if (err) {
                throw new FS.ErrnoError(err)
              }
              if (!parent.node_ops.unlink) {
                throw new FS.ErrnoError(1)
              }
              if (FS.isMountpoint(node)) {
                throw new FS.ErrnoError(16)
              }
              try {
                if (FS.trackingDelegate["willDeletePath"]) {
                  FS.trackingDelegate["willDeletePath"](path)
                }
              } catch (e) {
                console.log("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message)
              }
              parent.node_ops.unlink(parent, name);
              FS.destroyNode(node);
              try {
                if (FS.trackingDelegate["onDeletePath"]) FS.trackingDelegate["onDeletePath"](path)
              } catch (e) {
                console.log("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message)
              }
            },
            readlink: function(path) {
              var lookup = FS.lookupPath(path);
              var link = lookup.node;
              if (!link) {
                throw new FS.ErrnoError(2)
              }
              if (!link.node_ops.readlink) {
                throw new FS.ErrnoError(22)
              }
              return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link))
            },
            stat: function(path, dontFollow) {
              var lookup = FS.lookupPath(path, {
                follow: !dontFollow
              });
              var node = lookup.node;
              if (!node) {
                throw new FS.ErrnoError(2)
              }
              if (!node.node_ops.getattr) {
                throw new FS.ErrnoError(1)
              }
              return node.node_ops.getattr(node)
            },
            lstat: function(path) {
              return FS.stat(path, true)
            },
            chmod: function(path, mode, dontFollow) {
              var node;
              if (typeof path === "string") {
                var lookup = FS.lookupPath(path, {
                  follow: !dontFollow
                });
                node = lookup.node
              } else {
                node = path
              }
              if (!node.node_ops.setattr) {
                throw new FS.ErrnoError(1)
              }
              node.node_ops.setattr(node, {
                mode: mode & 4095 | node.mode & ~4095,
                timestamp: Date.now()
              })
            },
            lchmod: function(path, mode) {
              FS.chmod(path, mode, true)
            },
            fchmod: function(fd, mode) {
              var stream = FS.getStream(fd);
              if (!stream) {
                throw new FS.ErrnoError(9)
              }
              FS.chmod(stream.node, mode)
            },
            chown: function(path, uid, gid, dontFollow) {
              var node;
              if (typeof path === "string") {
                var lookup = FS.lookupPath(path, {
                  follow: !dontFollow
                });
                node = lookup.node
              } else {
                node = path
              }
              if (!node.node_ops.setattr) {
                throw new FS.ErrnoError(1)
              }
              node.node_ops.setattr(node, {
                timestamp: Date.now()
              })
            },
            lchown: function(path, uid, gid) {
              FS.chown(path, uid, gid, true)
            },
            fchown: function(fd, uid, gid) {
              var stream = FS.getStream(fd);
              if (!stream) {
                throw new FS.ErrnoError(9)
              }
              FS.chown(stream.node, uid, gid)
            },
            truncate: function(path, len) {
              if (len < 0) {
                throw new FS.ErrnoError(22)
              }
              var node;
              if (typeof path === "string") {
                var lookup = FS.lookupPath(path, {
                  follow: true
                });
                node = lookup.node
              } else {
                node = path
              }
              if (!node.node_ops.setattr) {
                throw new FS.ErrnoError(1)
              }
              if (FS.isDir(node.mode)) {
                throw new FS.ErrnoError(21)
              }
              if (!FS.isFile(node.mode)) {
                throw new FS.ErrnoError(22)
              }
              var err = FS.nodePermissions(node, "w");
              if (err) {
                throw new FS.ErrnoError(err)
              }
              node.node_ops.setattr(node, {
                size: len,
                timestamp: Date.now()
              })
            },
            ftruncate: function(fd, len) {
              var stream = FS.getStream(fd);
              if (!stream) {
                throw new FS.ErrnoError(9)
              }
              if ((stream.flags & 2097155) === 0) {
                throw new FS.ErrnoError(22)
              }
              FS.truncate(stream.node, len)
            },
            utime: function(path, atime, mtime) {
              var lookup = FS.lookupPath(path, {
                follow: true
              });
              var node = lookup.node;
              node.node_ops.setattr(node, {
                timestamp: Math.max(atime, mtime)
              })
            },
            open: function(path, flags, mode, fd_start, fd_end) {
              if (path === "") {
                throw new FS.ErrnoError(2)
              }
              flags = typeof flags === "string" ? FS.modeStringToFlags(flags) : flags;
              mode = typeof mode === "undefined" ? 438 : mode;
              if (flags & 64) {
                mode = mode & 4095 | 32768
              } else {
                mode = 0
              }
              var node;
              if (typeof path === "object") {
                node = path
              } else {
                path = PATH.normalize(path);
                try {
                  var lookup = FS.lookupPath(path, {
                    follow: !(flags & 131072)
                  });
                  node = lookup.node
                } catch (e) {}
              }
              var created = false;
              if (flags & 64) {
                if (node) {
                  if (flags & 128) {
                    throw new FS.ErrnoError(17)
                  }
                } else {
                  node = FS.mknod(path, mode, 0);
                  created = true
                }
              }
              if (!node) {
                throw new FS.ErrnoError(2)
              }
              if (FS.isChrdev(node.mode)) {
                flags &= ~512
              }
              if (flags & 65536 && !FS.isDir(node.mode)) {
                throw new FS.ErrnoError(20)
              }
              if (!created) {
                var err = FS.mayOpen(node, flags);
                if (err) {
                  throw new FS.ErrnoError(err)
                }
              }
              if (flags & 512) {
                FS.truncate(node, 0)
              }
              flags &= ~(128 | 512);
              var stream = FS.createStream({
                node: node,
                path: FS.getPath(node),
                flags: flags,
                seekable: true,
                position: 0,
                stream_ops: node.stream_ops,
                ungotten: [],
                error: false
              }, fd_start, fd_end);
              if (stream.stream_ops.open) {
                stream.stream_ops.open(stream)
              }
              if (Module["logReadFiles"] && !(flags & 1)) {
                if (!FS.readFiles) FS.readFiles = {};
                if (!(path in FS.readFiles)) {
                  FS.readFiles[path] = 1;
                  console.log("FS.trackingDelegate error on read file: " + path)
                }
              }
              try {
                if (FS.trackingDelegate["onOpenFile"]) {
                  var trackingFlags = 0;
                  if ((flags & 2097155) !== 1) {
                    trackingFlags |= FS.tracking.openFlags.READ
                  }
                  if ((flags & 2097155) !== 0) {
                    trackingFlags |= FS.tracking.openFlags.WRITE
                  }
                  FS.trackingDelegate["onOpenFile"](path, trackingFlags)
                }
              } catch (e) {
                console.log("FS.trackingDelegate['onOpenFile']('" + path + "', flags) threw an exception: " + e.message)
              }
              return stream
            },
            close: function(stream) {
              if (FS.isClosed(stream)) {
                throw new FS.ErrnoError(9)
              }
              if (stream.getdents) stream.getdents = null;
              try {
                if (stream.stream_ops.close) {
                  stream.stream_ops.close(stream)
                }
              } catch (e) {
                throw e
              } finally {
                FS.closeStream(stream.fd)
              }
              stream.fd = null
            },
            isClosed: function(stream) {
              return stream.fd === null
            },
            llseek: function(stream, offset, whence) {
              if (FS.isClosed(stream)) {
                throw new FS.ErrnoError(9)
              }
              if (!stream.seekable || !stream.stream_ops.llseek) {
                throw new FS.ErrnoError(29)
              }
              if (whence != 0 && whence != 1 && whence != 2) {
                throw new FS.ErrnoError(22)
              }
              stream.position = stream.stream_ops.llseek(stream, offset, whence);
              stream.ungotten = [];
              return stream.position
            },
            read: function(stream, buffer, offset, length, position) {
              if (length < 0 || position < 0) {
                throw new FS.ErrnoError(22)
              }
              if (FS.isClosed(stream)) {
                throw new FS.ErrnoError(9)
              }
              if ((stream.flags & 2097155) === 1) {
                throw new FS.ErrnoError(9)
              }
              if (FS.isDir(stream.node.mode)) {
                throw new FS.ErrnoError(21)
              }
              if (!stream.stream_ops.read) {
                throw new FS.ErrnoError(22)
              }
              var seeking = typeof position !== "undefined";
              if (!seeking) {
                position = stream.position
              } else if (!stream.seekable) {
                throw new FS.ErrnoError(29)
              }
              var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
              if (!seeking) stream.position += bytesRead;
              return bytesRead
            },
            write: function(stream, buffer, offset, length, position, canOwn) {
              if (length < 0 || position < 0) {
                throw new FS.ErrnoError(22)
              }
              if (FS.isClosed(stream)) {
                throw new FS.ErrnoError(9)
              }
              if ((stream.flags & 2097155) === 0) {
                throw new FS.ErrnoError(9)
              }
              if (FS.isDir(stream.node.mode)) {
                throw new FS.ErrnoError(21)
              }
              if (!stream.stream_ops.write) {
                throw new FS.ErrnoError(22)
              }
              if (stream.flags & 1024) {
                FS.llseek(stream, 0, 2)
              }
              var seeking = typeof position !== "undefined";
              if (!seeking) {
                position = stream.position
              } else if (!stream.seekable) {
                throw new FS.ErrnoError(29)
              }
              var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
              if (!seeking) stream.position += bytesWritten;
              try {
                if (stream.path && FS.trackingDelegate["onWriteToFile"]) FS.trackingDelegate["onWriteToFile"](stream.path)
              } catch (e) {
                console.log("FS.trackingDelegate['onWriteToFile']('" + stream.path + "') threw an exception: " + e.message)
              }
              return bytesWritten
            },
            allocate: function(stream, offset, length) {
              if (FS.isClosed(stream)) {
                throw new FS.ErrnoError(9)
              }
              if (offset < 0 || length <= 0) {
                throw new FS.ErrnoError(22)
              }
              if ((stream.flags & 2097155) === 0) {
                throw new FS.ErrnoError(9)
              }
              if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
                throw new FS.ErrnoError(19)
              }
              if (!stream.stream_ops.allocate) {
                throw new FS.ErrnoError(95)
              }
              stream.stream_ops.allocate(stream, offset, length)
            },
            mmap: function(stream, buffer, offset, length, position, prot, flags) {
              if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
                throw new FS.ErrnoError(13)
              }
              if ((stream.flags & 2097155) === 1) {
                throw new FS.ErrnoError(13)
              }
              if (!stream.stream_ops.mmap) {
                throw new FS.ErrnoError(19)
              }
              return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags)
            },
            msync: function(stream, buffer, offset, length, mmapFlags) {
              if (!stream || !stream.stream_ops.msync) {
                return 0
              }
              return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags)
            },
            munmap: function(stream) {
              return 0
            },
            ioctl: function(stream, cmd, arg) {
              if (!stream.stream_ops.ioctl) {
                throw new FS.ErrnoError(25)
              }
              return stream.stream_ops.ioctl(stream, cmd, arg)
            },
            readFile: function(path, opts) {
              opts = opts || {};
              opts.flags = opts.flags || "r";
              opts.encoding = opts.encoding || "binary";
              if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
                throw new Error('Invalid encoding type "' + opts.encoding + '"')
              }
              var ret;
              var stream = FS.open(path, opts.flags);
              var stat = FS.stat(path);
              var length = stat.size;
              var buf = new Uint8Array(length);
              FS.read(stream, buf, 0, length, 0);
              if (opts.encoding === "utf8") {
                ret = UTF8ArrayToString(buf, 0)
              } else if (opts.encoding === "binary") {
                ret = buf
              }
              FS.close(stream);
              return ret
            },
            writeFile: function(path, data, opts) {
              opts = opts || {};
              opts.flags = opts.flags || "w";
              var stream = FS.open(path, opts.flags, opts.mode);
              if (typeof data === "string") {
                var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
                var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
                FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn)
              } else if (ArrayBuffer.isView(data)) {
                FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn)
              } else {
                throw new Error("Unsupported data type")
              }
              FS.close(stream)
            },
            cwd: function() {
              return FS.currentPath
            },
            chdir: function(path) {
              var lookup = FS.lookupPath(path, {
                follow: true
              });
              if (lookup.node === null) {
                throw new FS.ErrnoError(2)
              }
              if (!FS.isDir(lookup.node.mode)) {
                throw new FS.ErrnoError(20)
              }
              var err = FS.nodePermissions(lookup.node, "x");
              if (err) {
                throw new FS.ErrnoError(err)
              }
              FS.currentPath = lookup.path
            },
            createDefaultDirectories: function() {
              FS.mkdir("/tmp");
              FS.mkdir("/home");
              FS.mkdir("/home/web_user")
            },
            createDefaultDevices: function() {
              FS.mkdir("/dev");
              FS.registerDevice(FS.makedev(1, 3), {
                read: function() {
                  return 0
                },
                write: function(stream, buffer, offset, length, pos) {
                  return length
                }
              });
              FS.mkdev("/dev/null", FS.makedev(1, 3));
              TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
              TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
              FS.mkdev("/dev/tty", FS.makedev(5, 0));
              FS.mkdev("/dev/tty1", FS.makedev(6, 0));
              var random_device;
              if (typeof crypto === "object" && typeof crypto["getRandomValues"] === "function") {
                var randomBuffer = new Uint8Array(1);
                random_device = function() {
                  crypto.getRandomValues(randomBuffer);
                  return randomBuffer[0]
                }
              } else {}
              if (!random_device) {
                random_device = function() {
                  abort("random_device")
                }
              }
              FS.createDevice("/dev", "random", random_device);
              FS.createDevice("/dev", "urandom", random_device);
              FS.mkdir("/dev/shm");
              FS.mkdir("/dev/shm/tmp")
            },
            createSpecialDirectories: function() {
              FS.mkdir("/proc");
              FS.mkdir("/proc/self");
              FS.mkdir("/proc/self/fd");
              FS.mount({
                mount: function() {
                  var node = FS.createNode("/proc/self", "fd", 16384 | 511, 73);
                  node.node_ops = {
                    lookup: function(parent, name) {
                      var fd = +name;
                      var stream = FS.getStream(fd);
                      if (!stream) throw new FS.ErrnoError(9);
                      var ret = {
                        parent: null,
                        mount: {
                          mountpoint: "fake"
                        },
                        node_ops: {
                          readlink: function() {
                            return stream.path
                          }
                        }
                      };
                      ret.parent = ret;
                      return ret
                    }
                  };
                  return node
                }
              }, {}, "/proc/self/fd")
            },
            createStandardStreams: function() {
              if (Module["stdin"]) {
                FS.createDevice("/dev", "stdin", Module["stdin"])
              } else {
                FS.symlink("/dev/tty", "/dev/stdin")
              }
              if (Module["stdout"]) {
                FS.createDevice("/dev", "stdout", null, Module["stdout"])
              } else {
                FS.symlink("/dev/tty", "/dev/stdout")
              }
              if (Module["stderr"]) {
                FS.createDevice("/dev", "stderr", null, Module["stderr"])
              } else {
                FS.symlink("/dev/tty1", "/dev/stderr")
              }
              var stdin = FS.open("/dev/stdin", "r");
              var stdout = FS.open("/dev/stdout", "w");
              var stderr = FS.open("/dev/stderr", "w")
            },
            ensureErrnoError: function() {
              if (FS.ErrnoError) return;
              FS.ErrnoError = function ErrnoError(errno, node) {
                this.node = node;
                this.setErrno = function(errno) {
                  this.errno = errno
                };
                this.setErrno(errno);
                this.message = "FS error"
              };
              FS.ErrnoError.prototype = new Error;
              FS.ErrnoError.prototype.constructor = FS.ErrnoError;
              [2].forEach(function(code) {
                FS.genericErrors[code] = new FS.ErrnoError(code);
                FS.genericErrors[code].stack = "<generic error, no stack>"
              })
            },
            staticInit: function() {
              FS.ensureErrnoError();
              FS.nameTable = new Array(4096);
              FS.mount(MEMFS, {}, "/");
              FS.createDefaultDirectories();
              FS.createDefaultDevices();
              FS.createSpecialDirectories();
              FS.filesystems = {
                "MEMFS": MEMFS
              }
            },
            init: function(input, output, error) {
              FS.init.initialized = true;
              FS.ensureErrnoError();
              Module["stdin"] = input || Module["stdin"];
              Module["stdout"] = output || Module["stdout"];
              Module["stderr"] = error || Module["stderr"];
              FS.createStandardStreams()
            },
            quit: function() {
              FS.init.initialized = false;
              var fflush = Module["_fflush"];
              if (fflush) fflush(0);
              for (var i = 0; i < FS.streams.length; i++) {
                var stream = FS.streams[i];
                if (!stream) {
                  continue
                }
                FS.close(stream)
              }
            },
            getMode: function(canRead, canWrite) {
              var mode = 0;
              if (canRead) mode |= 292 | 73;
              if (canWrite) mode |= 146;
              return mode
            },
            joinPath: function(parts, forceRelative) {
              var path = PATH.join.apply(null, parts);
              if (forceRelative && path[0] == "/") path = path.substr(1);
              return path
            },
            absolutePath: function(relative, base) {
              return PATH_FS.resolve(base, relative)
            },
            standardizePath: function(path) {
              return PATH.normalize(path)
            },
            findObject: function(path, dontResolveLastLink) {
              var ret = FS.analyzePath(path, dontResolveLastLink);
              if (ret.exists) {
                return ret.object
              } else {
                ___setErrNo(ret.error);
                return null
              }
            },
            analyzePath: function(path, dontResolveLastLink) {
              try {
                var lookup = FS.lookupPath(path, {
                  follow: !dontResolveLastLink
                });
                path = lookup.path
              } catch (e) {}
              var ret = {
                isRoot: false,
                exists: false,
                error: 0,
                name: null,
                path: null,
                object: null,
                parentExists: false,
                parentPath: null,
                parentObject: null
              };
              try {
                var lookup = FS.lookupPath(path, {
                  parent: true
                });
                ret.parentExists = true;
                ret.parentPath = lookup.path;
                ret.parentObject = lookup.node;
                ret.name = PATH.basename(path);
                lookup = FS.lookupPath(path, {
                  follow: !dontResolveLastLink
                });
                ret.exists = true;
                ret.path = lookup.path;
                ret.object = lookup.node;
                ret.name = lookup.node.name;
                ret.isRoot = lookup.path === "/"
              } catch (e) {
                ret.error = e.errno
              }
              return ret
            },
            createFolder: function(parent, name, canRead, canWrite) {
              var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
              var mode = FS.getMode(canRead, canWrite);
              return FS.mkdir(path, mode)
            },
            createPath: function(parent, path, canRead, canWrite) {
              parent = typeof parent === "string" ? parent : FS.getPath(parent);
              var parts = path.split("/").reverse();
              while (parts.length) {
                var part = parts.pop();
                if (!part) continue;
                var current = PATH.join2(parent, part);
                try {
                  FS.mkdir(current)
                } catch (e) {}
                parent = current
              }
              return current
            },
            createFile: function(parent, name, properties, canRead, canWrite) {
              var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
              var mode = FS.getMode(canRead, canWrite);
              return FS.create(path, mode)
            },
            createDataFile: function(parent, name, data, canRead, canWrite, canOwn) {
              var path = name ? PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name) : parent;
              var mode = FS.getMode(canRead, canWrite);
              var node = FS.create(path, mode);
              if (data) {
                if (typeof data === "string") {
                  var arr = new Array(data.length);
                  for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
                  data = arr
                }
                FS.chmod(node, mode | 146);
                var stream = FS.open(node, "w");
                FS.write(stream, data, 0, data.length, 0, canOwn);
                FS.close(stream);
                FS.chmod(node, mode)
              }
              return node
            },
            createDevice: function(parent, name, input, output) {
              var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
              var mode = FS.getMode(!!input, !!output);
              if (!FS.createDevice.major) FS.createDevice.major = 64;
              var dev = FS.makedev(FS.createDevice.major++, 0);
              FS.registerDevice(dev, {
                open: function(stream) {
                  stream.seekable = false
                },
                close: function(stream) {
                  if (output && output.buffer && output.buffer.length) {
                    output(10)
                  }
                },
                read: function(stream, buffer, offset, length, pos) {
                  var bytesRead = 0;
                  for (var i = 0; i < length; i++) {
                    var result;
                    try {
                      result = input()
                    } catch (e) {
                      throw new FS.ErrnoError(5)
                    }
                    if (result === undefined && bytesRead === 0) {
                      throw new FS.ErrnoError(11)
                    }
                    if (result === null || result === undefined) break;
                    bytesRead++;
                    buffer[offset + i] = result
                  }
                  if (bytesRead) {
                    stream.node.timestamp = Date.now()
                  }
                  return bytesRead
                },
                write: function(stream, buffer, offset, length, pos) {
                  for (var i = 0; i < length; i++) {
                    try {
                      output(buffer[offset + i])
                    } catch (e) {
                      throw new FS.ErrnoError(5)
                    }
                  }
                  if (length) {
                    stream.node.timestamp = Date.now()
                  }
                  return i
                }
              });
              return FS.mkdev(path, mode, dev)
            },
            createLink: function(parent, name, target, canRead, canWrite) {
              var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
              return FS.symlink(target, path)
            },
            forceLoadFile: function(obj) {
              if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
              var success = true;
              if (typeof XMLHttpRequest !== "undefined") {
                throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.")
              } else if (read_) {
                try {
                  obj.contents = intArrayFromString(read_(obj.url), true);
                  obj.usedBytes = obj.contents.length
                } catch (e) {
                  success = false
                }
              } else {
                throw new Error("Cannot load without read() or XMLHttpRequest.")
              }
              if (!success) ___setErrNo(5);
              return success
            },
            createLazyFile: function(parent, name, url, canRead, canWrite) {
              function LazyUint8Array() {
                this.lengthKnown = false;
                this.chunks = []
              }
              LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
                if (idx > this.length - 1 || idx < 0) {
                  return undefined
                }
                var chunkOffset = idx % this.chunkSize;
                var chunkNum = idx / this.chunkSize | 0;
                return this.getter(chunkNum)[chunkOffset]
              };
              LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
                this.getter = getter
              };
              LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
                var xhr = new XMLHttpRequest;
                xhr.open("HEAD", url, false);
                xhr.send(null);
                if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
                var datalength = Number(xhr.getResponseHeader("Content-length"));
                var header;
                var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
                var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
                var chunkSize = 1024 * 1024;
                if (!hasByteServing) chunkSize = datalength;
                var doXHR = function(from, to) {
                  if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
                  if (to > datalength - 1) throw new Error("only " + datalength + " bytes available! programmer error!");
                  var xhr = new XMLHttpRequest;
                  xhr.open("GET", url, false);
                  if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
                  if (typeof Uint8Array != "undefined") xhr.responseType = "arraybuffer";
                  if (xhr.overrideMimeType) {
                    xhr.overrideMimeType("text/plain; charset=x-user-defined")
                  }
                  xhr.send(null);
                  if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
                  if (xhr.response !== undefined) {
                    return new Uint8Array(xhr.response || [])
                  } else {
                    return intArrayFromString(xhr.responseText || "", true)
                  }
                };
                var lazyArray = this;
                lazyArray.setDataGetter(function(chunkNum) {
                  var start = chunkNum * chunkSize;
                  var end = (chunkNum + 1) * chunkSize - 1;
                  end = Math.min(end, datalength - 1);
                  if (typeof lazyArray.chunks[chunkNum] === "undefined") {
                    lazyArray.chunks[chunkNum] = doXHR(start, end)
                  }
                  if (typeof lazyArray.chunks[chunkNum] === "undefined") throw new Error("doXHR failed!");
                  return lazyArray.chunks[chunkNum]
                });
                if (usesGzip || !datalength) {
                  chunkSize = datalength = 1;
                  datalength = this.getter(0).length;
                  chunkSize = datalength;
                  console.log("LazyFiles on gzip forces download of the whole file when length is accessed")
                }
                this._length = datalength;
                this._chunkSize = chunkSize;
                this.lengthKnown = true
              };
              if (typeof XMLHttpRequest !== "undefined") {
                if (!ENVIRONMENT_IS_WORKER) throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
                var lazyArray = new LazyUint8Array;
                Object.defineProperties(lazyArray, {
                  length: {
                    get: function() {
                      if (!this.lengthKnown) {
                        this.cacheLength()
                      }
                      return this._length
                    }
                  },
                  chunkSize: {
                    get: function() {
                      if (!this.lengthKnown) {
                        this.cacheLength()
                      }
                      return this._chunkSize
                    }
                  }
                });
                var properties = {
                  isDevice: false,
                  contents: lazyArray
                }
              } else {
                var properties = {
                  isDevice: false,
                  url: url
                }
              }
              var node = FS.createFile(parent, name, properties, canRead, canWrite);
              if (properties.contents) {
                node.contents = properties.contents
              } else if (properties.url) {
                node.contents = null;
                node.url = properties.url
              }
              Object.defineProperties(node, {
                usedBytes: {
                  get: function() {
                    return this.contents.length
                  }
                }
              });
              var stream_ops = {};
              var keys = Object.keys(node.stream_ops);
              keys.forEach(function(key) {
                var fn = node.stream_ops[key];
                stream_ops[key] = function forceLoadLazyFile() {
                  if (!FS.forceLoadFile(node)) {
                    throw new FS.ErrnoError(5)
                  }
                  return fn.apply(null, arguments)
                }
              });
              stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {
                if (!FS.forceLoadFile(node)) {
                  throw new FS.ErrnoError(5)
                }
                var contents = stream.node.contents;
                if (position >= contents.length) return 0;
                var size = Math.min(contents.length - position, length);
                if (contents.slice) {
                  for (var i = 0; i < size; i++) {
                    buffer[offset + i] = contents[position + i]
                  }
                } else {
                  for (var i = 0; i < size; i++) {
                    buffer[offset + i] = contents.get(position + i)
                  }
                }
                return size
              };
              node.stream_ops = stream_ops;
              return node
            },
            createPreloadedFile: function(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
              Browser.init();
              var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
              var dep = getUniqueRunDependency("cp " + fullname);

              function processData(byteArray) {
                function finish(byteArray) {
                  if (preFinish) preFinish();
                  if (!dontCreateFile) {
                    FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn)
                  }
                  if (onload) onload();
                  removeRunDependency(dep)
                }
                var handled = false;
                Module["preloadPlugins"].forEach(function(plugin) {
                  if (handled) return;
                  if (plugin["canHandle"](fullname)) {
                    plugin["handle"](byteArray, fullname, finish, function() {
                      if (onerror) onerror();
                      removeRunDependency(dep)
                    });
                    handled = true
                  }
                });
                if (!handled) finish(byteArray)
              }
              addRunDependency(dep);
              if (typeof url == "string") {
                Browser.asyncLoad(url, function(byteArray) {
                  processData(byteArray)
                }, onerror)
              } else {
                processData(url)
              }
            },
            indexedDB: function() {
              return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB
            },
            DB_NAME: function() {
              return "EM_FS_" + window.location.pathname
            },
            DB_VERSION: 20,
            DB_STORE_NAME: "FILE_DATA",
            saveFilesToDB: function(paths, onload, onerror) {
              onload = onload || function() {};
              onerror = onerror || function() {};
              var indexedDB = FS.indexedDB();
              try {
                var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION)
              } catch (e) {
                return onerror(e)
              }
              openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
                console.log("creating db");
                var db = openRequest.result;
                db.createObjectStore(FS.DB_STORE_NAME)
              };
              openRequest.onsuccess = function openRequest_onsuccess() {
                var db = openRequest.result;
                var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite");
                var files = transaction.objectStore(FS.DB_STORE_NAME);
                var ok = 0,
                  fail = 0,
                  total = paths.length;

                function finish() {
                  if (fail == 0) onload();
                  else onerror()
                }
                paths.forEach(function(path) {
                  var putRequest = files.put(FS.analyzePath(path).object.contents, path);
                  putRequest.onsuccess = function putRequest_onsuccess() {
                    ok++;
                    if (ok + fail == total) finish()
                  };
                  putRequest.onerror = function putRequest_onerror() {
                    fail++;
                    if (ok + fail == total) finish()
                  }
                });
                transaction.onerror = onerror
              };
              openRequest.onerror = onerror
            },
            loadFilesFromDB: function(paths, onload, onerror) {
              onload = onload || function() {};
              onerror = onerror || function() {};
              var indexedDB = FS.indexedDB();
              try {
                var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION)
              } catch (e) {
                return onerror(e)
              }
              openRequest.onupgradeneeded = onerror;
              openRequest.onsuccess = function openRequest_onsuccess() {
                var db = openRequest.result;
                try {
                  var transaction = db.transaction([FS.DB_STORE_NAME], "readonly")
                } catch (e) {
                  onerror(e);
                  return
                }
                var files = transaction.objectStore(FS.DB_STORE_NAME);
                var ok = 0,
                  fail = 0,
                  total = paths.length;

                function finish() {
                  if (fail == 0) onload();
                  else onerror()
                }
                paths.forEach(function(path) {
                  var getRequest = files.get(path);
                  getRequest.onsuccess = function getRequest_onsuccess() {
                    if (FS.analyzePath(path).exists) {
                      FS.unlink(path)
                    }
                    FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
                    ok++;
                    if (ok + fail == total) finish()
                  };
                  getRequest.onerror = function getRequest_onerror() {
                    fail++;
                    if (ok + fail == total) finish()
                  }
                });
                transaction.onerror = onerror
              };
              openRequest.onerror = onerror
            }
          };
          var SYSCALLS = {
            DEFAULT_POLLMASK: 5,
            mappings: {},
            umask: 511,
            calculateAt: function(dirfd, path) {
              if (path[0] !== "/") {
                var dir;
                if (dirfd === -100) {
                  dir = FS.cwd()
                } else {
                  var dirstream = FS.getStream(dirfd);
                  if (!dirstream) throw new FS.ErrnoError(9);
                  dir = dirstream.path
                }
                path = PATH.join2(dir, path)
              }
              return path
            },
            doStat: function(func, path, buf) {
              try {
                var stat = func(path)
              } catch (e) {
                if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
                  return -20
                }
                throw e
              }
              HEAP32[buf >> 2] = stat.dev;
              HEAP32[buf + 4 >> 2] = 0;
              HEAP32[buf + 8 >> 2] = stat.ino;
              HEAP32[buf + 12 >> 2] = stat.mode;
              HEAP32[buf + 16 >> 2] = stat.nlink;
              HEAP32[buf + 20 >> 2] = stat.uid;
              HEAP32[buf + 24 >> 2] = stat.gid;
              HEAP32[buf + 28 >> 2] = stat.rdev;
              HEAP32[buf + 32 >> 2] = 0;
              tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
              HEAP32[buf + 48 >> 2] = 4096;
              HEAP32[buf + 52 >> 2] = stat.blocks;
              HEAP32[buf + 56 >> 2] = stat.atime.getTime() / 1e3 | 0;
              HEAP32[buf + 60 >> 2] = 0;
              HEAP32[buf + 64 >> 2] = stat.mtime.getTime() / 1e3 | 0;
              HEAP32[buf + 68 >> 2] = 0;
              HEAP32[buf + 72 >> 2] = stat.ctime.getTime() / 1e3 | 0;
              HEAP32[buf + 76 >> 2] = 0;
              tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 80 >> 2] = tempI64[0], HEAP32[buf + 84 >> 2] = tempI64[1];
              return 0
            },
            doMsync: function(addr, stream, len, flags) {
              var buffer = new Uint8Array(HEAPU8.subarray(addr, addr + len));
              FS.msync(stream, buffer, 0, len, flags)
            },
            doMkdir: function(path, mode) {
              path = PATH.normalize(path);
              if (path[path.length - 1] === "/") path = path.substr(0, path.length - 1);
              FS.mkdir(path, mode, 0);
              return 0
            },
            doMknod: function(path, mode, dev) {
              switch (mode & 61440) {
                case 32768:
                case 8192:
                case 24576:
                case 4096:
                case 49152:
                  break;
                default:
                  return -22
              }
              FS.mknod(path, mode, dev);
              return 0
            },
            doReadlink: function(path, buf, bufsize) {
              if (bufsize <= 0) return -22;
              var ret = FS.readlink(path);
              var len = Math.min(bufsize, lengthBytesUTF8(ret));
              var endChar = HEAP8[buf + len];
              stringToUTF8(ret, buf, bufsize + 1);
              HEAP8[buf + len] = endChar;
              return len
            },
            doAccess: function(path, amode) {
              if (amode & ~7) {
                return -22
              }
              var node;
              var lookup = FS.lookupPath(path, {
                follow: true
              });
              node = lookup.node;
              if (!node) {
                return -2
              }
              var perms = "";
              if (amode & 4) perms += "r";
              if (amode & 2) perms += "w";
              if (amode & 1) perms += "x";
              if (perms && FS.nodePermissions(node, perms)) {
                return -13
              }
              return 0
            },
            doDup: function(path, flags, suggestFD) {
              var suggest = FS.getStream(suggestFD);
              if (suggest) FS.close(suggest);
              return FS.open(path, flags, 0, suggestFD, suggestFD).fd
            },
            doReadv: function(stream, iov, iovcnt, offset) {
              var ret = 0;
              for (var i = 0; i < iovcnt; i++) {
                var ptr = HEAP32[iov + i * 8 >> 2];
                var len = HEAP32[iov + (i * 8 + 4) >> 2];
                var curr = FS.read(stream, HEAP8, ptr, len, offset);
                if (curr < 0) return -1;
                ret += curr;
                if (curr < len) break
              }
              return ret
            },
            doWritev: function(stream, iov, iovcnt, offset) {
              var ret = 0;
              for (var i = 0; i < iovcnt; i++) {
                var ptr = HEAP32[iov + i * 8 >> 2];
                var len = HEAP32[iov + (i * 8 + 4) >> 2];
                var curr = FS.write(stream, HEAP8, ptr, len, offset);
                if (curr < 0) return -1;
                ret += curr
              }
              return ret
            },
            varargs: 0,
            get: function(varargs) {
              SYSCALLS.varargs += 4;
              var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
              return ret
            },
            getStr: function() {
              var ret = UTF8ToString(SYSCALLS.get());
              return ret
            },
            getStreamFromFD: function() {
              var stream = FS.getStream(SYSCALLS.get());
              if (!stream) throw new FS.ErrnoError(9);
              return stream
            },
            get64: function() {
              var low = SYSCALLS.get(),
                high = SYSCALLS.get();
              return low
            },
            getZero: function() {
              SYSCALLS.get()
            }
          };

          function ___syscall140(which, varargs) {
            SYSCALLS.varargs = varargs;
            try {
              var stream = SYSCALLS.getStreamFromFD(),
                offset_high = SYSCALLS.get(),
                offset_low = SYSCALLS.get(),
                result = SYSCALLS.get(),
                whence = SYSCALLS.get();
              var HIGH_OFFSET = 4294967296;
              var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
              var DOUBLE_LIMIT = 9007199254740992;
              if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
                return -75
              }
              FS.llseek(stream, offset, whence);
              tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[result >> 2] = tempI64[0], HEAP32[result + 4 >> 2] = tempI64[1];
              if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;
              return 0
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
              return -e.errno
            }
          }

          function ___syscall145(which, varargs) {
            SYSCALLS.varargs = varargs;
            try {
              var stream = SYSCALLS.getStreamFromFD(),
                iov = SYSCALLS.get(),
                iovcnt = SYSCALLS.get();
              return SYSCALLS.doReadv(stream, iov, iovcnt)
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
              return -e.errno
            }
          }

          function ___syscall146(which, varargs) {
            SYSCALLS.varargs = varargs;
            try {
              var stream = SYSCALLS.getStreamFromFD(),
                iov = SYSCALLS.get(),
                iovcnt = SYSCALLS.get();
              return SYSCALLS.doWritev(stream, iov, iovcnt)
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
              return -e.errno
            }
          }

          function ___syscall221(which, varargs) {
            SYSCALLS.varargs = varargs;
            try {
              var stream = SYSCALLS.getStreamFromFD(),
                cmd = SYSCALLS.get();
              switch (cmd) {
                case 0: {
                  var arg = SYSCALLS.get();
                  if (arg < 0) {
                    return -22
                  }
                  var newStream;
                  newStream = FS.open(stream.path, stream.flags, 0, arg);
                  return newStream.fd
                }
                case 1:
                case 2:
                  return 0;
                case 3:
                  return stream.flags;
                case 4: {
                  var arg = SYSCALLS.get();
                  stream.flags |= arg;
                  return 0
                }
                case 12: {
                  var arg = SYSCALLS.get();
                  var offset = 0;
                  HEAP16[arg + offset >> 1] = 2;
                  return 0
                }
                case 13:
                case 14:
                  return 0;
                case 16:
                case 8:
                  return -22;
                case 9:
                  ___setErrNo(22);
                  return -1;
                default: {
                  return -22
                }
              }
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
              return -e.errno
            }
          }

          function ___syscall3(which, varargs) {
            SYSCALLS.varargs = varargs;
            try {
              var stream = SYSCALLS.getStreamFromFD(),
                buf = SYSCALLS.get(),
                count = SYSCALLS.get();
              return FS.read(stream, HEAP8, buf, count)
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
              return -e.errno
            }
          }

          function ___syscall5(which, varargs) {
            SYSCALLS.varargs = varargs;
            try {
              var pathname = SYSCALLS.getStr(),
                flags = SYSCALLS.get(),
                mode = SYSCALLS.get();
              var stream = FS.open(pathname, flags, mode);
              return stream.fd
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
              return -e.errno
            }
          }

          function ___syscall54(which, varargs) {
            SYSCALLS.varargs = varargs;
            try {
              var stream = SYSCALLS.getStreamFromFD(),
                op = SYSCALLS.get();
              switch (op) {
                case 21509:
                case 21505: {
                  if (!stream.tty) return -25;
                  return 0
                }
                case 21510:
                case 21511:
                case 21512:
                case 21506:
                case 21507:
                case 21508: {
                  if (!stream.tty) return -25;
                  return 0
                }
                case 21519: {
                  if (!stream.tty) return -25;
                  var argp = SYSCALLS.get();
                  HEAP32[argp >> 2] = 0;
                  return 0
                }
                case 21520: {
                  if (!stream.tty) return -25;
                  return -22
                }
                case 21531: {
                  var argp = SYSCALLS.get();
                  return FS.ioctl(stream, op, argp)
                }
                case 21523: {
                  if (!stream.tty) return -25;
                  return 0
                }
                case 21524: {
                  if (!stream.tty) return -25;
                  return 0
                }
                default:
                  abort("bad ioctl syscall " + op)
              }
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
              return -e.errno
            }
          }

          function ___syscall6(which, varargs) {
            SYSCALLS.varargs = varargs;
            try {
              var stream = SYSCALLS.getStreamFromFD();
              FS.close(stream);
              return 0
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
              return -e.errno
            }
          }

          function ___unlock() {}

          function ___wait() {}

          function getShiftFromSize(size) {
            switch (size) {
              case 1:
                return 0;
              case 2:
                return 1;
              case 4:
                return 2;
              case 8:
                return 3;
              default:
                throw new TypeError("Unknown type size: " + size)
            }
          }

          function embind_init_charCodes() {
            var codes = new Array(256);
            for (var i = 0; i < 256; ++i) {
              codes[i] = String.fromCharCode(i)
            }
            embind_charCodes = codes
          }
          var embind_charCodes = undefined;

          function readLatin1String(ptr) {
            var ret = "";
            var c = ptr;
            while (HEAPU8[c]) {
              ret += embind_charCodes[HEAPU8[c++]]
            }
            return ret
          }
          var awaitingDependencies = {};
          var registeredTypes = {};
          var typeDependencies = {};
          var char_0 = 48;
          var char_9 = 57;

          function makeLegalFunctionName(name) {
            if (undefined === name) {
              return "_unknown"
            }
            name = name.replace(/[^a-zA-Z0-9_]/g, "$");
            var f = name.charCodeAt(0);
            if (f >= char_0 && f <= char_9) {
              return "_" + name
            } else {
              return name
            }
          }

          function createNamedFunction(name, body) {
            name = makeLegalFunctionName(name);
            return new Function("body", "return function " + name + "() {\n" + '    "use strict";' + "    return body.apply(this, arguments);\n" + "};\n")(body)
          }

          function extendError(baseErrorType, errorName) {
            var errorClass = createNamedFunction(errorName, function(message) {
              this.name = errorName;
              this.message = message;
              var stack = new Error(message).stack;
              if (stack !== undefined) {
                this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "")
              }
            });
            errorClass.prototype = Object.create(baseErrorType.prototype);
            errorClass.prototype.constructor = errorClass;
            errorClass.prototype.toString = function() {
              if (this.message === undefined) {
                return this.name
              } else {
                return this.name + ": " + this.message
              }
            };
            return errorClass
          }
          var BindingError = undefined;

          function throwBindingError(message) {
            throw new BindingError(message)
          }
          var InternalError = undefined;

          function registerType(rawType, registeredInstance, options) {
            options = options || {};
            if (!("argPackAdvance" in registeredInstance)) {
              throw new TypeError("registerType registeredInstance requires argPackAdvance")
            }
            var name = registeredInstance.name;
            if (!rawType) {
              throwBindingError('type "' + name + '" must have a positive integer typeid pointer')
            }
            if (registeredTypes.hasOwnProperty(rawType)) {
              if (options.ignoreDuplicateRegistrations) {
                return
              } else {
                throwBindingError("Cannot register type '" + name + "' twice")
              }
            }
            registeredTypes[rawType] = registeredInstance;
            delete typeDependencies[rawType];
            if (awaitingDependencies.hasOwnProperty(rawType)) {
              var callbacks = awaitingDependencies[rawType];
              delete awaitingDependencies[rawType];
              callbacks.forEach(function(cb) {
                cb()
              })
            }
          }

          function __embind_register_bool(rawType, name, size, trueValue, falseValue) {
            var shift = getShiftFromSize(size);
            name = readLatin1String(name);
            registerType(rawType, {
              name: name,
              "fromWireType": function(wt) {
                return !!wt
              },
              "toWireType": function(destructors, o) {
                return o ? trueValue : falseValue
              },
              "argPackAdvance": 8,
              "readValueFromPointer": function(pointer) {
                var heap;
                if (size === 1) {
                  heap = HEAP8
                } else if (size === 2) {
                  heap = HEAP16
                } else if (size === 4) {
                  heap = HEAP32
                } else {
                  throw new TypeError("Unknown boolean type size: " + name)
                }
                return this["fromWireType"](heap[pointer >> shift])
              },
              destructorFunction: null
            })
          }
          var emval_free_list = [];
          var emval_handle_array = [{}, {
            value: undefined
          }, {
            value: null
          }, {
            value: true
          }, {
            value: false
          }];

          function __emval_decref(handle) {
            if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {
              emval_handle_array[handle] = undefined;
              emval_free_list.push(handle)
            }
          }

          function count_emval_handles() {
            var count = 0;
            for (var i = 5; i < emval_handle_array.length; ++i) {
              if (emval_handle_array[i] !== undefined) {
                ++count
              }
            }
            return count
          }

          function get_first_emval() {
            for (var i = 5; i < emval_handle_array.length; ++i) {
              if (emval_handle_array[i] !== undefined) {
                return emval_handle_array[i]
              }
            }
            return null
          }

          function init_emval() {
            Module["count_emval_handles"] = count_emval_handles;
            Module["get_first_emval"] = get_first_emval
          }

          function __emval_register(value) {
            switch (value) {
              case undefined: {
                return 1
              }
              case null: {
                return 2
              }
              case true: {
                return 3
              }
              case false: {
                return 4
              }
              default: {
                var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;
                emval_handle_array[handle] = {
                  refcount: 1,
                  value: value
                };
                return handle
              }
            }
          }

          function simpleReadValueFromPointer(pointer) {
            return this["fromWireType"](HEAPU32[pointer >> 2])
          }

          function __embind_register_emval(rawType, name) {
            name = readLatin1String(name);
            registerType(rawType, {
              name: name,
              "fromWireType": function(handle) {
                var rv = emval_handle_array[handle].value;
                __emval_decref(handle);
                return rv
              },
              "toWireType": function(destructors, value) {
                return __emval_register(value)
              },
              "argPackAdvance": 8,
              "readValueFromPointer": simpleReadValueFromPointer,
              destructorFunction: null
            })
          }

          function _embind_repr(v) {
            if (v === null) {
              return "null"
            }
            var t = typeof v;
            if (t === "object" || t === "array" || t === "function") {
              return v.toString()
            } else {
              return "" + v
            }
          }

          function floatReadValueFromPointer(name, shift) {
            switch (shift) {
              case 2:
                return function(pointer) {
                  return this["fromWireType"](HEAPF32[pointer >> 2])
                };
              case 3:
                return function(pointer) {
                  return this["fromWireType"](HEAPF64[pointer >> 3])
                };
              default:
                throw new TypeError("Unknown float type: " + name)
            }
          }

          function __embind_register_float(rawType, name, size) {
            var shift = getShiftFromSize(size);
            name = readLatin1String(name);
            registerType(rawType, {
              name: name,
              "fromWireType": function(value) {
                return value
              },
              "toWireType": function(destructors, value) {
                if (typeof value !== "number" && typeof value !== "boolean") {
                  throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name)
                }
                return value
              },
              "argPackAdvance": 8,
              "readValueFromPointer": floatReadValueFromPointer(name, shift),
              destructorFunction: null
            })
          }

          function integerReadValueFromPointer(name, shift, signed) {
            switch (shift) {
              case 0:
                return signed ? function readS8FromPointer(pointer) {
                  return HEAP8[pointer]
                } : function readU8FromPointer(pointer) {
                  return HEAPU8[pointer]
                };
              case 1:
                return signed ? function readS16FromPointer(pointer) {
                  return HEAP16[pointer >> 1]
                } : function readU16FromPointer(pointer) {
                  return HEAPU16[pointer >> 1]
                };
              case 2:
                return signed ? function readS32FromPointer(pointer) {
                  return HEAP32[pointer >> 2]
                } : function readU32FromPointer(pointer) {
                  return HEAPU32[pointer >> 2]
                };
              default:
                throw new TypeError("Unknown integer type: " + name)
            }
          }

          function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {
            name = readLatin1String(name);
            if (maxRange === -1) {
              maxRange = 4294967295
            }
            var shift = getShiftFromSize(size);
            var fromWireType = function(value) {
              return value
            };
            if (minRange === 0) {
              var bitshift = 32 - 8 * size;
              fromWireType = function(value) {
                return value << bitshift >>> bitshift
              }
            }
            var isUnsignedType = name.indexOf("unsigned") != -1;
            registerType(primitiveType, {
              name: name,
              "fromWireType": fromWireType,
              "toWireType": function(destructors, value) {
                if (typeof value !== "number" && typeof value !== "boolean") {
                  throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name)
                }
                if (value < minRange || value > maxRange) {
                  throw new TypeError('Passing a number "' + _embind_repr(value) + '" from JS side to C/C++ side to an argument of type "' + name + '", which is outside the valid range [' + minRange + ", " + maxRange + "]!")
                }
                return isUnsignedType ? value >>> 0 : value | 0
              },
              "argPackAdvance": 8,
              "readValueFromPointer": integerReadValueFromPointer(name, shift, minRange !== 0),
              destructorFunction: null
            })
          }

          function __embind_register_memory_view(rawType, dataTypeIndex, name) {
            var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
            var TA = typeMapping[dataTypeIndex];

            function decodeMemoryView(handle) {
              handle = handle >> 2;
              var heap = HEAPU32;
              var size = heap[handle];
              var data = heap[handle + 1];
              return new TA(heap["buffer"], data, size)
            }
            name = readLatin1String(name);
            registerType(rawType, {
              name: name,
              "fromWireType": decodeMemoryView,
              "argPackAdvance": 8,
              "readValueFromPointer": decodeMemoryView
            }, {
              ignoreDuplicateRegistrations: true
            })
          }

          function __embind_register_std_string(rawType, name) {
            name = readLatin1String(name);
            var stdStringIsUTF8 = name === "std::string";
            registerType(rawType, {
              name: name,
              "fromWireType": function(value) {
                var length = HEAPU32[value >> 2];
                var str;
                if (stdStringIsUTF8) {
                  var endChar = HEAPU8[value + 4 + length];
                  var endCharSwap = 0;
                  if (endChar != 0) {
                    endCharSwap = endChar;
                    HEAPU8[value + 4 + length] = 0
                  }
                  var decodeStartPtr = value + 4;
                  for (var i = 0; i <= length; ++i) {
                    var currentBytePtr = value + 4 + i;
                    if (HEAPU8[currentBytePtr] == 0) {
                      var stringSegment = UTF8ToString(decodeStartPtr);
                      if (str === undefined) str = stringSegment;
                      else {
                        str += String.fromCharCode(0);
                        str += stringSegment
                      }
                      decodeStartPtr = currentBytePtr + 1
                    }
                  }
                  if (endCharSwap != 0) HEAPU8[value + 4 + length] = endCharSwap
                } else {
                  var a = new Array(length);
                  for (var i = 0; i < length; ++i) {
                    a[i] = String.fromCharCode(HEAPU8[value + 4 + i])
                  }
                  str = a.join("")
                }
                _free(value);
                return str
              },
              "toWireType": function(destructors, value) {
                if (value instanceof ArrayBuffer) {
                  value = new Uint8Array(value)
                }
                var getLength;
                var valueIsOfTypeString = typeof value === "string";
                if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
                  throwBindingError("Cannot pass non-string to std::string")
                }
                if (stdStringIsUTF8 && valueIsOfTypeString) {
                  getLength = function() {
                    return lengthBytesUTF8(value)
                  }
                } else {
                  getLength = function() {
                    return value.length
                  }
                }
                var length = getLength();
                var ptr = _malloc(4 + length + 1);
                HEAPU32[ptr >> 2] = length;
                if (stdStringIsUTF8 && valueIsOfTypeString) {
                  stringToUTF8(value, ptr + 4, length + 1)
                } else {
                  if (valueIsOfTypeString) {
                    for (var i = 0; i < length; ++i) {
                      var charCode = value.charCodeAt(i);
                      if (charCode > 255) {
                        _free(ptr);
                        throwBindingError("String has UTF-16 code units that do not fit in 8 bits")
                      }
                      HEAPU8[ptr + 4 + i] = charCode
                    }
                  } else {
                    for (var i = 0; i < length; ++i) {
                      HEAPU8[ptr + 4 + i] = value[i]
                    }
                  }
                }
                if (destructors !== null) {
                  destructors.push(_free, ptr)
                }
                return ptr
              },
              "argPackAdvance": 8,
              "readValueFromPointer": simpleReadValueFromPointer,
              destructorFunction: function(ptr) {
                _free(ptr)
              }
            })
          }

          function __embind_register_std_wstring(rawType, charSize, name) {
            name = readLatin1String(name);
            var getHeap, shift;
            if (charSize === 2) {
              getHeap = function() {
                return HEAPU16
              };
              shift = 1
            } else if (charSize === 4) {
              getHeap = function() {
                return HEAPU32
              };
              shift = 2
            }
            registerType(rawType, {
              name: name,
              "fromWireType": function(value) {
                var HEAP = getHeap();
                var length = HEAPU32[value >> 2];
                var a = new Array(length);
                var start = value + 4 >> shift;
                for (var i = 0; i < length; ++i) {
                  a[i] = String.fromCharCode(HEAP[start + i])
                }
                _free(value);
                return a.join("")
              },
              "toWireType": function(destructors, value) {
                var HEAP = getHeap();
                var length = value.length;
                var ptr = _malloc(4 + length * charSize);
                HEAPU32[ptr >> 2] = length;
                var start = ptr + 4 >> shift;
                for (var i = 0; i < length; ++i) {
                  HEAP[start + i] = value.charCodeAt(i)
                }
                if (destructors !== null) {
                  destructors.push(_free, ptr)
                }
                return ptr
              },
              "argPackAdvance": 8,
              "readValueFromPointer": simpleReadValueFromPointer,
              destructorFunction: function(ptr) {
                _free(ptr)
              }
            })
          }

          function __embind_register_void(rawType, name) {
            name = readLatin1String(name);
            registerType(rawType, {
              isVoid: true,
              name: name,
              "argPackAdvance": 0,
              "fromWireType": function() {
                return undefined
              },
              "toWireType": function(destructors, o) {
                return undefined
              }
            })
          }

          function _emscripten_get_heap_size() {
            return HEAP8.length
          }

          function _exit(status) {
            exit(status)
          }

          function _emscripten_memcpy_big(dest, src, num) {
            HEAPU8.set(HEAPU8.subarray(src, src + num), dest)
          }

          function abortOnCannotGrowMemory(requestedSize) {
            abort("OOM")
          }

          function emscripten_realloc_buffer(size) {
            try {
              wasmMemory.grow(size - buffer.byteLength + 65535 >> 16);
              updateGlobalBufferAndViews(wasmMemory.buffer);
              return 1
            } catch (e) {}
          }

          function _emscripten_resize_heap(requestedSize) {
            var oldSize = _emscripten_get_heap_size();
            var PAGE_MULTIPLE = 65536;
            var LIMIT = 2147483648 - PAGE_MULTIPLE;
            if (requestedSize > LIMIT) {
              return false
            }
            var MIN_TOTAL_MEMORY = 16777216;
            var newSize = Math.max(oldSize, MIN_TOTAL_MEMORY);
            while (newSize < requestedSize) {
              if (newSize <= 536870912) {
                newSize = alignUp(2 * newSize, PAGE_MULTIPLE)
              } else {
                newSize = Math.min(alignUp((3 * newSize + 2147483648) / 4, PAGE_MULTIPLE), LIMIT)
              }
            }
            var replacement = emscripten_realloc_buffer(newSize);
            if (!replacement) {
              return false
            }
            return true
          }
          FS.staticInit();
          embind_init_charCodes();
          BindingError = Module["BindingError"] = extendError(Error, "BindingError");
          InternalError = Module["InternalError"] = extendError(Error, "InternalError");
          init_emval();

          function intArrayFromString(stringy, dontAddNull, length) {
            var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
            var u8array = new Array(len);
            var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
            if (dontAddNull) u8array.length = numBytesWritten;
            return u8array
          }
          var asmGlobalArg = {};
          var asmLibraryArg = {
            "e": abort,
            "A": ___lock,
            "k": ___setErrNo,
            "q": ___syscall140,
            "p": ___syscall145,
            "j": ___syscall146,
            "f": ___syscall221,
            "o": ___syscall3,
            "i": ___syscall5,
            "g": ___syscall54,
            "n": ___syscall6,
            "h": ___unlock,
            "z": ___wait,
            "y": __embind_register_bool,
            "x": __embind_register_emval,
            "m": __embind_register_float,
            "d": __embind_register_integer,
            "c": __embind_register_memory_view,
            "l": __embind_register_std_string,
            "w": __embind_register_std_wstring,
            "v": __embind_register_void,
            "u": _emscripten_get_heap_size,
            "t": _emscripten_memcpy_big,
            "s": _emscripten_resize_heap,
            "b": _exit,
            "r": abortOnCannotGrowMemory,
            "a": DYNAMICTOP_PTR
          };
          var asm = Module["asm"](asmGlobalArg, asmLibraryArg, buffer);
          Module["asm"] = asm;
          var __GLOBAL__sub_I_bind_cpp = Module["__GLOBAL__sub_I_bind_cpp"] = function() {
            return Module["asm"]["B"].apply(null, arguments)
          };
          var ___embind_register_native_and_builtin_types = Module["___embind_register_native_and_builtin_types"] = function() {
            return Module["asm"]["C"].apply(null, arguments)
          };
          var ___errno_location = Module["___errno_location"] = function() {
            return Module["asm"]["D"].apply(null, arguments)
          };
          var ___getTypeName = Module["___getTypeName"] = function() {
            return Module["asm"]["E"].apply(null, arguments)
          };
          var _fflush = Module["_fflush"] = function() {
            return Module["asm"]["F"].apply(null, arguments)
          };
          var _free = Module["_free"] = function() {
            return Module["asm"]["G"].apply(null, arguments)
          };
          var _main = Module["_main"] = function() {
            return Module["asm"]["H"].apply(null, arguments)
          };
          var _malloc = Module["_malloc"] = function() {
            return Module["asm"]["I"].apply(null, arguments)
          };
          var stackAlloc = Module["stackAlloc"] = function() {
            return Module["asm"]["K"].apply(null, arguments)
          };
          var dynCall_vi = Module["dynCall_vi"] = function() {
            return Module["asm"]["J"].apply(null, arguments)
          };
          Module["asm"] = asm;
          var calledRun;
          Module["then"] = function(func) {
            if (calledRun) {
              func(Module)
            } else {
              var old = Module["onRuntimeInitialized"];
              Module["onRuntimeInitialized"] = function() {
                if (old) old();
                func(Module)
              }
            }
            return Module
          };

          function ExitStatus(status) {
            this.name = "ExitStatus";
            this.message = "Program terminated with exit(" + status + ")";
            this.status = status
          }
          var calledMain = false;
          dependenciesFulfilled = function runCaller() {
            if (!calledRun) run();
            if (!calledRun) dependenciesFulfilled = runCaller
          };

          function callMain(args) {
            args = args || [];
            var argc = args.length + 1;
            var argv = stackAlloc((argc + 1) * 4);
            HEAP32[argv >> 2] = allocateUTF8OnStack(thisProgram);
            for (var i = 1; i < argc; i++) {
              HEAP32[(argv >> 2) + i] = allocateUTF8OnStack(args[i - 1])
            }
            HEAP32[(argv >> 2) + argc] = 0;
            try {
              var ret = Module["_main"](argc, argv);
              exit(ret, true)
            } catch (e) {
              if (e instanceof ExitStatus) {
                return
              } else if (e == "SimulateInfiniteLoop") {
                noExitRuntime = true;
                return
              } else {
                var toLog = e;
                if (e && typeof e === "object" && e.stack) {
                  toLog = [e, e.stack]
                }
                err("exception thrown: " + toLog);
                quit_(1, e)
              }
            } finally {
              calledMain = true
            }
          }

          function run(args) {
            args = args || arguments_;
            if (runDependencies > 0) {
              return
            }
            preRun();
            if (runDependencies > 0) return;

            function doRun() {
              if (calledRun) return;
              calledRun = true;
              if (ABORT) return;
              initRuntime();
              preMain();
              if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();
              if (shouldRunNow) callMain(args);
              postRun()
            }
            if (Module["setStatus"]) {
              Module["setStatus"]("Running...");
              setTimeout(function() {
                setTimeout(function() {
                  Module["setStatus"]("")
                }, 1);
                doRun()
              }, 1)
            } else {
              doRun()
            }
          }
          Module["run"] = run;

          function exit(status, implicit) {
            if (implicit && noExitRuntime && status === 0) {
              return
            }
            if (noExitRuntime) {} else {
              ABORT = true;
              EXITSTATUS = status;
              exitRuntime();
              if (Module["onExit"]) Module["onExit"](status)
            }
            quit_(status, new ExitStatus(status))
          }

          function abort(what) {
            if (Module["onAbort"]) {
              Module["onAbort"](what)
            }
            what += "";
            out(what);
            err(what);
            ABORT = true;
            EXITSTATUS = 1;
            throw "abort(" + what + "). Build with -s ASSERTIONS=1 for more info."
          }
          Module["abort"] = abort;
          if (Module["preInit"]) {
            if (typeof Module["preInit"] == "function") Module["preInit"] = [Module["preInit"]];
            while (Module["preInit"].length > 0) {
              Module["preInit"].pop()()
            }
          }
          var shouldRunNow = true;
          if (Module["noInitialRun"]) shouldRunNow = false;
          run();


          return pwgen
        }
      );
    })();
    export default pwgen;

    // -- x-pwgen
    export class Xpwgen extends HTMLElement {
      constructor() {
        super()

        this.wasmModule = undefined
        this.hasRendered = false

        const container = document.createElement('div')
        container.id = 'container'
        container.innerHTML = `
          <style>
            :host {
              display: var(--x-pwgen-display, initial);
              font-size: var(--x-pwgen-font-size, initial);
              font-family: var(--x-pwgen-font-family, monospace);
            }

            ul {
              list-style: var(--x-pwgen-ul-list-style, none);
              margin: var(--x-pwgen-ul-margin, 0);
              padding: var(--x-pwgen-ul-padding, 0);
            }

            li {
              display: var(--x-pwgen-li-display, block);
              margin: var(--x-pwgen-li-margin, 0);
              padding: var(--x-pwgen-li-padding, 0);
            }
          </style>
          <ul></ul>
        `

        this.attachShadow({ mode: 'open' }).appendChild(container)
      }

      static get observedAttributes() {
        return ['composed', 'flags', 'length', 'number']
      }

      get composed() {
        return this.getAttribute('composed')
      }

      set composed(composed) {
        this.setAttribute('composed', composed)
      }

      get flags() {
        return this.getAttribute('flags')
      }

      set flags(flags) {
        this.setAttribute('flags', flags)
      }

      get length() {
        return this.getAttribute('length')
      }

      set length(length) {
        this.setAttribute('length', length)
      }

      get number() {
        return this.getAttribute('number')
      }

      set number(number) {
        this.setAttribute('number', number)
      }

      connectedCallback() {
        this.constructor.observedAttributes.forEach(attribute => {
          this._upgradeProperty(attribute)
        })

        if (!this.flags) { this.flags = '-sy' }
        if (!this.length) { this.length = '20' }
        if (!this.number) { this.number = '1' }

        // import('../pwgen.js').then(mod => {
          this.wasmModule = pwgen
        // }).then(() => {
          this.generate()

          this.hasRendered = true
        // })
      }

      attributeChangedCallback(name, oldValue, newValue) {
        if (newValue === null || oldValue === newValue) {
          return
        }

        if (name !== 'flags' && !newValue) {
          return
        }

        if (this.hasRendered && this.length && this.number) {
          this.generate()
        }
      }

      generate() {
        this.wasmModule({
          arguments: this.flags
            ? [
              this.flags,
              this.length,
              this.number
            ]
            : [
              this.length,
              this.number
            ],
          print: this._handlePassword()
        })
      }

      _handlePassword() {
        const ul = document.createElement('ul')

        return msg => {
          this.shadowRoot.dispatchEvent(new CustomEvent('x-pwgen-handle-password', {
            bubbles: true,
            composed: this.composed !== null,
            detail: {
              msg
            }
          }))

          msg.split(' ').forEach(password => {
            const li = document.createElement('li')
            li.innerText = password

            ul.appendChild(li)
          })

          this.shadowRoot.getElementById('container').replaceChild(
            ul,
            this.shadowRoot.querySelector('ul')
          )
        }
      }

      _upgradeProperty(prop) {
        if (this.hasOwnProperty(prop)) {
          let value = this[prop]
          delete this[prop]
          this[prop] = value
        }
      }
    }

    if (!customElements.get('x-pwgen')) {
      customElements.define('x-pwgen', Xpwgen)
    }

    // import 'https://kherrick.github.io/x-pwgen-components/dist/esm/mwc-button.js'
    // import 'https://kherrick.github.io/x-pwgen-components/dist/esm/mwc-slider.js'
    // import 'https://kherrick.github.io/x-pwgen-components/dist/esm/mwc-formfield.js'

    // -- umd components
    import 'data:text/javascript;base64,IWZ1bmN0aW9uKHQsZSl7Im9iamVjdCI9PXR5cGVvZiBleHBvcnRzJiYidW5kZWZpbmVkIiE9dHlwZW9mIG1vZHVsZT9lKGV4cG9ydHMpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiZXhwb3J0cyJdLGUpOmUoKHQ9dHx8c2VsZilbIngtcHdnZW4tY29tcG9uZW50cyJdPXt9KX0odGhpcywoZnVuY3Rpb24odCl7InVzZSBzdHJpY3QiOwovKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioKICAgIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogICAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICJMaWNlbnNlIik7IHlvdSBtYXkgbm90IHVzZQogICAgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUKICAgIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wCgogICAgVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWQogICAgS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRAogICAgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSwKICAgIE1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuCgogICAgU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zCiAgICBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuCiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL3ZhciBlPWZ1bmN0aW9uKHQsaSl7cmV0dXJuKGU9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKHQsZSl7dC5fX3Byb3RvX189ZX18fGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBpIGluIGUpZS5oYXNPd25Qcm9wZXJ0eShpKSYmKHRbaV09ZVtpXSl9KSh0LGkpfTtmdW5jdGlvbiBpKHQsaSl7ZnVuY3Rpb24gbigpe3RoaXMuY29uc3RydWN0b3I9dH1lKHQsaSksdC5wcm90b3R5cGU9bnVsbD09PWk/T2JqZWN0LmNyZWF0ZShpKToobi5wcm90b3R5cGU9aS5wcm90b3R5cGUsbmV3IG4pfXZhciBuPWZ1bmN0aW9uKCl7cmV0dXJuKG49T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24odCl7Zm9yKHZhciBlLGk9MSxuPWFyZ3VtZW50cy5sZW5ndGg7aTxuO2krKylmb3IodmFyIHIgaW4gZT1hcmd1bWVudHNbaV0pT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiB0fSkuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtmdW5jdGlvbiByKHQsZSxpLG4pe3ZhciByLG89YXJndW1lbnRzLmxlbmd0aCxhPW88Mz9lOm51bGw9PT1uP249T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLGkpOm47aWYoIm9iamVjdCI9PXR5cGVvZiBSZWZsZWN0JiYiZnVuY3Rpb24iPT10eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSlhPVJlZmxlY3QuZGVjb3JhdGUodCxlLGksbik7ZWxzZSBmb3IodmFyIHM9dC5sZW5ndGgtMTtzPj0wO3MtLSkocj10W3NdKSYmKGE9KG88Mz9yKGEpOm8+Mz9yKGUsaSxhKTpyKGUsaSkpfHxhKTtyZXR1cm4gbz4zJiZhJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxpLGEpLGEKLyoqCiAgICAgKiBAbGljZW5zZQogICAgICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KICAgICAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdAogICAgICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0CiAgICAgKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0CiAgICAgKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHQKICAgICAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdAogICAgICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHQKICAgICAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvCiAgICAgKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0CiAgICAgKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHQKICAgICAqL31jb25zdCBvPW5ldyBXZWFrTWFwLGE9dD0+KC4uLmUpPT57Y29uc3QgaT10KC4uLmUpO3JldHVybiBvLnNldChpLCEwKSxpfSxzPXQ9PiJmdW5jdGlvbiI9PXR5cGVvZiB0JiZvLmhhcyh0KSxkPXZvaWQgMCE9PXdpbmRvdy5jdXN0b21FbGVtZW50cyYmdm9pZCAwIT09d2luZG93LmN1c3RvbUVsZW1lbnRzLnBvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2ssYz0odCxlLGk9bnVsbCk9Pntmb3IoO2UhPT1pOyl7Y29uc3QgaT1lLm5leHRTaWJsaW5nO3QucmVtb3ZlQ2hpbGQoZSksZT1pfX0sbD17fSx1PXt9LHA9YHt7bGl0LSR7U3RyaW5nKE1hdGgucmFuZG9tKCkpLnNsaWNlKDIpfX19YCxtPWBceDNjIS0tJHtwfS0tXHgzZWAsaD1uZXcgUmVnRXhwKGAke3B9fCR7bX1gKTtjbGFzcyBme2NvbnN0cnVjdG9yKHQsZSl7dGhpcy5wYXJ0cz1bXSx0aGlzLmVsZW1lbnQ9ZTtjb25zdCBpPVtdLG49W10scj1kb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGUuY29udGVudCwxMzMsbnVsbCwhMSk7bGV0IG89MCxhPS0xLHM9MDtjb25zdHtzdHJpbmdzOmQsdmFsdWVzOntsZW5ndGg6Y319PXQ7Zm9yKDtzPGM7KXtjb25zdCB0PXIubmV4dE5vZGUoKTtpZihudWxsIT09dCl7aWYoYSsrLDE9PT10Lm5vZGVUeXBlKXtpZih0Lmhhc0F0dHJpYnV0ZXMoKSl7Y29uc3QgZT10LmF0dHJpYnV0ZXMse2xlbmd0aDppfT1lO2xldCBuPTA7Zm9yKGxldCB0PTA7dDxpO3QrKylfKGVbdF0ubmFtZSwiJGxpdCQiKSYmbisrO2Zvcig7bi0tID4wOyl7Y29uc3QgZT1kW3NdLGk9di5leGVjKGUpWzJdLG49aS50b0xvd2VyQ2FzZSgpKyIkbGl0JCIscj10LmdldEF0dHJpYnV0ZShuKTt0LnJlbW92ZUF0dHJpYnV0ZShuKTtjb25zdCBvPXIuc3BsaXQoaCk7dGhpcy5wYXJ0cy5wdXNoKHt0eXBlOiJhdHRyaWJ1dGUiLGluZGV4OmEsbmFtZTppLHN0cmluZ3M6b30pLHMrPW8ubGVuZ3RoLTF9fSJURU1QTEFURSI9PT10LnRhZ05hbWUmJihuLnB1c2godCksci5jdXJyZW50Tm9kZT10LmNvbnRlbnQpfWVsc2UgaWYoMz09PXQubm9kZVR5cGUpe2NvbnN0IGU9dC5kYXRhO2lmKGUuaW5kZXhPZihwKT49MCl7Y29uc3Qgbj10LnBhcmVudE5vZGUscj1lLnNwbGl0KGgpLG89ci5sZW5ndGgtMTtmb3IobGV0IGU9MDtlPG87ZSsrKXtsZXQgaSxvPXJbZV07aWYoIiI9PT1vKWk9ZygpO2Vsc2V7Y29uc3QgdD12LmV4ZWMobyk7bnVsbCE9PXQmJl8odFsyXSwiJGxpdCQiKSYmKG89by5zbGljZSgwLHQuaW5kZXgpK3RbMV0rdFsyXS5zbGljZSgwLC0iJGxpdCQiLmxlbmd0aCkrdFszXSksaT1kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShvKX1uLmluc2VydEJlZm9yZShpLHQpLHRoaXMucGFydHMucHVzaCh7dHlwZToibm9kZSIsaW5kZXg6KythfSl9IiI9PT1yW29dPyhuLmluc2VydEJlZm9yZShnKCksdCksaS5wdXNoKHQpKTp0LmRhdGE9cltvXSxzKz1vfX1lbHNlIGlmKDg9PT10Lm5vZGVUeXBlKWlmKHQuZGF0YT09PXApe2NvbnN0IGU9dC5wYXJlbnROb2RlO251bGwhPT10LnByZXZpb3VzU2libGluZyYmYSE9PW98fChhKyssZS5pbnNlcnRCZWZvcmUoZygpLHQpKSxvPWEsdGhpcy5wYXJ0cy5wdXNoKHt0eXBlOiJub2RlIixpbmRleDphfSksbnVsbD09PXQubmV4dFNpYmxpbmc/dC5kYXRhPSIiOihpLnB1c2godCksYS0tKSxzKyt9ZWxzZXtsZXQgZT0tMTtmb3IoOy0xIT09KGU9dC5kYXRhLmluZGV4T2YocCxlKzEpKTspdGhpcy5wYXJ0cy5wdXNoKHt0eXBlOiJub2RlIixpbmRleDotMX0pLHMrK319ZWxzZSByLmN1cnJlbnROb2RlPW4ucG9wKCl9Zm9yKGNvbnN0IHQgb2YgaSl0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodCl9fWNvbnN0IF89KHQsZSk9Pntjb25zdCBpPXQubGVuZ3RoLWUubGVuZ3RoO3JldHVybiBpPj0wJiZ0LnNsaWNlKGkpPT09ZX0sYj10PT4tMSE9PXQuaW5kZXgsZz0oKT0+ZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgiIiksdj0vKFsgXHgwOVx4MGFceDBjXHgwZF0pKFteXDAtXHgxRlx4N0YtXHg5RiAiJz49L10rKShbIFx4MDlceDBhXHgwY1x4MGRdKj1bIFx4MDlceDBhXHgwY1x4MGRdKig/OlteIFx4MDlceDBhXHgwY1x4MGQiJ2A8Pj1dKnwiW14iXSp8J1teJ10qKSkkLzsKLyoqCiAgICAgKiBAbGljZW5zZQogICAgICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KICAgICAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdAogICAgICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0CiAgICAgKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0CiAgICAgKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHQKICAgICAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdAogICAgICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHQKICAgICAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvCiAgICAgKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0CiAgICAgKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHQKICAgICAqLwpjbGFzcyB5e2NvbnN0cnVjdG9yKHQsZSxpKXt0aGlzLl9fcGFydHM9W10sdGhpcy50ZW1wbGF0ZT10LHRoaXMucHJvY2Vzc29yPWUsdGhpcy5vcHRpb25zPWl9dXBkYXRlKHQpe2xldCBlPTA7Zm9yKGNvbnN0IGkgb2YgdGhpcy5fX3BhcnRzKXZvaWQgMCE9PWkmJmkuc2V0VmFsdWUodFtlXSksZSsrO2Zvcihjb25zdCB0IG9mIHRoaXMuX19wYXJ0cyl2b2lkIDAhPT10JiZ0LmNvbW1pdCgpfV9jbG9uZSgpe2NvbnN0IHQ9ZD90aGlzLnRlbXBsYXRlLmVsZW1lbnQuY29udGVudC5jbG9uZU5vZGUoITApOmRvY3VtZW50LmltcG9ydE5vZGUodGhpcy50ZW1wbGF0ZS5lbGVtZW50LmNvbnRlbnQsITApLGU9W10saT10aGlzLnRlbXBsYXRlLnBhcnRzLG49ZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcih0LDEzMyxudWxsLCExKTtsZXQgcixvPTAsYT0wLHM9bi5uZXh0Tm9kZSgpO2Zvcig7bzxpLmxlbmd0aDspaWYocj1pW29dLGIocikpe2Zvcig7YTxyLmluZGV4OylhKyssIlRFTVBMQVRFIj09PXMubm9kZU5hbWUmJihlLnB1c2gocyksbi5jdXJyZW50Tm9kZT1zLmNvbnRlbnQpLG51bGw9PT0ocz1uLm5leHROb2RlKCkpJiYobi5jdXJyZW50Tm9kZT1lLnBvcCgpLHM9bi5uZXh0Tm9kZSgpKTtpZigibm9kZSI9PT1yLnR5cGUpe2NvbnN0IHQ9dGhpcy5wcm9jZXNzb3IuaGFuZGxlVGV4dEV4cHJlc3Npb24odGhpcy5vcHRpb25zKTt0Lmluc2VydEFmdGVyTm9kZShzLnByZXZpb3VzU2libGluZyksdGhpcy5fX3BhcnRzLnB1c2godCl9ZWxzZSB0aGlzLl9fcGFydHMucHVzaCguLi50aGlzLnByb2Nlc3Nvci5oYW5kbGVBdHRyaWJ1dGVFeHByZXNzaW9ucyhzLHIubmFtZSxyLnN0cmluZ3MsdGhpcy5vcHRpb25zKSk7bysrfWVsc2UgdGhpcy5fX3BhcnRzLnB1c2godm9pZCAwKSxvKys7cmV0dXJuIGQmJihkb2N1bWVudC5hZG9wdE5vZGUodCksY3VzdG9tRWxlbWVudHMudXBncmFkZSh0KSksdH19Ci8qKgogICAgICogQGxpY2Vuc2UKICAgICAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuCiAgICAgKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQKICAgICAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dAogICAgICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdAogICAgICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0CiAgICAgKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQKICAgICAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0CiAgICAgKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzbwogICAgICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdAogICAgICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0CiAgICAgKi9jb25zdCB4PWAgJHtwfSBgO2NsYXNzIHd7Y29uc3RydWN0b3IodCxlLGksbil7dGhpcy5zdHJpbmdzPXQsdGhpcy52YWx1ZXM9ZSx0aGlzLnR5cGU9aSx0aGlzLnByb2Nlc3Nvcj1ufWdldEhUTUwoKXtjb25zdCB0PXRoaXMuc3RyaW5ncy5sZW5ndGgtMTtsZXQgZT0iIixpPSExO2ZvcihsZXQgbj0wO248dDtuKyspe2NvbnN0IHQ9dGhpcy5zdHJpbmdzW25dLHI9dC5sYXN0SW5kZXhPZigiXHgzYyEtLSIpO2k9KHI+LTF8fGkpJiYtMT09PXQuaW5kZXhPZigiLS1ceDNlIixyKzEpO2NvbnN0IG89di5leGVjKHQpO2UrPW51bGw9PT1vP3QrKGk/eDptKTp0LnN1YnN0cigwLG8uaW5kZXgpK29bMV0rb1syXSsiJGxpdCQiK29bM10rcH1yZXR1cm4gZSs9dGhpcy5zdHJpbmdzW3RdLGV9Z2V0VGVtcGxhdGVFbGVtZW50KCl7Y29uc3QgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZW1wbGF0ZSIpO3JldHVybiB0LmlubmVySFRNTD10aGlzLmdldEhUTUwoKSx0fX0KLyoqCiAgICAgKiBAbGljZW5zZQogICAgICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KICAgICAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdAogICAgICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0CiAgICAgKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0CiAgICAgKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHQKICAgICAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdAogICAgICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHQKICAgICAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvCiAgICAgKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0CiAgICAgKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHQKICAgICAqL2NvbnN0IFM9dD0+bnVsbD09PXR8fCEoIm9iamVjdCI9PXR5cGVvZiB0fHwiZnVuY3Rpb24iPT10eXBlb2YgdCksQT10PT5BcnJheS5pc0FycmF5KHQpfHwhKCF0fHwhdFtTeW1ib2wuaXRlcmF0b3JdKTtjbGFzcyBDe2NvbnN0cnVjdG9yKHQsZSxpKXt0aGlzLmRpcnR5PSEwLHRoaXMuZWxlbWVudD10LHRoaXMubmFtZT1lLHRoaXMuc3RyaW5ncz1pLHRoaXMucGFydHM9W107Zm9yKGxldCB0PTA7dDxpLmxlbmd0aC0xO3QrKyl0aGlzLnBhcnRzW3RdPXRoaXMuX2NyZWF0ZVBhcnQoKX1fY3JlYXRlUGFydCgpe3JldHVybiBuZXcgayh0aGlzKX1fZ2V0VmFsdWUoKXtjb25zdCB0PXRoaXMuc3RyaW5ncyxlPXQubGVuZ3RoLTE7bGV0IGk9IiI7Zm9yKGxldCBuPTA7bjxlO24rKyl7aSs9dFtuXTtjb25zdCBlPXRoaXMucGFydHNbbl07aWYodm9pZCAwIT09ZSl7Y29uc3QgdD1lLnZhbHVlO2lmKFModCl8fCFBKHQpKWkrPSJzdHJpbmciPT10eXBlb2YgdD90OlN0cmluZyh0KTtlbHNlIGZvcihjb25zdCBlIG9mIHQpaSs9InN0cmluZyI9PXR5cGVvZiBlP2U6U3RyaW5nKGUpfX1yZXR1cm4gaSs9dFtlXSxpfWNvbW1pdCgpe3RoaXMuZGlydHkmJih0aGlzLmRpcnR5PSExLHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUodGhpcy5uYW1lLHRoaXMuX2dldFZhbHVlKCkpKX19Y2xhc3Mga3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnZhbHVlPXZvaWQgMCx0aGlzLmNvbW1pdHRlcj10fXNldFZhbHVlKHQpe3Q9PT1sfHxTKHQpJiZ0PT09dGhpcy52YWx1ZXx8KHRoaXMudmFsdWU9dCxzKHQpfHwodGhpcy5jb21taXR0ZXIuZGlydHk9ITApKX1jb21taXQoKXtmb3IoO3ModGhpcy52YWx1ZSk7KXtjb25zdCB0PXRoaXMudmFsdWU7dGhpcy52YWx1ZT1sLHQodGhpcyl9dGhpcy52YWx1ZSE9PWwmJnRoaXMuY29tbWl0dGVyLmNvbW1pdCgpfX1jbGFzcyBFe2NvbnN0cnVjdG9yKHQpe3RoaXMudmFsdWU9dm9pZCAwLHRoaXMuX19wZW5kaW5nVmFsdWU9dm9pZCAwLHRoaXMub3B0aW9ucz10fWFwcGVuZEludG8odCl7dGhpcy5zdGFydE5vZGU9dC5hcHBlbmRDaGlsZChnKCkpLHRoaXMuZW5kTm9kZT10LmFwcGVuZENoaWxkKGcoKSl9aW5zZXJ0QWZ0ZXJOb2RlKHQpe3RoaXMuc3RhcnROb2RlPXQsdGhpcy5lbmROb2RlPXQubmV4dFNpYmxpbmd9YXBwZW5kSW50b1BhcnQodCl7dC5fX2luc2VydCh0aGlzLnN0YXJ0Tm9kZT1nKCkpLHQuX19pbnNlcnQodGhpcy5lbmROb2RlPWcoKSl9aW5zZXJ0QWZ0ZXJQYXJ0KHQpe3QuX19pbnNlcnQodGhpcy5zdGFydE5vZGU9ZygpKSx0aGlzLmVuZE5vZGU9dC5lbmROb2RlLHQuZW5kTm9kZT10aGlzLnN0YXJ0Tm9kZX1zZXRWYWx1ZSh0KXt0aGlzLl9fcGVuZGluZ1ZhbHVlPXR9Y29tbWl0KCl7Zm9yKDtzKHRoaXMuX19wZW5kaW5nVmFsdWUpOyl7Y29uc3QgdD10aGlzLl9fcGVuZGluZ1ZhbHVlO3RoaXMuX19wZW5kaW5nVmFsdWU9bCx0KHRoaXMpfWNvbnN0IHQ9dGhpcy5fX3BlbmRpbmdWYWx1ZTt0IT09bCYmKFModCk/dCE9PXRoaXMudmFsdWUmJnRoaXMuX19jb21taXRUZXh0KHQpOnQgaW5zdGFuY2VvZiB3P3RoaXMuX19jb21taXRUZW1wbGF0ZVJlc3VsdCh0KTp0IGluc3RhbmNlb2YgTm9kZT90aGlzLl9fY29tbWl0Tm9kZSh0KTpBKHQpP3RoaXMuX19jb21taXRJdGVyYWJsZSh0KTp0PT09dT8odGhpcy52YWx1ZT11LHRoaXMuY2xlYXIoKSk6dGhpcy5fX2NvbW1pdFRleHQodCkpfV9faW5zZXJ0KHQpe3RoaXMuZW5kTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0LHRoaXMuZW5kTm9kZSl9X19jb21taXROb2RlKHQpe3RoaXMudmFsdWUhPT10JiYodGhpcy5jbGVhcigpLHRoaXMuX19pbnNlcnQodCksdGhpcy52YWx1ZT10KX1fX2NvbW1pdFRleHQodCl7Y29uc3QgZT10aGlzLnN0YXJ0Tm9kZS5uZXh0U2libGluZyxpPSJzdHJpbmciPT10eXBlb2YodD1udWxsPT10PyIiOnQpP3Q6U3RyaW5nKHQpO2U9PT10aGlzLmVuZE5vZGUucHJldmlvdXNTaWJsaW5nJiYzPT09ZS5ub2RlVHlwZT9lLmRhdGE9aTp0aGlzLl9fY29tbWl0Tm9kZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShpKSksdGhpcy52YWx1ZT10fV9fY29tbWl0VGVtcGxhdGVSZXN1bHQodCl7Y29uc3QgZT10aGlzLm9wdGlvbnMudGVtcGxhdGVGYWN0b3J5KHQpO2lmKHRoaXMudmFsdWUgaW5zdGFuY2VvZiB5JiZ0aGlzLnZhbHVlLnRlbXBsYXRlPT09ZSl0aGlzLnZhbHVlLnVwZGF0ZSh0LnZhbHVlcyk7ZWxzZXtjb25zdCBpPW5ldyB5KGUsdC5wcm9jZXNzb3IsdGhpcy5vcHRpb25zKSxuPWkuX2Nsb25lKCk7aS51cGRhdGUodC52YWx1ZXMpLHRoaXMuX19jb21taXROb2RlKG4pLHRoaXMudmFsdWU9aX19X19jb21taXRJdGVyYWJsZSh0KXtBcnJheS5pc0FycmF5KHRoaXMudmFsdWUpfHwodGhpcy52YWx1ZT1bXSx0aGlzLmNsZWFyKCkpO2NvbnN0IGU9dGhpcy52YWx1ZTtsZXQgaSxuPTA7Zm9yKGNvbnN0IHIgb2YgdClpPWVbbl0sdm9pZCAwPT09aSYmKGk9bmV3IEUodGhpcy5vcHRpb25zKSxlLnB1c2goaSksMD09PW4/aS5hcHBlbmRJbnRvUGFydCh0aGlzKTppLmluc2VydEFmdGVyUGFydChlW24tMV0pKSxpLnNldFZhbHVlKHIpLGkuY29tbWl0KCksbisrO248ZS5sZW5ndGgmJihlLmxlbmd0aD1uLHRoaXMuY2xlYXIoaSYmaS5lbmROb2RlKSl9Y2xlYXIodD10aGlzLnN0YXJ0Tm9kZSl7Yyh0aGlzLnN0YXJ0Tm9kZS5wYXJlbnROb2RlLHQubmV4dFNpYmxpbmcsdGhpcy5lbmROb2RlKX19Y2xhc3MgVHtjb25zdHJ1Y3Rvcih0LGUsaSl7aWYodGhpcy52YWx1ZT12b2lkIDAsdGhpcy5fX3BlbmRpbmdWYWx1ZT12b2lkIDAsMiE9PWkubGVuZ3RofHwiIiE9PWlbMF18fCIiIT09aVsxXSl0aHJvdyBuZXcgRXJyb3IoIkJvb2xlYW4gYXR0cmlidXRlcyBjYW4gb25seSBjb250YWluIGEgc2luZ2xlIGV4cHJlc3Npb24iKTt0aGlzLmVsZW1lbnQ9dCx0aGlzLm5hbWU9ZSx0aGlzLnN0cmluZ3M9aX1zZXRWYWx1ZSh0KXt0aGlzLl9fcGVuZGluZ1ZhbHVlPXR9Y29tbWl0KCl7Zm9yKDtzKHRoaXMuX19wZW5kaW5nVmFsdWUpOyl7Y29uc3QgdD10aGlzLl9fcGVuZGluZ1ZhbHVlO3RoaXMuX19wZW5kaW5nVmFsdWU9bCx0KHRoaXMpfWlmKHRoaXMuX19wZW5kaW5nVmFsdWU9PT1sKXJldHVybjtjb25zdCB0PSEhdGhpcy5fX3BlbmRpbmdWYWx1ZTt0aGlzLnZhbHVlIT09dCYmKHQ/dGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSh0aGlzLm5hbWUsIiIpOnRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUodGhpcy5uYW1lKSx0aGlzLnZhbHVlPXQpLHRoaXMuX19wZW5kaW5nVmFsdWU9bH19Y2xhc3MgSSBleHRlbmRzIEN7Y29uc3RydWN0b3IodCxlLGkpe3N1cGVyKHQsZSxpKSx0aGlzLnNpbmdsZT0yPT09aS5sZW5ndGgmJiIiPT09aVswXSYmIiI9PT1pWzFdfV9jcmVhdGVQYXJ0KCl7cmV0dXJuIG5ldyBSKHRoaXMpfV9nZXRWYWx1ZSgpe3JldHVybiB0aGlzLnNpbmdsZT90aGlzLnBhcnRzWzBdLnZhbHVlOnN1cGVyLl9nZXRWYWx1ZSgpfWNvbW1pdCgpe3RoaXMuZGlydHkmJih0aGlzLmRpcnR5PSExLHRoaXMuZWxlbWVudFt0aGlzLm5hbWVdPXRoaXMuX2dldFZhbHVlKCkpfX1jbGFzcyBSIGV4dGVuZHMga3t9bGV0IFA9ITE7dHJ5e2NvbnN0IHQ9e2dldCBjYXB0dXJlKCl7cmV0dXJuIFA9ITAsITF9fTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigidGVzdCIsdCx0KSx3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigidGVzdCIsdCx0KX1jYXRjaCh0KXt9Y2xhc3MgTntjb25zdHJ1Y3Rvcih0LGUsaSl7dGhpcy52YWx1ZT12b2lkIDAsdGhpcy5fX3BlbmRpbmdWYWx1ZT12b2lkIDAsdGhpcy5lbGVtZW50PXQsdGhpcy5ldmVudE5hbWU9ZSx0aGlzLmV2ZW50Q29udGV4dD1pLHRoaXMuX19ib3VuZEhhbmRsZUV2ZW50PXQ9PnRoaXMuaGFuZGxlRXZlbnQodCl9c2V0VmFsdWUodCl7dGhpcy5fX3BlbmRpbmdWYWx1ZT10fWNvbW1pdCgpe2Zvcig7cyh0aGlzLl9fcGVuZGluZ1ZhbHVlKTspe2NvbnN0IHQ9dGhpcy5fX3BlbmRpbmdWYWx1ZTt0aGlzLl9fcGVuZGluZ1ZhbHVlPWwsdCh0aGlzKX1pZih0aGlzLl9fcGVuZGluZ1ZhbHVlPT09bClyZXR1cm47Y29uc3QgdD10aGlzLl9fcGVuZGluZ1ZhbHVlLGU9dGhpcy52YWx1ZSxpPW51bGw9PXR8fG51bGwhPWUmJih0LmNhcHR1cmUhPT1lLmNhcHR1cmV8fHQub25jZSE9PWUub25jZXx8dC5wYXNzaXZlIT09ZS5wYXNzaXZlKSxuPW51bGwhPXQmJihudWxsPT1lfHxpKTtpJiZ0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLmV2ZW50TmFtZSx0aGlzLl9fYm91bmRIYW5kbGVFdmVudCx0aGlzLl9fb3B0aW9ucyksbiYmKHRoaXMuX19vcHRpb25zPU8odCksdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodGhpcy5ldmVudE5hbWUsdGhpcy5fX2JvdW5kSGFuZGxlRXZlbnQsdGhpcy5fX29wdGlvbnMpKSx0aGlzLnZhbHVlPXQsdGhpcy5fX3BlbmRpbmdWYWx1ZT1sfWhhbmRsZUV2ZW50KHQpeyJmdW5jdGlvbiI9PXR5cGVvZiB0aGlzLnZhbHVlP3RoaXMudmFsdWUuY2FsbCh0aGlzLmV2ZW50Q29udGV4dHx8dGhpcy5lbGVtZW50LHQpOnRoaXMudmFsdWUuaGFuZGxlRXZlbnQodCl9fWNvbnN0IE89dD0+dCYmKFA/e2NhcHR1cmU6dC5jYXB0dXJlLHBhc3NpdmU6dC5wYXNzaXZlLG9uY2U6dC5vbmNlfTp0LmNhcHR1cmUpCi8qKgogICAgICogQGxpY2Vuc2UKICAgICAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuCiAgICAgKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQKICAgICAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dAogICAgICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdAogICAgICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0CiAgICAgKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQKICAgICAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0CiAgICAgKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzbwogICAgICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdAogICAgICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0CiAgICAgKi87Y29uc3QgSD1uZXcgY2xhc3N7aGFuZGxlQXR0cmlidXRlRXhwcmVzc2lvbnModCxlLGksbil7Y29uc3Qgcj1lWzBdO2lmKCIuIj09PXIpe3JldHVybiBuZXcgSSh0LGUuc2xpY2UoMSksaSkucGFydHN9cmV0dXJuIkAiPT09cj9bbmV3IE4odCxlLnNsaWNlKDEpLG4uZXZlbnRDb250ZXh0KV06Ij8iPT09cj9bbmV3IFQodCxlLnNsaWNlKDEpLGkpXTpuZXcgQyh0LGUsaSkucGFydHN9aGFuZGxlVGV4dEV4cHJlc3Npb24odCl7cmV0dXJuIG5ldyBFKHQpfX07Ci8qKgogICAgICogQGxpY2Vuc2UKICAgICAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuCiAgICAgKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQKICAgICAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dAogICAgICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdAogICAgICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0CiAgICAgKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQKICAgICAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0CiAgICAgKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzbwogICAgICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdAogICAgICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0CiAgICAgKi9mdW5jdGlvbiBWKHQpe2xldCBlPUQuZ2V0KHQudHlwZSk7dm9pZCAwPT09ZSYmKGU9e3N0cmluZ3NBcnJheTpuZXcgV2Vha01hcCxrZXlTdHJpbmc6bmV3IE1hcH0sRC5zZXQodC50eXBlLGUpKTtsZXQgaT1lLnN0cmluZ3NBcnJheS5nZXQodC5zdHJpbmdzKTtpZih2b2lkIDAhPT1pKXJldHVybiBpO2NvbnN0IG49dC5zdHJpbmdzLmpvaW4ocCk7cmV0dXJuIGk9ZS5rZXlTdHJpbmcuZ2V0KG4pLHZvaWQgMD09PWkmJihpPW5ldyBmKHQsdC5nZXRUZW1wbGF0ZUVsZW1lbnQoKSksZS5rZXlTdHJpbmcuc2V0KG4saSkpLGUuc3RyaW5nc0FycmF5LnNldCh0LnN0cmluZ3MsaSksaX1jb25zdCBEPW5ldyBNYXAsRj1uZXcgV2Vha01hcDsKLyoqCiAgICAgKiBAbGljZW5zZQogICAgICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KICAgICAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdAogICAgICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0CiAgICAgKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0CiAgICAgKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHQKICAgICAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdAogICAgICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHQKICAgICAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvCiAgICAgKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0CiAgICAgKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHQKICAgICAqLwovKioKICAgICAqIEBsaWNlbnNlCiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogICAgICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0CiAgICAgKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHQKICAgICAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQKICAgICAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dAogICAgICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0CiAgICAgKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dAogICAgICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc28KICAgICAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQKICAgICAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dAogICAgICovCih3aW5kb3cubGl0SHRtbFZlcnNpb25zfHwod2luZG93LmxpdEh0bWxWZXJzaW9ucz1bXSkpLnB1c2goIjEuMS4yIik7Y29uc3QgTT0odCwuLi5lKT0+bmV3IHcodCxlLCJodG1sIixIKQovKioKICAgICAqIEBsaWNlbnNlCiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogICAgICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0CiAgICAgKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHQKICAgICAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQKICAgICAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dAogICAgICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0CiAgICAgKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dAogICAgICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc28KICAgICAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQKICAgICAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dAogICAgICovO2Z1bmN0aW9uIEwodCxlKXtjb25zdHtlbGVtZW50Ontjb250ZW50Oml9LHBhcnRzOm59PXQscj1kb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGksMTMzLG51bGwsITEpO2xldCBvPXoobiksYT1uW29dLHM9LTEsZD0wO2NvbnN0IGM9W107bGV0IGw9bnVsbDtmb3IoO3IubmV4dE5vZGUoKTspe3MrKztjb25zdCB0PXIuY3VycmVudE5vZGU7Zm9yKHQucHJldmlvdXNTaWJsaW5nPT09bCYmKGw9bnVsbCksZS5oYXModCkmJihjLnB1c2godCksbnVsbD09PWwmJihsPXQpKSxudWxsIT09bCYmZCsrO3ZvaWQgMCE9PWEmJmEuaW5kZXg9PT1zOylhLmluZGV4PW51bGwhPT1sPy0xOmEuaW5kZXgtZCxvPXoobixvKSxhPW5bb119Yy5mb3JFYWNoKHQ9PnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0KSl9Y29uc3QgVT10PT57bGV0IGU9MTE9PT10Lm5vZGVUeXBlPzA6MTtjb25zdCBpPWRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIodCwxMzMsbnVsbCwhMSk7Zm9yKDtpLm5leHROb2RlKCk7KWUrKztyZXR1cm4gZX0sej0odCxlPS0xKT0+e2ZvcihsZXQgaT1lKzE7aTx0Lmxlbmd0aDtpKyspe2NvbnN0IGU9dFtpXTtpZihiKGUpKXJldHVybiBpfXJldHVybi0xfTsKLyoqCiAgICAgKiBAbGljZW5zZQogICAgICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KICAgICAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdAogICAgICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0CiAgICAgKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0CiAgICAgKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHQKICAgICAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdAogICAgICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHQKICAgICAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvCiAgICAgKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0CiAgICAgKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHQKICAgICAqLwpjb25zdCBCPSh0LGUpPT5gJHt0fS0tJHtlfWA7bGV0IGo9ITA7dm9pZCAwPT09d2luZG93LlNoYWR5Q1NTP2o9ITE6dm9pZCAwPT09d2luZG93LlNoYWR5Q1NTLnByZXBhcmVUZW1wbGF0ZURvbSYmKGNvbnNvbGUud2FybigiSW5jb21wYXRpYmxlIFNoYWR5Q1NTIHZlcnNpb24gZGV0ZWN0ZWQuIFBsZWFzZSB1cGRhdGUgdG8gYXQgbGVhc3QgQHdlYmNvbXBvbmVudHMvd2ViY29tcG9uZW50c2pzQDIuMC4yIGFuZCBAd2ViY29tcG9uZW50cy9zaGFkeWNzc0AxLjMuMS4iKSxqPSExKTtjb25zdCAkPXQ9PmU9Pntjb25zdCBpPUIoZS50eXBlLHQpO2xldCBuPUQuZ2V0KGkpO3ZvaWQgMD09PW4mJihuPXtzdHJpbmdzQXJyYXk6bmV3IFdlYWtNYXAsa2V5U3RyaW5nOm5ldyBNYXB9LEQuc2V0KGksbikpO2xldCByPW4uc3RyaW5nc0FycmF5LmdldChlLnN0cmluZ3MpO2lmKHZvaWQgMCE9PXIpcmV0dXJuIHI7Y29uc3Qgbz1lLnN0cmluZ3Muam9pbihwKTtpZihyPW4ua2V5U3RyaW5nLmdldChvKSx2b2lkIDA9PT1yKXtjb25zdCBpPWUuZ2V0VGVtcGxhdGVFbGVtZW50KCk7aiYmd2luZG93LlNoYWR5Q1NTLnByZXBhcmVUZW1wbGF0ZURvbShpLHQpLHI9bmV3IGYoZSxpKSxuLmtleVN0cmluZy5zZXQobyxyKX1yZXR1cm4gbi5zdHJpbmdzQXJyYXkuc2V0KGUuc3RyaW5ncyxyKSxyfSxxPVsiaHRtbCIsInN2ZyJdLEc9bmV3IFNldCxXPSh0LGUsaSk9PntHLmFkZCh0KTtjb25zdCBuPWk/aS5lbGVtZW50OmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRlbXBsYXRlIikscj1lLnF1ZXJ5U2VsZWN0b3JBbGwoInN0eWxlIikse2xlbmd0aDpvfT1yO2lmKDA9PT1vKXJldHVybiB2b2lkIHdpbmRvdy5TaGFkeUNTUy5wcmVwYXJlVGVtcGxhdGVTdHlsZXMobix0KTtjb25zdCBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInN0eWxlIik7Zm9yKGxldCB0PTA7dDxvO3QrKyl7Y29uc3QgZT1yW3RdO2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKSxhLnRleHRDb250ZW50Kz1lLnRleHRDb250ZW50fSh0PT57cS5mb3JFYWNoKGU9Pntjb25zdCBpPUQuZ2V0KEIoZSx0KSk7dm9pZCAwIT09aSYmaS5rZXlTdHJpbmcuZm9yRWFjaCh0PT57Y29uc3R7ZWxlbWVudDp7Y29udGVudDplfX09dCxpPW5ldyBTZXQ7QXJyYXkuZnJvbShlLnF1ZXJ5U2VsZWN0b3JBbGwoInN0eWxlIikpLmZvckVhY2godD0+e2kuYWRkKHQpfSksTCh0LGkpfSl9KX0pKHQpO2NvbnN0IHM9bi5jb250ZW50O2k/ZnVuY3Rpb24odCxlLGk9bnVsbCl7Y29uc3R7ZWxlbWVudDp7Y29udGVudDpufSxwYXJ0czpyfT10O2lmKG51bGw9PWkpcmV0dXJuIHZvaWQgbi5hcHBlbmRDaGlsZChlKTtjb25zdCBvPWRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIobiwxMzMsbnVsbCwhMSk7bGV0IGE9eihyKSxzPTAsZD0tMTtmb3IoO28ubmV4dE5vZGUoKTspe2ZvcihkKyssby5jdXJyZW50Tm9kZT09PWkmJihzPVUoZSksaS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlLGkpKTstMSE9PWEmJnJbYV0uaW5kZXg9PT1kOyl7aWYocz4wKXtmb3IoOy0xIT09YTspclthXS5pbmRleCs9cyxhPXoocixhKTtyZXR1cm59YT16KHIsYSl9fX0oaSxhLHMuZmlyc3RDaGlsZCk6cy5pbnNlcnRCZWZvcmUoYSxzLmZpcnN0Q2hpbGQpLHdpbmRvdy5TaGFkeUNTUy5wcmVwYXJlVGVtcGxhdGVTdHlsZXMobix0KTtjb25zdCBkPXMucXVlcnlTZWxlY3Rvcigic3R5bGUiKTtpZih3aW5kb3cuU2hhZHlDU1MubmF0aXZlU2hhZG93JiZudWxsIT09ZCllLmluc2VydEJlZm9yZShkLmNsb25lTm9kZSghMCksZS5maXJzdENoaWxkKTtlbHNlIGlmKGkpe3MuaW5zZXJ0QmVmb3JlKGEscy5maXJzdENoaWxkKTtjb25zdCB0PW5ldyBTZXQ7dC5hZGQoYSksTChpLHQpfX07d2luZG93LkpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHk9KHQsZSk9PnQ7Y29uc3QgWD17dG9BdHRyaWJ1dGUodCxlKXtzd2l0Y2goZSl7Y2FzZSBCb29sZWFuOnJldHVybiB0PyIiOm51bGw7Y2FzZSBPYmplY3Q6Y2FzZSBBcnJheTpyZXR1cm4gbnVsbD09dD90OkpTT04uc3RyaW5naWZ5KHQpfXJldHVybiB0fSxmcm9tQXR0cmlidXRlKHQsZSl7c3dpdGNoKGUpe2Nhc2UgQm9vbGVhbjpyZXR1cm4gbnVsbCE9PXQ7Y2FzZSBOdW1iZXI6cmV0dXJuIG51bGw9PT10P251bGw6TnVtYmVyKHQpO2Nhc2UgT2JqZWN0OmNhc2UgQXJyYXk6cmV0dXJuIEpTT04ucGFyc2UodCl9cmV0dXJuIHR9fSxLPSh0LGUpPT5lIT09dCYmKGU9PWV8fHQ9PXQpLEo9e2F0dHJpYnV0ZTohMCx0eXBlOlN0cmluZyxjb252ZXJ0ZXI6WCxyZWZsZWN0OiExLGhhc0NoYW5nZWQ6S30sWT1Qcm9taXNlLnJlc29sdmUoITApO2NsYXNzIFogZXh0ZW5kcyBIVE1MRWxlbWVudHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5fdXBkYXRlU3RhdGU9MCx0aGlzLl9pbnN0YW5jZVByb3BlcnRpZXM9dm9pZCAwLHRoaXMuX3VwZGF0ZVByb21pc2U9WSx0aGlzLl9oYXNDb25uZWN0ZWRSZXNvbHZlcj12b2lkIDAsdGhpcy5fY2hhbmdlZFByb3BlcnRpZXM9bmV3IE1hcCx0aGlzLl9yZWZsZWN0aW5nUHJvcGVydGllcz12b2lkIDAsdGhpcy5pbml0aWFsaXplKCl9c3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKXt0aGlzLmZpbmFsaXplKCk7Y29uc3QgdD1bXTtyZXR1cm4gdGhpcy5fY2xhc3NQcm9wZXJ0aWVzLmZvckVhY2goKGUsaSk9Pntjb25zdCBuPXRoaXMuX2F0dHJpYnV0ZU5hbWVGb3JQcm9wZXJ0eShpLGUpO3ZvaWQgMCE9PW4mJih0aGlzLl9hdHRyaWJ1dGVUb1Byb3BlcnR5TWFwLnNldChuLGkpLHQucHVzaChuKSl9KSx0fXN0YXRpYyBfZW5zdXJlQ2xhc3NQcm9wZXJ0aWVzKCl7aWYoIXRoaXMuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgiX2NsYXNzUHJvcGVydGllcyIsdGhpcykpKXt0aGlzLl9jbGFzc1Byb3BlcnRpZXM9bmV3IE1hcDtjb25zdCB0PU9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fY2xhc3NQcm9wZXJ0aWVzO3ZvaWQgMCE9PXQmJnQuZm9yRWFjaCgodCxlKT0+dGhpcy5fY2xhc3NQcm9wZXJ0aWVzLnNldChlLHQpKX19c3RhdGljIGNyZWF0ZVByb3BlcnR5KHQsZT1KKXtpZih0aGlzLl9lbnN1cmVDbGFzc1Byb3BlcnRpZXMoKSx0aGlzLl9jbGFzc1Byb3BlcnRpZXMuc2V0KHQsZSksZS5ub0FjY2Vzc29yfHx0aGlzLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSh0KSlyZXR1cm47Y29uc3QgaT0ic3ltYm9sIj09dHlwZW9mIHQ/U3ltYm9sKCk6YF9fJHt0fWA7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMucHJvdG90eXBlLHQse2dldCgpe3JldHVybiB0aGlzW2ldfSxzZXQoZSl7Y29uc3Qgbj10aGlzW3RdO3RoaXNbaV09ZSx0aGlzLl9yZXF1ZXN0VXBkYXRlKHQsbil9LGNvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiEwfSl9c3RhdGljIGZpbmFsaXplKCl7Y29uc3QgdD1PYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyk7aWYodC5oYXNPd25Qcm9wZXJ0eSgiZmluYWxpemVkIil8fHQuZmluYWxpemUoKSx0aGlzLmZpbmFsaXplZD0hMCx0aGlzLl9lbnN1cmVDbGFzc1Byb3BlcnRpZXMoKSx0aGlzLl9hdHRyaWJ1dGVUb1Byb3BlcnR5TWFwPW5ldyBNYXAsdGhpcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCJwcm9wZXJ0aWVzIix0aGlzKSkpe2NvbnN0IHQ9dGhpcy5wcm9wZXJ0aWVzLGU9Wy4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHQpLC4uLiJmdW5jdGlvbiI9PXR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzP09iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModCk6W11dO2Zvcihjb25zdCBpIG9mIGUpdGhpcy5jcmVhdGVQcm9wZXJ0eShpLHRbaV0pfX1zdGF0aWMgX2F0dHJpYnV0ZU5hbWVGb3JQcm9wZXJ0eSh0LGUpe2NvbnN0IGk9ZS5hdHRyaWJ1dGU7cmV0dXJuITE9PT1pP3ZvaWQgMDoic3RyaW5nIj09dHlwZW9mIGk/aToic3RyaW5nIj09dHlwZW9mIHQ/dC50b0xvd2VyQ2FzZSgpOnZvaWQgMH1zdGF0aWMgX3ZhbHVlSGFzQ2hhbmdlZCh0LGUsaT1LKXtyZXR1cm4gaSh0LGUpfXN0YXRpYyBfcHJvcGVydHlWYWx1ZUZyb21BdHRyaWJ1dGUodCxlKXtjb25zdCBpPWUudHlwZSxuPWUuY29udmVydGVyfHxYLHI9ImZ1bmN0aW9uIj09dHlwZW9mIG4/bjpuLmZyb21BdHRyaWJ1dGU7cmV0dXJuIHI/cih0LGkpOnR9c3RhdGljIF9wcm9wZXJ0eVZhbHVlVG9BdHRyaWJ1dGUodCxlKXtpZih2b2lkIDA9PT1lLnJlZmxlY3QpcmV0dXJuO2NvbnN0IGk9ZS50eXBlLG49ZS5jb252ZXJ0ZXI7cmV0dXJuKG4mJm4udG9BdHRyaWJ1dGV8fFgudG9BdHRyaWJ1dGUpKHQsaSl9aW5pdGlhbGl6ZSgpe3RoaXMuX3NhdmVJbnN0YW5jZVByb3BlcnRpZXMoKSx0aGlzLl9yZXF1ZXN0VXBkYXRlKCl9X3NhdmVJbnN0YW5jZVByb3BlcnRpZXMoKXt0aGlzLmNvbnN0cnVjdG9yLl9jbGFzc1Byb3BlcnRpZXMuZm9yRWFjaCgodCxlKT0+e2lmKHRoaXMuaGFzT3duUHJvcGVydHkoZSkpe2NvbnN0IHQ9dGhpc1tlXTtkZWxldGUgdGhpc1tlXSx0aGlzLl9pbnN0YW5jZVByb3BlcnRpZXN8fCh0aGlzLl9pbnN0YW5jZVByb3BlcnRpZXM9bmV3IE1hcCksdGhpcy5faW5zdGFuY2VQcm9wZXJ0aWVzLnNldChlLHQpfX0pfV9hcHBseUluc3RhbmNlUHJvcGVydGllcygpe3RoaXMuX2luc3RhbmNlUHJvcGVydGllcy5mb3JFYWNoKCh0LGUpPT50aGlzW2VdPXQpLHRoaXMuX2luc3RhbmNlUHJvcGVydGllcz12b2lkIDB9Y29ubmVjdGVkQ2FsbGJhY2soKXt0aGlzLl91cGRhdGVTdGF0ZT0zMnx0aGlzLl91cGRhdGVTdGF0ZSx0aGlzLl9oYXNDb25uZWN0ZWRSZXNvbHZlciYmKHRoaXMuX2hhc0Nvbm5lY3RlZFJlc29sdmVyKCksdGhpcy5faGFzQ29ubmVjdGVkUmVzb2x2ZXI9dm9pZCAwKX1kaXNjb25uZWN0ZWRDYWxsYmFjaygpe31hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sodCxlLGkpe2UhPT1pJiZ0aGlzLl9hdHRyaWJ1dGVUb1Byb3BlcnR5KHQsaSl9X3Byb3BlcnR5VG9BdHRyaWJ1dGUodCxlLGk9Sil7Y29uc3Qgbj10aGlzLmNvbnN0cnVjdG9yLHI9bi5fYXR0cmlidXRlTmFtZUZvclByb3BlcnR5KHQsaSk7aWYodm9pZCAwIT09cil7Y29uc3QgdD1uLl9wcm9wZXJ0eVZhbHVlVG9BdHRyaWJ1dGUoZSxpKTtpZih2b2lkIDA9PT10KXJldHVybjt0aGlzLl91cGRhdGVTdGF0ZT04fHRoaXMuX3VwZGF0ZVN0YXRlLG51bGw9PXQ/dGhpcy5yZW1vdmVBdHRyaWJ1dGUocik6dGhpcy5zZXRBdHRyaWJ1dGUocix0KSx0aGlzLl91cGRhdGVTdGF0ZT0tOSZ0aGlzLl91cGRhdGVTdGF0ZX19X2F0dHJpYnV0ZVRvUHJvcGVydHkodCxlKXtpZig4JnRoaXMuX3VwZGF0ZVN0YXRlKXJldHVybjtjb25zdCBpPXRoaXMuY29uc3RydWN0b3Isbj1pLl9hdHRyaWJ1dGVUb1Byb3BlcnR5TWFwLmdldCh0KTtpZih2b2lkIDAhPT1uKXtjb25zdCB0PWkuX2NsYXNzUHJvcGVydGllcy5nZXQobil8fEo7dGhpcy5fdXBkYXRlU3RhdGU9MTZ8dGhpcy5fdXBkYXRlU3RhdGUsdGhpc1tuXT1pLl9wcm9wZXJ0eVZhbHVlRnJvbUF0dHJpYnV0ZShlLHQpLHRoaXMuX3VwZGF0ZVN0YXRlPS0xNyZ0aGlzLl91cGRhdGVTdGF0ZX19X3JlcXVlc3RVcGRhdGUodCxlKXtsZXQgaT0hMDtpZih2b2lkIDAhPT10KXtjb25zdCBuPXRoaXMuY29uc3RydWN0b3Iscj1uLl9jbGFzc1Byb3BlcnRpZXMuZ2V0KHQpfHxKO24uX3ZhbHVlSGFzQ2hhbmdlZCh0aGlzW3RdLGUsci5oYXNDaGFuZ2VkKT8odGhpcy5fY2hhbmdlZFByb3BlcnRpZXMuaGFzKHQpfHx0aGlzLl9jaGFuZ2VkUHJvcGVydGllcy5zZXQodCxlKSwhMCE9PXIucmVmbGVjdHx8MTYmdGhpcy5fdXBkYXRlU3RhdGV8fCh2b2lkIDA9PT10aGlzLl9yZWZsZWN0aW5nUHJvcGVydGllcyYmKHRoaXMuX3JlZmxlY3RpbmdQcm9wZXJ0aWVzPW5ldyBNYXApLHRoaXMuX3JlZmxlY3RpbmdQcm9wZXJ0aWVzLnNldCh0LHIpKSk6aT0hMX0hdGhpcy5faGFzUmVxdWVzdGVkVXBkYXRlJiZpJiZ0aGlzLl9lbnF1ZXVlVXBkYXRlKCl9cmVxdWVzdFVwZGF0ZSh0LGUpe3JldHVybiB0aGlzLl9yZXF1ZXN0VXBkYXRlKHQsZSksdGhpcy51cGRhdGVDb21wbGV0ZX1hc3luYyBfZW5xdWV1ZVVwZGF0ZSgpe2xldCB0LGU7dGhpcy5fdXBkYXRlU3RhdGU9NHx0aGlzLl91cGRhdGVTdGF0ZTtjb25zdCBpPXRoaXMuX3VwZGF0ZVByb21pc2U7dGhpcy5fdXBkYXRlUHJvbWlzZT1uZXcgUHJvbWlzZSgoaSxuKT0+e3Q9aSxlPW59KTt0cnl7YXdhaXQgaX1jYXRjaCh0KXt9dGhpcy5faGFzQ29ubmVjdGVkfHxhd2FpdCBuZXcgUHJvbWlzZSh0PT50aGlzLl9oYXNDb25uZWN0ZWRSZXNvbHZlcj10KTt0cnl7Y29uc3QgdD10aGlzLnBlcmZvcm1VcGRhdGUoKTtudWxsIT10JiZhd2FpdCB0fWNhdGNoKHQpe2UodCl9dCghdGhpcy5faGFzUmVxdWVzdGVkVXBkYXRlKX1nZXQgX2hhc0Nvbm5lY3RlZCgpe3JldHVybiAzMiZ0aGlzLl91cGRhdGVTdGF0ZX1nZXQgX2hhc1JlcXVlc3RlZFVwZGF0ZSgpe3JldHVybiA0JnRoaXMuX3VwZGF0ZVN0YXRlfWdldCBoYXNVcGRhdGVkKCl7cmV0dXJuIDEmdGhpcy5fdXBkYXRlU3RhdGV9cGVyZm9ybVVwZGF0ZSgpe3RoaXMuX2luc3RhbmNlUHJvcGVydGllcyYmdGhpcy5fYXBwbHlJbnN0YW5jZVByb3BlcnRpZXMoKTtsZXQgdD0hMTtjb25zdCBlPXRoaXMuX2NoYW5nZWRQcm9wZXJ0aWVzO3RyeXt0PXRoaXMuc2hvdWxkVXBkYXRlKGUpLHQmJnRoaXMudXBkYXRlKGUpfWNhdGNoKGUpe3Rocm93IHQ9ITEsZX1maW5hbGx5e3RoaXMuX21hcmtVcGRhdGVkKCl9dCYmKDEmdGhpcy5fdXBkYXRlU3RhdGV8fCh0aGlzLl91cGRhdGVTdGF0ZT0xfHRoaXMuX3VwZGF0ZVN0YXRlLHRoaXMuZmlyc3RVcGRhdGVkKGUpKSx0aGlzLnVwZGF0ZWQoZSkpfV9tYXJrVXBkYXRlZCgpe3RoaXMuX2NoYW5nZWRQcm9wZXJ0aWVzPW5ldyBNYXAsdGhpcy5fdXBkYXRlU3RhdGU9LTUmdGhpcy5fdXBkYXRlU3RhdGV9Z2V0IHVwZGF0ZUNvbXBsZXRlKCl7cmV0dXJuIHRoaXMuX2dldFVwZGF0ZUNvbXBsZXRlKCl9X2dldFVwZGF0ZUNvbXBsZXRlKCl7cmV0dXJuIHRoaXMuX3VwZGF0ZVByb21pc2V9c2hvdWxkVXBkYXRlKHQpe3JldHVybiEwfXVwZGF0ZSh0KXt2b2lkIDAhPT10aGlzLl9yZWZsZWN0aW5nUHJvcGVydGllcyYmdGhpcy5fcmVmbGVjdGluZ1Byb3BlcnRpZXMuc2l6ZT4wJiYodGhpcy5fcmVmbGVjdGluZ1Byb3BlcnRpZXMuZm9yRWFjaCgodCxlKT0+dGhpcy5fcHJvcGVydHlUb0F0dHJpYnV0ZShlLHRoaXNbZV0sdCkpLHRoaXMuX3JlZmxlY3RpbmdQcm9wZXJ0aWVzPXZvaWQgMCl9dXBkYXRlZCh0KXt9Zmlyc3RVcGRhdGVkKHQpe319Wi5maW5hbGl6ZWQ9ITA7Ci8qKgogICAgICogQGxpY2Vuc2UKICAgICAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuCiAgICAgKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQKICAgICAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dAogICAgICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdAogICAgICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0CiAgICAgKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQKICAgICAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0CiAgICAgKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzbwogICAgICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdAogICAgICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0CiAgICAgKi8KY29uc3QgUT10PT5lPT4iZnVuY3Rpb24iPT10eXBlb2YgZT8oKHQsZSk9Pih3aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKHQsZSksZSkpKHQsZSk6KCh0LGUpPT57Y29uc3R7a2luZDppLGVsZW1lbnRzOm59PWU7cmV0dXJue2tpbmQ6aSxlbGVtZW50czpuLGZpbmlzaGVyKGUpe3dpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUodCxlKX19fSkodCxlKSx0dD0odCxlKT0+Im1ldGhvZCIhPT1lLmtpbmR8fCFlLmRlc2NyaXB0b3J8fCJ2YWx1ZSJpbiBlLmRlc2NyaXB0b3I/e2tpbmQ6ImZpZWxkIixrZXk6U3ltYm9sKCkscGxhY2VtZW50OiJvd24iLGRlc2NyaXB0b3I6e30saW5pdGlhbGl6ZXIoKXsiZnVuY3Rpb24iPT10eXBlb2YgZS5pbml0aWFsaXplciYmKHRoaXNbZS5rZXldPWUuaW5pdGlhbGl6ZXIuY2FsbCh0aGlzKSl9LGZpbmlzaGVyKGkpe2kuY3JlYXRlUHJvcGVydHkoZS5rZXksdCl9fTpPYmplY3QuYXNzaWduKHt9LGUse2ZpbmlzaGVyKGkpe2kuY3JlYXRlUHJvcGVydHkoZS5rZXksdCl9fSk7ZnVuY3Rpb24gZXQodCl7cmV0dXJuKGUsaSk9PnZvaWQgMCE9PWk/KCh0LGUsaSk9PntlLmNvbnN0cnVjdG9yLmNyZWF0ZVByb3BlcnR5KGksdCl9KSh0LGUsaSk6dHQodCxlKX1mdW5jdGlvbiBpdCh0KXtyZXR1cm4oZSxpKT0+e2NvbnN0IG49e2dldCgpe3JldHVybiB0aGlzLnJlbmRlclJvb3QucXVlcnlTZWxlY3Rvcih0KX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9O3JldHVybiB2b2lkIDAhPT1pP250KG4sZSxpKTpydChuLGUpfX1jb25zdCBudD0odCxlLGkpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsaSx0KX0scnQ9KHQsZSk9Pih7a2luZDoibWV0aG9kIixwbGFjZW1lbnQ6InByb3RvdHlwZSIsa2V5OmUua2V5LGRlc2NyaXB0b3I6dH0pLG90PSJhZG9wdGVkU3R5bGVTaGVldHMiaW4gRG9jdW1lbnQucHJvdG90eXBlJiYicmVwbGFjZSJpbiBDU1NTdHlsZVNoZWV0LnByb3RvdHlwZSxhdD1TeW1ib2woKTtjbGFzcyBzdHtjb25zdHJ1Y3Rvcih0LGUpe2lmKGUhPT1hdCl0aHJvdyBuZXcgRXJyb3IoIkNTU1Jlc3VsdCBpcyBub3QgY29uc3RydWN0YWJsZS4gVXNlIGB1bnNhZmVDU1NgIG9yIGBjc3NgIGluc3RlYWQuIik7dGhpcy5jc3NUZXh0PXR9Z2V0IHN0eWxlU2hlZXQoKXtyZXR1cm4gdm9pZCAwPT09dGhpcy5fc3R5bGVTaGVldCYmKG90Pyh0aGlzLl9zdHlsZVNoZWV0PW5ldyBDU1NTdHlsZVNoZWV0LHRoaXMuX3N0eWxlU2hlZXQucmVwbGFjZVN5bmModGhpcy5jc3NUZXh0KSk6dGhpcy5fc3R5bGVTaGVldD1udWxsKSx0aGlzLl9zdHlsZVNoZWV0fXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuY3NzVGV4dH19Y29uc3QgZHQ9KHQsLi4uZSk9Pntjb25zdCBpPWUucmVkdWNlKChlLGksbik9PmUrKHQ9PntpZih0IGluc3RhbmNlb2Ygc3QpcmV0dXJuIHQuY3NzVGV4dDtpZigibnVtYmVyIj09dHlwZW9mIHQpcmV0dXJuIHQ7dGhyb3cgbmV3IEVycm9yKGBWYWx1ZSBwYXNzZWQgdG8gJ2NzcycgZnVuY3Rpb24gbXVzdCBiZSBhICdjc3MnIGZ1bmN0aW9uIHJlc3VsdDogJHt0fS4gVXNlICd1bnNhZmVDU1MnIHRvIHBhc3Mgbm9uLWxpdGVyYWwgdmFsdWVzLCBidXRcbiAgICAgICAgICAgIHRha2UgY2FyZSB0byBlbnN1cmUgcGFnZSBzZWN1cml0eS5gKX0pKGkpK3RbbisxXSx0WzBdKTtyZXR1cm4gbmV3IHN0KGksYXQpfTsKLyoqCiAgICAgKiBAbGljZW5zZQogICAgICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KICAgICAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdAogICAgICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0CiAgICAgKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0CiAgICAgKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHQKICAgICAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdAogICAgICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHQKICAgICAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvCiAgICAgKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0CiAgICAgKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHQKICAgICAqLwood2luZG93LmxpdEVsZW1lbnRWZXJzaW9uc3x8KHdpbmRvdy5saXRFbGVtZW50VmVyc2lvbnM9W10pKS5wdXNoKCIyLjIuMSIpO2NvbnN0IGN0PXQ9PnQuZmxhdD90LmZsYXQoMS8wKTpmdW5jdGlvbiB0KGUsaT1bXSl7Zm9yKGxldCBuPTAscj1lLmxlbmd0aDtuPHI7bisrKXtjb25zdCByPWVbbl07QXJyYXkuaXNBcnJheShyKT90KHIsaSk6aS5wdXNoKHIpfXJldHVybiBpfSh0KTtjbGFzcyBsdCBleHRlbmRzIFp7c3RhdGljIGZpbmFsaXplKCl7c3VwZXIuZmluYWxpemUuY2FsbCh0aGlzKSx0aGlzLl9zdHlsZXM9dGhpcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCJzdHlsZXMiLHRoaXMpKT90aGlzLl9nZXRVbmlxdWVTdHlsZXMoKTp0aGlzLl9zdHlsZXN8fFtdfXN0YXRpYyBfZ2V0VW5pcXVlU3R5bGVzKCl7Y29uc3QgdD10aGlzLnN0eWxlcyxlPVtdO2lmKEFycmF5LmlzQXJyYXkodCkpe2N0KHQpLnJlZHVjZVJpZ2h0KCh0LGUpPT4odC5hZGQoZSksdCksbmV3IFNldCkuZm9yRWFjaCh0PT5lLnVuc2hpZnQodCkpfWVsc2UgdCYmZS5wdXNoKHQpO3JldHVybiBlfWluaXRpYWxpemUoKXtzdXBlci5pbml0aWFsaXplKCksdGhpcy5yZW5kZXJSb290PXRoaXMuY3JlYXRlUmVuZGVyUm9vdCgpLHdpbmRvdy5TaGFkb3dSb290JiZ0aGlzLnJlbmRlclJvb3QgaW5zdGFuY2VvZiB3aW5kb3cuU2hhZG93Um9vdCYmdGhpcy5hZG9wdFN0eWxlcygpfWNyZWF0ZVJlbmRlclJvb3QoKXtyZXR1cm4gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6Im9wZW4ifSl9YWRvcHRTdHlsZXMoKXtjb25zdCB0PXRoaXMuY29uc3RydWN0b3IuX3N0eWxlczswIT09dC5sZW5ndGgmJih2b2lkIDA9PT13aW5kb3cuU2hhZHlDU1N8fHdpbmRvdy5TaGFkeUNTUy5uYXRpdmVTaGFkb3c/b3Q/dGhpcy5yZW5kZXJSb290LmFkb3B0ZWRTdHlsZVNoZWV0cz10Lm1hcCh0PT50LnN0eWxlU2hlZXQpOnRoaXMuX25lZWRzU2hpbUFkb3B0ZWRTdHlsZVNoZWV0cz0hMDp3aW5kb3cuU2hhZHlDU1MuU2NvcGluZ1NoaW0ucHJlcGFyZUFkb3B0ZWRDc3NUZXh0KHQubWFwKHQ9PnQuY3NzVGV4dCksdGhpcy5sb2NhbE5hbWUpKX1jb25uZWN0ZWRDYWxsYmFjaygpe3N1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCksdGhpcy5oYXNVcGRhdGVkJiZ2b2lkIDAhPT13aW5kb3cuU2hhZHlDU1MmJndpbmRvdy5TaGFkeUNTUy5zdHlsZUVsZW1lbnQodGhpcyl9dXBkYXRlKHQpe3N1cGVyLnVwZGF0ZSh0KTtjb25zdCBlPXRoaXMucmVuZGVyKCk7ZSBpbnN0YW5jZW9mIHcmJnRoaXMuY29uc3RydWN0b3IucmVuZGVyKGUsdGhpcy5yZW5kZXJSb290LHtzY29wZU5hbWU6dGhpcy5sb2NhbE5hbWUsZXZlbnRDb250ZXh0OnRoaXN9KSx0aGlzLl9uZWVkc1NoaW1BZG9wdGVkU3R5bGVTaGVldHMmJih0aGlzLl9uZWVkc1NoaW1BZG9wdGVkU3R5bGVTaGVldHM9ITEsdGhpcy5jb25zdHJ1Y3Rvci5fc3R5bGVzLmZvckVhY2godD0+e2NvbnN0IGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic3R5bGUiKTtlLnRleHRDb250ZW50PXQuY3NzVGV4dCx0aGlzLnJlbmRlclJvb3QuYXBwZW5kQ2hpbGQoZSl9KSl9cmVuZGVyKCl7fX0KLyoqCiAgICAgKiBAbGljZW5zZQogICAgICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIEluYy4KICAgICAqCiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5CiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAiU29mdHdhcmUiKSwgdG8gZGVhbAogICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cwogICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbAogICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzCiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOgogICAgICoKICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluCiAgICAgKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS4KICAgICAqCiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgIkFTIElTIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUgogICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksCiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUKICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIKICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sCiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOCiAgICAgKiBUSEUgU09GVFdBUkUuCiAgICAgKi8KdmFyIHV0O2Z1bmN0aW9uIHB0KHQsZSl7aWYodm9pZCAwPT09dCYmKHQ9d2luZG93KSx2b2lkIDA9PT1lJiYoZT0hMSksdm9pZCAwPT09dXR8fGUpe3ZhciBpPSExO3RyeXt0LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoInRlc3QiLChmdW5jdGlvbigpe30pLHtnZXQgcGFzc2l2ZSgpe3JldHVybiBpPSEwfX0pfWNhdGNoKHQpe311dD1pfXJldHVybiEhdXQmJntwYXNzaXZlOiEwfX0KLyoqCiAgICAgKiBAbGljZW5zZQogICAgICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4KICAgICAqCiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5CiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAiU29mdHdhcmUiKSwgdG8gZGVhbAogICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cwogICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbAogICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzCiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOgogICAgICoKICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluCiAgICAgKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS4KICAgICAqCiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgIkFTIElTIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUgogICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksCiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUKICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIKICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sCiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOCiAgICAgKiBUSEUgU09GVFdBUkUuCiAgICAgKi9mdW5jdGlvbiBtdCh0LGUpe3JldHVybih0Lm1hdGNoZXN8fHQud2Via2l0TWF0Y2hlc1NlbGVjdG9yfHx0Lm1zTWF0Y2hlc1NlbGVjdG9yKS5jYWxsKHQsZSl9Ci8qKgogICAgICogQGxpY2Vuc2UKICAgICAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuCiAgICAgKgogICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weQogICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgIlNvZnR3YXJlIiksIHRvIGRlYWwKICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMKICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwKICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcwogICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczoKICAgICAqCiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbgogICAgICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuCiAgICAgKgogICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IKICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLAogICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFCiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSCiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLAogICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTgogICAgICogVEhFIFNPRlRXQVJFLgogICAgICovbHQuZmluYWxpemVkPSEwLGx0LnJlbmRlcj0odCxlLGkpPT57aWYoIWl8fCJvYmplY3QiIT10eXBlb2YgaXx8IWkuc2NvcGVOYW1lKXRocm93IG5ldyBFcnJvcigiVGhlIGBzY29wZU5hbWVgIG9wdGlvbiBpcyByZXF1aXJlZC4iKTtjb25zdCBuPWkuc2NvcGVOYW1lLHI9Ri5oYXMoZSksbz1qJiYxMT09PWUubm9kZVR5cGUmJiEhZS5ob3N0LGE9byYmIUcuaGFzKG4pLHM9YT9kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk6ZTtpZigoKHQsZSxpKT0+e2xldCBuPUYuZ2V0KGUpO3ZvaWQgMD09PW4mJihjKGUsZS5maXJzdENoaWxkKSxGLnNldChlLG49bmV3IEUoT2JqZWN0LmFzc2lnbih7dGVtcGxhdGVGYWN0b3J5OlZ9LGkpKSksbi5hcHBlbmRJbnRvKGUpKSxuLnNldFZhbHVlKHQpLG4uY29tbWl0KCl9KSh0LHMsT2JqZWN0LmFzc2lnbih7dGVtcGxhdGVGYWN0b3J5OiQobil9LGkpKSxhKXtjb25zdCB0PUYuZ2V0KHMpO0YuZGVsZXRlKHMpO2NvbnN0IGk9dC52YWx1ZSBpbnN0YW5jZW9mIHk/dC52YWx1ZS50ZW1wbGF0ZTp2b2lkIDA7VyhuLHMsaSksYyhlLGUuZmlyc3RDaGlsZCksZS5hcHBlbmRDaGlsZChzKSxGLnNldChlLHQpfSFyJiZvJiZ3aW5kb3cuU2hhZHlDU1Muc3R5bGVFbGVtZW50KGUuaG9zdCl9O3ZhciBodCxmdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dm9pZCAwPT09dCYmKHQ9e30pLHRoaXMuYWRhcHRlcl89dH1yZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsImNzc0NsYXNzZXMiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm57fX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCwic3RyaW5ncyIse2dldDpmdW5jdGlvbigpe3JldHVybnt9fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJudW1iZXJzIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJue319LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsImRlZmF1bHRBZGFwdGVyIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJue319LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbigpe30sdC5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe30sdH0oKSxfdD17QkdfRk9DVVNFRDoibWRjLXJpcHBsZS11cGdyYWRlZC0tYmFja2dyb3VuZC1mb2N1c2VkIixGR19BQ1RJVkFUSU9OOiJtZGMtcmlwcGxlLXVwZ3JhZGVkLS1mb3JlZ3JvdW5kLWFjdGl2YXRpb24iLEZHX0RFQUNUSVZBVElPTjoibWRjLXJpcHBsZS11cGdyYWRlZC0tZm9yZWdyb3VuZC1kZWFjdGl2YXRpb24iLFJPT1Q6Im1kYy1yaXBwbGUtdXBncmFkZWQiLFVOQk9VTkRFRDoibWRjLXJpcHBsZS11cGdyYWRlZC0tdW5ib3VuZGVkIn0sYnQ9e1ZBUl9GR19TQ0FMRToiLS1tZGMtcmlwcGxlLWZnLXNjYWxlIixWQVJfRkdfU0laRToiLS1tZGMtcmlwcGxlLWZnLXNpemUiLFZBUl9GR19UUkFOU0xBVEVfRU5EOiItLW1kYy1yaXBwbGUtZmctdHJhbnNsYXRlLWVuZCIsVkFSX0ZHX1RSQU5TTEFURV9TVEFSVDoiLS1tZGMtcmlwcGxlLWZnLXRyYW5zbGF0ZS1zdGFydCIsVkFSX0xFRlQ6Ii0tbWRjLXJpcHBsZS1sZWZ0IixWQVJfVE9QOiItLW1kYy1yaXBwbGUtdG9wIn0sZ3Q9e0RFQUNUSVZBVElPTl9USU1FT1VUX01TOjIyNSxGR19ERUFDVElWQVRJT05fTVM6MTUwLElOSVRJQUxfT1JJR0lOX1NDQUxFOi42LFBBRERJTkc6MTAsVEFQX0RFTEFZX01TOjMwMH07Ci8qKgogICAgICogQGxpY2Vuc2UKICAgICAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuCiAgICAgKgogICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weQogICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgIlNvZnR3YXJlIiksIHRvIGRlYWwKICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMKICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwKICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcwogICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczoKICAgICAqCiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbgogICAgICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuCiAgICAgKgogICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IKICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLAogICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFCiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSCiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLAogICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTgogICAgICogVEhFIFNPRlRXQVJFLgogICAgICovCi8qKgogICAgICogQGxpY2Vuc2UKICAgICAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuCiAgICAgKgogICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weQogICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgIlNvZnR3YXJlIiksIHRvIGRlYWwKICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMKICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwKICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcwogICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczoKICAgICAqCiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbgogICAgICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuCiAgICAgKgogICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IKICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLAogICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFCiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSCiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLAogICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTgogICAgICogVEhFIFNPRlRXQVJFLgogICAgICovCnZhciB2dD1bInRvdWNoc3RhcnQiLCJwb2ludGVyZG93biIsIm1vdXNlZG93biIsImtleWRvd24iXSx5dD1bInRvdWNoZW5kIiwicG9pbnRlcnVwIiwibW91c2V1cCIsImNvbnRleHRtZW51Il0seHQ9W10sd3Q9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShpKXt2YXIgcj10LmNhbGwodGhpcyxuKHt9LGUuZGVmYXVsdEFkYXB0ZXIsaSkpfHx0aGlzO3JldHVybiByLmFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF89ITEsci5hY3RpdmF0aW9uVGltZXJfPTAsci5mZ0RlYWN0aXZhdGlvblJlbW92YWxUaW1lcl89MCxyLmZnU2NhbGVfPSIwIixyLmZyYW1lXz17d2lkdGg6MCxoZWlnaHQ6MH0sci5pbml0aWFsU2l6ZV89MCxyLmxheW91dEZyYW1lXz0wLHIubWF4UmFkaXVzXz0wLHIudW5ib3VuZGVkQ29vcmRzXz17bGVmdDowLHRvcDowfSxyLmFjdGl2YXRpb25TdGF0ZV89ci5kZWZhdWx0QWN0aXZhdGlvblN0YXRlXygpLHIuYWN0aXZhdGlvblRpbWVyQ2FsbGJhY2tfPWZ1bmN0aW9uKCl7ci5hY3RpdmF0aW9uQW5pbWF0aW9uSGFzRW5kZWRfPSEwLHIucnVuRGVhY3RpdmF0aW9uVVhMb2dpY0lmUmVhZHlfKCl9LHIuYWN0aXZhdGVIYW5kbGVyXz1mdW5jdGlvbih0KXtyZXR1cm4gci5hY3RpdmF0ZV8odCl9LHIuZGVhY3RpdmF0ZUhhbmRsZXJfPWZ1bmN0aW9uKCl7cmV0dXJuIHIuZGVhY3RpdmF0ZV8oKX0sci5mb2N1c0hhbmRsZXJfPWZ1bmN0aW9uKCl7cmV0dXJuIHIuaGFuZGxlRm9jdXMoKX0sci5ibHVySGFuZGxlcl89ZnVuY3Rpb24oKXtyZXR1cm4gci5oYW5kbGVCbHVyKCl9LHIucmVzaXplSGFuZGxlcl89ZnVuY3Rpb24oKXtyZXR1cm4gci5sYXlvdXQoKX0scn1yZXR1cm4gaShlLHQpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJjc3NDbGFzc2VzIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIF90fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJzdHJpbmdzIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGJ0fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJudW1iZXJzIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGd0fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWZhdWx0QWRhcHRlciIse2dldDpmdW5jdGlvbigpe3JldHVybnthZGRDbGFzczpmdW5jdGlvbigpe30sYnJvd3NlclN1cHBvcnRzQ3NzVmFyczpmdW5jdGlvbigpe3JldHVybiEwfSxjb21wdXRlQm91bmRpbmdSZWN0OmZ1bmN0aW9uKCl7cmV0dXJue3RvcDowLHJpZ2h0OjAsYm90dG9tOjAsbGVmdDowLHdpZHRoOjAsaGVpZ2h0OjB9fSxjb250YWluc0V2ZW50VGFyZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuITB9LGRlcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcjpmdW5jdGlvbigpe30sZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjpmdW5jdGlvbigpe30sZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6ZnVuY3Rpb24oKXt9LGdldFdpbmRvd1BhZ2VPZmZzZXQ6ZnVuY3Rpb24oKXtyZXR1cm57eDowLHk6MH19LGlzU3VyZmFjZUFjdGl2ZTpmdW5jdGlvbigpe3JldHVybiEwfSxpc1N1cmZhY2VEaXNhYmxlZDpmdW5jdGlvbigpe3JldHVybiEwfSxpc1VuYm91bmRlZDpmdW5jdGlvbigpe3JldHVybiEwfSxyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyOmZ1bmN0aW9uKCl7fSxyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjpmdW5jdGlvbigpe30scmVnaXN0ZXJSZXNpemVIYW5kbGVyOmZ1bmN0aW9uKCl7fSxyZW1vdmVDbGFzczpmdW5jdGlvbigpe30sdXBkYXRlQ3NzVmFyaWFibGU6ZnVuY3Rpb24oKXt9fX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxlLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxpPXRoaXMuc3VwcG9ydHNQcmVzc1JpcHBsZV8oKTtpZih0aGlzLnJlZ2lzdGVyUm9vdEhhbmRsZXJzXyhpKSxpKXt2YXIgbj1lLmNzc0NsYXNzZXMscj1uLlJPT1Qsbz1uLlVOQk9VTkRFRDtyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKGZ1bmN0aW9uKCl7dC5hZGFwdGVyXy5hZGRDbGFzcyhyKSx0LmFkYXB0ZXJfLmlzVW5ib3VuZGVkKCkmJih0LmFkYXB0ZXJfLmFkZENsYXNzKG8pLHQubGF5b3V0SW50ZXJuYWxfKCkpfSkpfX0sZS5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3ZhciB0PXRoaXM7aWYodGhpcy5zdXBwb3J0c1ByZXNzUmlwcGxlXygpKXt0aGlzLmFjdGl2YXRpb25UaW1lcl8mJihjbGVhclRpbWVvdXQodGhpcy5hY3RpdmF0aW9uVGltZXJfKSx0aGlzLmFjdGl2YXRpb25UaW1lcl89MCx0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGUuY3NzQ2xhc3Nlcy5GR19BQ1RJVkFUSU9OKSksdGhpcy5mZ0RlYWN0aXZhdGlvblJlbW92YWxUaW1lcl8mJihjbGVhclRpbWVvdXQodGhpcy5mZ0RlYWN0aXZhdGlvblJlbW92YWxUaW1lcl8pLHRoaXMuZmdEZWFjdGl2YXRpb25SZW1vdmFsVGltZXJfPTAsdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhlLmNzc0NsYXNzZXMuRkdfREVBQ1RJVkFUSU9OKSk7dmFyIGk9ZS5jc3NDbGFzc2VzLG49aS5ST09ULHI9aS5VTkJPVU5ERUQ7cmVxdWVzdEFuaW1hdGlvbkZyYW1lKChmdW5jdGlvbigpe3QuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MobiksdC5hZGFwdGVyXy5yZW1vdmVDbGFzcyhyKSx0LnJlbW92ZUNzc1ZhcnNfKCl9KSl9dGhpcy5kZXJlZ2lzdGVyUm9vdEhhbmRsZXJzXygpLHRoaXMuZGVyZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXygpfSxlLnByb3RvdHlwZS5hY3RpdmF0ZT1mdW5jdGlvbih0KXt0aGlzLmFjdGl2YXRlXyh0KX0sZS5wcm90b3R5cGUuZGVhY3RpdmF0ZT1mdW5jdGlvbigpe3RoaXMuZGVhY3RpdmF0ZV8oKX0sZS5wcm90b3R5cGUubGF5b3V0PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLmxheW91dEZyYW1lXyYmY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5sYXlvdXRGcmFtZV8pLHRoaXMubGF5b3V0RnJhbWVfPXJlcXVlc3RBbmltYXRpb25GcmFtZSgoZnVuY3Rpb24oKXt0LmxheW91dEludGVybmFsXygpLHQubGF5b3V0RnJhbWVfPTB9KSl9LGUucHJvdG90eXBlLnNldFVuYm91bmRlZD1mdW5jdGlvbih0KXt2YXIgaT1lLmNzc0NsYXNzZXMuVU5CT1VOREVEO3Q/dGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhpKTp0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGkpfSxlLnByb3RvdHlwZS5oYW5kbGVGb2N1cz1mdW5jdGlvbigpe3ZhciB0PXRoaXM7cmVxdWVzdEFuaW1hdGlvbkZyYW1lKChmdW5jdGlvbigpe3JldHVybiB0LmFkYXB0ZXJfLmFkZENsYXNzKGUuY3NzQ2xhc3Nlcy5CR19GT0NVU0VEKX0pKX0sZS5wcm90b3R5cGUuaGFuZGxlQmx1cj1mdW5jdGlvbigpe3ZhciB0PXRoaXM7cmVxdWVzdEFuaW1hdGlvbkZyYW1lKChmdW5jdGlvbigpe3JldHVybiB0LmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGUuY3NzQ2xhc3Nlcy5CR19GT0NVU0VEKX0pKX0sZS5wcm90b3R5cGUuc3VwcG9ydHNQcmVzc1JpcHBsZV89ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hZGFwdGVyXy5icm93c2VyU3VwcG9ydHNDc3NWYXJzKCl9LGUucHJvdG90eXBlLmRlZmF1bHRBY3RpdmF0aW9uU3RhdGVfPWZ1bmN0aW9uKCl7cmV0dXJue2FjdGl2YXRpb25FdmVudDp2b2lkIDAsaGFzRGVhY3RpdmF0aW9uVVhSdW46ITEsaXNBY3RpdmF0ZWQ6ITEsaXNQcm9ncmFtbWF0aWM6ITEsd2FzQWN0aXZhdGVkQnlQb2ludGVyOiExLHdhc0VsZW1lbnRNYWRlQWN0aXZlOiExfX0sZS5wcm90b3R5cGUucmVnaXN0ZXJSb290SGFuZGxlcnNfPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7dCYmKHZ0LmZvckVhY2goKGZ1bmN0aW9uKHQpe2UuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIodCxlLmFjdGl2YXRlSGFuZGxlcl8pfSkpLHRoaXMuYWRhcHRlcl8uaXNVbmJvdW5kZWQoKSYmdGhpcy5hZGFwdGVyXy5yZWdpc3RlclJlc2l6ZUhhbmRsZXIodGhpcy5yZXNpemVIYW5kbGVyXykpLHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoImZvY3VzIix0aGlzLmZvY3VzSGFuZGxlcl8pLHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoImJsdXIiLHRoaXMuYmx1ckhhbmRsZXJfKX0sZS5wcm90b3R5cGUucmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVyc189ZnVuY3Rpb24odCl7dmFyIGU9dGhpczsia2V5ZG93biI9PT10LnR5cGU/dGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigia2V5dXAiLHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXJfKTp5dC5mb3JFYWNoKChmdW5jdGlvbih0KXtlLmFkYXB0ZXJfLnJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXIodCxlLmRlYWN0aXZhdGVIYW5kbGVyXyl9KSl9LGUucHJvdG90eXBlLmRlcmVnaXN0ZXJSb290SGFuZGxlcnNfPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt2dC5mb3JFYWNoKChmdW5jdGlvbihlKXt0LmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZSx0LmFjdGl2YXRlSGFuZGxlcl8pfSkpLHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigiZm9jdXMiLHRoaXMuZm9jdXNIYW5kbGVyXyksdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCJibHVyIix0aGlzLmJsdXJIYW5kbGVyXyksdGhpcy5hZGFwdGVyXy5pc1VuYm91bmRlZCgpJiZ0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pfSxlLnByb3RvdHlwZS5kZXJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoImtleXVwIix0aGlzLmRlYWN0aXZhdGVIYW5kbGVyXykseXQuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dC5hZGFwdGVyXy5kZXJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXIoZSx0LmRlYWN0aXZhdGVIYW5kbGVyXyl9KSl9LGUucHJvdG90eXBlLnJlbW92ZUNzc1ZhcnNfPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxpPWUuc3RyaW5ncztPYmplY3Qua2V5cyhpKS5mb3JFYWNoKChmdW5jdGlvbihlKXswPT09ZS5pbmRleE9mKCJWQVJfIikmJnQuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoaVtlXSxudWxsKX0pKX0sZS5wcm90b3R5cGUuYWN0aXZhdGVfPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7aWYoIXRoaXMuYWRhcHRlcl8uaXNTdXJmYWNlRGlzYWJsZWQoKSl7dmFyIGk9dGhpcy5hY3RpdmF0aW9uU3RhdGVfO2lmKCFpLmlzQWN0aXZhdGVkKXt2YXIgbj10aGlzLnByZXZpb3VzQWN0aXZhdGlvbkV2ZW50XztpZighKG4mJnZvaWQgMCE9PXQmJm4udHlwZSE9PXQudHlwZSkpaS5pc0FjdGl2YXRlZD0hMCxpLmlzUHJvZ3JhbW1hdGljPXZvaWQgMD09PXQsaS5hY3RpdmF0aW9uRXZlbnQ9dCxpLndhc0FjdGl2YXRlZEJ5UG9pbnRlcj0haS5pc1Byb2dyYW1tYXRpYyYmKHZvaWQgMCE9PXQmJigibW91c2Vkb3duIj09PXQudHlwZXx8InRvdWNoc3RhcnQiPT09dC50eXBlfHwicG9pbnRlcmRvd24iPT09dC50eXBlKSksdm9pZCAwIT09dCYmeHQubGVuZ3RoPjAmJnh0LnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiBlLmFkYXB0ZXJfLmNvbnRhaW5zRXZlbnRUYXJnZXQodCl9KSk/dGhpcy5yZXNldEFjdGl2YXRpb25TdGF0ZV8oKToodm9pZCAwIT09dCYmKHh0LnB1c2godC50YXJnZXQpLHRoaXMucmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVyc18odCkpLGkud2FzRWxlbWVudE1hZGVBY3RpdmU9dGhpcy5jaGVja0VsZW1lbnRNYWRlQWN0aXZlXyh0KSxpLndhc0VsZW1lbnRNYWRlQWN0aXZlJiZ0aGlzLmFuaW1hdGVBY3RpdmF0aW9uXygpLHJlcXVlc3RBbmltYXRpb25GcmFtZSgoZnVuY3Rpb24oKXt4dD1bXSxpLndhc0VsZW1lbnRNYWRlQWN0aXZlfHx2b2lkIDA9PT10fHwiICIhPT10LmtleSYmMzIhPT10LmtleUNvZGV8fChpLndhc0VsZW1lbnRNYWRlQWN0aXZlPWUuY2hlY2tFbGVtZW50TWFkZUFjdGl2ZV8odCksaS53YXNFbGVtZW50TWFkZUFjdGl2ZSYmZS5hbmltYXRlQWN0aXZhdGlvbl8oKSksaS53YXNFbGVtZW50TWFkZUFjdGl2ZXx8KGUuYWN0aXZhdGlvblN0YXRlXz1lLmRlZmF1bHRBY3RpdmF0aW9uU3RhdGVfKCkpfSkpKX19fSxlLnByb3RvdHlwZS5jaGVja0VsZW1lbnRNYWRlQWN0aXZlXz1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dHx8ImtleWRvd24iIT09dC50eXBlfHx0aGlzLmFkYXB0ZXJfLmlzU3VyZmFjZUFjdGl2ZSgpfSxlLnByb3RvdHlwZS5hbmltYXRlQWN0aXZhdGlvbl89ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGk9ZS5zdHJpbmdzLG49aS5WQVJfRkdfVFJBTlNMQVRFX1NUQVJULHI9aS5WQVJfRkdfVFJBTlNMQVRFX0VORCxvPWUuY3NzQ2xhc3NlcyxhPW8uRkdfREVBQ1RJVkFUSU9OLHM9by5GR19BQ1RJVkFUSU9OLGQ9ZS5udW1iZXJzLkRFQUNUSVZBVElPTl9USU1FT1VUX01TO3RoaXMubGF5b3V0SW50ZXJuYWxfKCk7dmFyIGM9IiIsbD0iIjtpZighdGhpcy5hZGFwdGVyXy5pc1VuYm91bmRlZCgpKXt2YXIgdT10aGlzLmdldEZnVHJhbnNsYXRpb25Db29yZGluYXRlc18oKSxwPXUuc3RhcnRQb2ludCxtPXUuZW5kUG9pbnQ7Yz1wLngrInB4LCAiK3AueSsicHgiLGw9bS54KyJweCwgIittLnkrInB4In10aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKG4sYyksdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShyLGwpLGNsZWFyVGltZW91dCh0aGlzLmFjdGl2YXRpb25UaW1lcl8pLGNsZWFyVGltZW91dCh0aGlzLmZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyXyksdGhpcy5ybUJvdW5kZWRBY3RpdmF0aW9uQ2xhc3Nlc18oKSx0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGEpLHRoaXMuYWRhcHRlcl8uY29tcHV0ZUJvdW5kaW5nUmVjdCgpLHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MocyksdGhpcy5hY3RpdmF0aW9uVGltZXJfPXNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYWN0aXZhdGlvblRpbWVyQ2FsbGJhY2tfKCl9KSxkKX0sZS5wcm90b3R5cGUuZ2V0RmdUcmFuc2xhdGlvbkNvb3JkaW5hdGVzXz1mdW5jdGlvbigpe3ZhciB0LGU9dGhpcy5hY3RpdmF0aW9uU3RhdGVfLGk9ZS5hY3RpdmF0aW9uRXZlbnQ7cmV0dXJue3N0YXJ0UG9pbnQ6dD17eDoodD1lLndhc0FjdGl2YXRlZEJ5UG9pbnRlcj9mdW5jdGlvbih0LGUsaSl7aWYoIXQpcmV0dXJue3g6MCx5OjB9O3ZhciBuLHIsbz1lLngsYT1lLnkscz1vK2kubGVmdCxkPWEraS50b3A7aWYoInRvdWNoc3RhcnQiPT09dC50eXBlKXt2YXIgYz10O249Yy5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWC1zLHI9Yy5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWS1kfWVsc2V7dmFyIGw9dDtuPWwucGFnZVgtcyxyPWwucGFnZVktZH1yZXR1cm57eDpuLHk6cn19KGksdGhpcy5hZGFwdGVyXy5nZXRXaW5kb3dQYWdlT2Zmc2V0KCksdGhpcy5hZGFwdGVyXy5jb21wdXRlQm91bmRpbmdSZWN0KCkpOnt4OnRoaXMuZnJhbWVfLndpZHRoLzIseTp0aGlzLmZyYW1lXy5oZWlnaHQvMn0pLngtdGhpcy5pbml0aWFsU2l6ZV8vMix5OnQueS10aGlzLmluaXRpYWxTaXplXy8yfSxlbmRQb2ludDp7eDp0aGlzLmZyYW1lXy53aWR0aC8yLXRoaXMuaW5pdGlhbFNpemVfLzIseTp0aGlzLmZyYW1lXy5oZWlnaHQvMi10aGlzLmluaXRpYWxTaXplXy8yfX19LGUucHJvdG90eXBlLnJ1bkRlYWN0aXZhdGlvblVYTG9naWNJZlJlYWR5Xz1mdW5jdGlvbigpe3ZhciB0PXRoaXMsaT1lLmNzc0NsYXNzZXMuRkdfREVBQ1RJVkFUSU9OLG49dGhpcy5hY3RpdmF0aW9uU3RhdGVfLHI9bi5oYXNEZWFjdGl2YXRpb25VWFJ1bixvPW4uaXNBY3RpdmF0ZWQ7KHJ8fCFvKSYmdGhpcy5hY3RpdmF0aW9uQW5pbWF0aW9uSGFzRW5kZWRfJiYodGhpcy5ybUJvdW5kZWRBY3RpdmF0aW9uQ2xhc3Nlc18oKSx0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGkpLHRoaXMuZmdEZWFjdGl2YXRpb25SZW1vdmFsVGltZXJfPXNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7dC5hZGFwdGVyXy5yZW1vdmVDbGFzcyhpKX0pLGd0LkZHX0RFQUNUSVZBVElPTl9NUykpfSxlLnByb3RvdHlwZS5ybUJvdW5kZWRBY3RpdmF0aW9uQ2xhc3Nlc189ZnVuY3Rpb24oKXt2YXIgdD1lLmNzc0NsYXNzZXMuRkdfQUNUSVZBVElPTjt0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKHQpLHRoaXMuYWN0aXZhdGlvbkFuaW1hdGlvbkhhc0VuZGVkXz0hMSx0aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKX0sZS5wcm90b3R5cGUucmVzZXRBY3RpdmF0aW9uU3RhdGVfPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLnByZXZpb3VzQWN0aXZhdGlvbkV2ZW50Xz10aGlzLmFjdGl2YXRpb25TdGF0ZV8uYWN0aXZhdGlvbkV2ZW50LHRoaXMuYWN0aXZhdGlvblN0YXRlXz10aGlzLmRlZmF1bHRBY3RpdmF0aW9uU3RhdGVfKCksc2V0VGltZW91dCgoZnVuY3Rpb24oKXtyZXR1cm4gdC5wcmV2aW91c0FjdGl2YXRpb25FdmVudF89dm9pZCAwfSksZS5udW1iZXJzLlRBUF9ERUxBWV9NUyl9LGUucHJvdG90eXBlLmRlYWN0aXZhdGVfPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXRoaXMuYWN0aXZhdGlvblN0YXRlXztpZihlLmlzQWN0aXZhdGVkKXt2YXIgaT1uKHt9LGUpO2UuaXNQcm9ncmFtbWF0aWM/KHJlcXVlc3RBbmltYXRpb25GcmFtZSgoZnVuY3Rpb24oKXtyZXR1cm4gdC5hbmltYXRlRGVhY3RpdmF0aW9uXyhpKX0pKSx0aGlzLnJlc2V0QWN0aXZhdGlvblN0YXRlXygpKToodGhpcy5kZXJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfKCkscmVxdWVzdEFuaW1hdGlvbkZyYW1lKChmdW5jdGlvbigpe3QuYWN0aXZhdGlvblN0YXRlXy5oYXNEZWFjdGl2YXRpb25VWFJ1bj0hMCx0LmFuaW1hdGVEZWFjdGl2YXRpb25fKGkpLHQucmVzZXRBY3RpdmF0aW9uU3RhdGVfKCl9KSkpfX0sZS5wcm90b3R5cGUuYW5pbWF0ZURlYWN0aXZhdGlvbl89ZnVuY3Rpb24odCl7dmFyIGU9dC53YXNBY3RpdmF0ZWRCeVBvaW50ZXIsaT10Lndhc0VsZW1lbnRNYWRlQWN0aXZlOyhlfHxpKSYmdGhpcy5ydW5EZWFjdGl2YXRpb25VWExvZ2ljSWZSZWFkeV8oKX0sZS5wcm90b3R5cGUubGF5b3V0SW50ZXJuYWxfPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLmZyYW1lXz10aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKTt2YXIgaT1NYXRoLm1heCh0aGlzLmZyYW1lXy5oZWlnaHQsdGhpcy5mcmFtZV8ud2lkdGgpO3RoaXMubWF4UmFkaXVzXz10aGlzLmFkYXB0ZXJfLmlzVW5ib3VuZGVkKCk/aTpNYXRoLnNxcnQoTWF0aC5wb3codC5mcmFtZV8ud2lkdGgsMikrTWF0aC5wb3codC5mcmFtZV8uaGVpZ2h0LDIpKStlLm51bWJlcnMuUEFERElORzt2YXIgbj1NYXRoLmZsb29yKGkqZS5udW1iZXJzLklOSVRJQUxfT1JJR0lOX1NDQUxFKTt0aGlzLmFkYXB0ZXJfLmlzVW5ib3VuZGVkKCkmJm4lMiE9MD90aGlzLmluaXRpYWxTaXplXz1uLTE6dGhpcy5pbml0aWFsU2l6ZV89bix0aGlzLmZnU2NhbGVfPSIiK3RoaXMubWF4UmFkaXVzXy90aGlzLmluaXRpYWxTaXplXyx0aGlzLnVwZGF0ZUxheW91dENzc1ZhcnNfKCl9LGUucHJvdG90eXBlLnVwZGF0ZUxheW91dENzc1ZhcnNfPWZ1bmN0aW9uKCl7dmFyIHQ9ZS5zdHJpbmdzLGk9dC5WQVJfRkdfU0laRSxuPXQuVkFSX0xFRlQscj10LlZBUl9UT1Asbz10LlZBUl9GR19TQ0FMRTt0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKGksdGhpcy5pbml0aWFsU2l6ZV8rInB4IiksdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShvLHRoaXMuZmdTY2FsZV8pLHRoaXMuYWRhcHRlcl8uaXNVbmJvdW5kZWQoKSYmKHRoaXMudW5ib3VuZGVkQ29vcmRzXz17bGVmdDpNYXRoLnJvdW5kKHRoaXMuZnJhbWVfLndpZHRoLzItdGhpcy5pbml0aWFsU2l6ZV8vMiksdG9wOk1hdGgucm91bmQodGhpcy5mcmFtZV8uaGVpZ2h0LzItdGhpcy5pbml0aWFsU2l6ZV8vMil9LHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUobix0aGlzLnVuYm91bmRlZENvb3Jkc18ubGVmdCsicHgiKSx0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKHIsdGhpcy51bmJvdW5kZWRDb29yZHNfLnRvcCsicHgiKSl9LGV9KGZ0KTsKLyoqCiAgICBAbGljZW5zZQogICAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC4KCiAgICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKICAgIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4KICAgIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdAoKICAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKCiAgICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCiAgICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAiQVMgSVMiIEJBU0lTLAogICAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuCiAgICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCiAgICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4KICAgICovCmNvbnN0IFN0PWR0YEBrZXlmcmFtZXMgbWRjLXJpcHBsZS1mZy1yYWRpdXMtaW57ZnJvbXthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7dHJhbnNmb3JtOnRyYW5zbGF0ZSh2YXIoLS1tZGMtcmlwcGxlLWZnLXRyYW5zbGF0ZS1zdGFydCwgMCkpIHNjYWxlKDEpfXRve3RyYW5zZm9ybTp0cmFuc2xhdGUodmFyKC0tbWRjLXJpcHBsZS1mZy10cmFuc2xhdGUtZW5kLCAwKSkgc2NhbGUodmFyKC0tbWRjLXJpcHBsZS1mZy1zY2FsZSwgMSkpfX1Aa2V5ZnJhbWVzIG1kYy1yaXBwbGUtZmctb3BhY2l0eS1pbntmcm9te2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246bGluZWFyO29wYWNpdHk6MH10b3tvcGFjaXR5OnZhcigtLW1kYy1yaXBwbGUtZmctb3BhY2l0eSwgMCl9fUBrZXlmcmFtZXMgbWRjLXJpcHBsZS1mZy1vcGFjaXR5LW91dHtmcm9te2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246bGluZWFyO29wYWNpdHk6dmFyKC0tbWRjLXJpcHBsZS1mZy1vcGFjaXR5LCAwKX10b3tvcGFjaXR5OjB9fWAKLyoqCiAgICBAbGljZW5zZQogICAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC4KCiAgICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKICAgIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4KICAgIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdAoKICAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKCiAgICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCiAgICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAiQVMgSVMiIEJBU0lTLAogICAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuCiAgICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCiAgICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4KICAgICovLEF0PWZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9ITEpO3ZhciBpLG49dC5DU1M7aWYoImJvb2xlYW4iPT10eXBlb2YgaHQmJiFlKXJldHVybiBodDtpZighKG4mJiJmdW5jdGlvbiI9PXR5cGVvZiBuLnN1cHBvcnRzKSlyZXR1cm4hMTt2YXIgcj1uLnN1cHBvcnRzKCItLWNzcy12YXJzIiwieWVzIiksbz1uLnN1cHBvcnRzKCIoLS1jc3MtdmFyczogeWVzKSIpJiZuLnN1cHBvcnRzKCJjb2xvciIsIiMwMDAwMDAwMCIpO3JldHVybiBpPXJ8fG8sZXx8KGh0PWkpLGl9KHdpbmRvdyksQ3Q9bmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvU2FmYXJpLyk7bGV0IGt0PSExO2NvbnN0IEV0PXQ9PntDdCYmIWt0JiYoKCk9PntrdD0hMDtjb25zdCB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInN0eWxlIiksZT1uZXcgRSh7dGVtcGxhdGVGYWN0b3J5OlZ9KTtlLmFwcGVuZEludG8odCksZS5zZXRWYWx1ZShTdCksZS5jb21taXQoKSxkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHQpfSkoKTtjb25zdCBlPXQuc3VyZmFjZU5vZGUsaT10LmludGVyYWN0aW9uTm9kZXx8ZTtpLmdldFJvb3ROb2RlKCkhPT1lLmdldFJvb3ROb2RlKCkmJiIiPT09aS5zdHlsZS5wb3NpdGlvbiYmKGkuc3R5bGUucG9zaXRpb249InJlbGF0aXZlIik7Y29uc3Qgbj1uZXcgd3Qoe2Jyb3dzZXJTdXBwb3J0c0Nzc1ZhcnM6KCk9PkF0LGlzVW5ib3VuZGVkOigpPT52b2lkIDA9PT10LnVuYm91bmRlZHx8dC51bmJvdW5kZWQsaXNTdXJmYWNlQWN0aXZlOigpPT5tdChpLCI6YWN0aXZlIiksaXNTdXJmYWNlRGlzYWJsZWQ6KCk9PkJvb2xlYW4oaS5oYXNBdHRyaWJ1dGUoImRpc2FibGVkIikpLGFkZENsYXNzOnQ9PmUuY2xhc3NMaXN0LmFkZCh0KSxyZW1vdmVDbGFzczp0PT5lLmNsYXNzTGlzdC5yZW1vdmUodCksY29udGFpbnNFdmVudFRhcmdldDp0PT5pLmNvbnRhaW5zKHQpLHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOih0LGUpPT5pLmFkZEV2ZW50TGlzdGVuZXIodCxlLHB0KCkpLGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6KHQsZSk9PmkucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LGUscHQoKSkscmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcjoodCxlKT0+ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodCxlLHB0KCkpLGRlcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcjoodCxlKT0+ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodCxlLHB0KCkpLHJlZ2lzdGVyUmVzaXplSGFuZGxlcjp0PT53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigicmVzaXplIix0KSxkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjp0PT53aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigicmVzaXplIix0KSx1cGRhdGVDc3NWYXJpYWJsZToodCxpKT0+ZS5zdHlsZS5zZXRQcm9wZXJ0eSh0LGkpLGNvbXB1dGVCb3VuZGluZ1JlY3Q6KCk9PmUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksZ2V0V2luZG93UGFnZU9mZnNldDooKT0+KHt4OndpbmRvdy5wYWdlWE9mZnNldCx5OndpbmRvdy5wYWdlWU9mZnNldH0pfSk7cmV0dXJuIG4uaW5pdCgpLG59LFR0PW5ldyBXZWFrTWFwLEl0PWEoKHQ9e30pPT5lPT57Y29uc3QgaT1lLmNvbW1pdHRlci5lbGVtZW50LG49dC5pbnRlcmFjdGlvbk5vZGV8fGk7bGV0IHI9ZS52YWx1ZTtjb25zdCBvPVR0LmdldChyKTt2b2lkIDAhPT1vJiZvIT09biYmKHIuZGVzdHJveSgpLHI9bCkscj09PWw/KHI9RXQoT2JqZWN0LmFzc2lnbih7fSx0LHtzdXJmYWNlTm9kZTppfSkpLFR0LnNldChyLG4pLGUuc2V0VmFsdWUocikpOih2b2lkIDAhPT10LnVuYm91bmRlZCYmci5zZXRVbmJvdW5kZWQodC51bmJvdW5kZWQpLHZvaWQgMCE9PXQuZGlzYWJsZWQmJnIuc2V0VW5ib3VuZGVkKHQuZGlzYWJsZWQpKSwhMD09PXQuYWN0aXZlP3IuYWN0aXZhdGUoKTohMT09PXQuYWN0aXZlJiZyLmRlYWN0aXZhdGUoKX0pLFJ0PW5ldyBXZWFrTWFwLFB0PWEodD0+ZT0+e2lmKCEoZSBpbnN0YW5jZW9mIGspfHxlIGluc3RhbmNlb2YgUnx8ImNsYXNzIiE9PWUuY29tbWl0dGVyLm5hbWV8fGUuY29tbWl0dGVyLnBhcnRzLmxlbmd0aD4xKXRocm93IG5ldyBFcnJvcigiVGhlIGBjbGFzc01hcGAgZGlyZWN0aXZlIG11c3QgYmUgdXNlZCBpbiB0aGUgYGNsYXNzYCBhdHRyaWJ1dGUgYW5kIG11c3QgYmUgdGhlIG9ubHkgcGFydCBpbiB0aGUgYXR0cmlidXRlLiIpO2NvbnN0e2NvbW1pdHRlcjppfT1lLHtlbGVtZW50Om59PWk7UnQuaGFzKGUpfHwobi5jbGFzc05hbWU9aS5zdHJpbmdzLmpvaW4oIiAiKSk7Y29uc3R7Y2xhc3NMaXN0OnJ9PW4sbz1SdC5nZXQoZSk7Zm9yKGNvbnN0IGUgaW4gbyllIGluIHR8fHIucmVtb3ZlKGUpO2Zvcihjb25zdCBlIGluIHQpe2NvbnN0IGk9dFtlXTtpZighb3x8aSE9PW9bZV0pe3JbaT8iYWRkIjoicmVtb3ZlIl0oZSl9fVJ0LnNldChlLHQpfSk7Y2xhc3MgTnQgZXh0ZW5kcyBsdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5yYWlzZWQ9ITEsdGhpcy51bmVsZXZhdGVkPSExLHRoaXMub3V0bGluZWQ9ITEsdGhpcy5kZW5zZT0hMSx0aGlzLmRpc2FibGVkPSExLHRoaXMudHJhaWxpbmdJY29uPSExLHRoaXMuaWNvbj0iIix0aGlzLmxhYmVsPSIifWNyZWF0ZVJlbmRlclJvb3QoKXtyZXR1cm4gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6Im9wZW4iLGRlbGVnYXRlc0ZvY3VzOiEwfSl9Zm9jdXMoKXtjb25zdCB0PXRoaXMuYnV0dG9uRWxlbWVudDtpZih0KXtjb25zdCBlPXQucmlwcGxlO2UmJmUuaGFuZGxlRm9jdXMoKSx0LmZvY3VzKCl9fWJsdXIoKXtjb25zdCB0PXRoaXMuYnV0dG9uRWxlbWVudDtpZih0KXtjb25zdCBlPXQucmlwcGxlO2UmJmUuaGFuZGxlQmx1cigpLHQuYmx1cigpfX1yZW5kZXIoKXtjb25zdCB0PXsibWRjLWJ1dHRvbi0tcmFpc2VkIjp0aGlzLnJhaXNlZCwibWRjLWJ1dHRvbi0tdW5lbGV2YXRlZCI6dGhpcy51bmVsZXZhdGVkLCJtZGMtYnV0dG9uLS1vdXRsaW5lZCI6dGhpcy5vdXRsaW5lZCwibWRjLWJ1dHRvbi0tZGVuc2UiOnRoaXMuZGVuc2V9LGU9TWA8c3BhbiBjbGFzcz0ibWF0ZXJpYWwtaWNvbnMgbWRjLWJ1dHRvbl9faWNvbiI+JHt0aGlzLmljb259PC9zcGFuPmAsaT1JdCh7dW5ib3VuZGVkOiExfSk7cmV0dXJuIE1gCiAgICAgIDxidXR0b24KICAgICAgICAgIGlkPSJidXR0b24iCiAgICAgICAgICAucmlwcGxlPSIke2l9IgogICAgICAgICAgY2xhc3M9Im1kYy1idXR0b24gJHtQdCh0KX0iCiAgICAgICAgICA/ZGlzYWJsZWQ9IiR7dGhpcy5kaXNhYmxlZH0iCiAgICAgICAgICBhcmlhLWxhYmVsPSIke3RoaXMubGFiZWx8fHRoaXMuaWNvbn0iPgogICAgICAgIDxkaXYgY2xhc3M9Im1kYy1idXR0b25fX3JpcHBsZSI+PC9kaXY+CiAgICAgICAgJHt0aGlzLmljb24mJiF0aGlzLnRyYWlsaW5nSWNvbj9lOiIifQogICAgICAgIDxzcGFuIGNsYXNzPSJtZGMtYnV0dG9uX19sYWJlbCI+JHt0aGlzLmxhYmVsfTwvc3Bhbj4KICAgICAgICAke3RoaXMuaWNvbiYmdGhpcy50cmFpbGluZ0ljb24/ZToiIn0KICAgICAgICA8c2xvdD48L3Nsb3Q+CiAgICAgIDwvYnV0dG9uPmB9fXIoW2V0KHt0eXBlOkJvb2xlYW59KV0sTnQucHJvdG90eXBlLCJyYWlzZWQiLHZvaWQgMCkscihbZXQoe3R5cGU6Qm9vbGVhbn0pXSxOdC5wcm90b3R5cGUsInVuZWxldmF0ZWQiLHZvaWQgMCkscihbZXQoe3R5cGU6Qm9vbGVhbn0pXSxOdC5wcm90b3R5cGUsIm91dGxpbmVkIix2b2lkIDApLHIoW2V0KHt0eXBlOkJvb2xlYW59KV0sTnQucHJvdG90eXBlLCJkZW5zZSIsdm9pZCAwKSxyKFtldCh7dHlwZTpCb29sZWFuLHJlZmxlY3Q6ITB9KV0sTnQucHJvdG90eXBlLCJkaXNhYmxlZCIsdm9pZCAwKSxyKFtldCh7dHlwZTpCb29sZWFufSldLE50LnByb3RvdHlwZSwidHJhaWxpbmdJY29uIix2b2lkIDApLHIoW2V0KCldLE50LnByb3RvdHlwZSwiaWNvbiIsdm9pZCAwKSxyKFtldCgpXSxOdC5wcm90b3R5cGUsImxhYmVsIix2b2lkIDApLHIoW2l0KCIjYnV0dG9uIildLE50LnByb3RvdHlwZSwiYnV0dG9uRWxlbWVudCIsdm9pZCAwKTsKLyoqCiAgICBAbGljZW5zZQogICAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC4KCiAgICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKICAgIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4KICAgIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdAoKICAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKCiAgICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCiAgICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAiQVMgSVMiIEJBU0lTLAogICAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuCiAgICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCiAgICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4KICAgICovCmNvbnN0IE90PWR0YC5tZGMtdG91Y2gtdGFyZ2V0LXdyYXBwZXJ7ZGlzcGxheTppbmxpbmV9Lm1kYy1lbGV2YXRpb24tb3ZlcmxheXtwb3NpdGlvbjphYnNvbHV0ZTtib3JkZXItcmFkaXVzOmluaGVyaXQ7b3BhY2l0eTowO3BvaW50ZXItZXZlbnRzOm5vbmU7dHJhbnNpdGlvbjpvcGFjaXR5IDI4MG1zIGN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7YmFja2dyb3VuZC1jb2xvcjojZmZmfS5tZGMtYnV0dG9ue2ZvbnQtZmFtaWx5OlJvYm90bywgc2Fucy1zZXJpZjstbW96LW9zeC1mb250LXNtb290aGluZzpncmF5c2NhbGU7LXdlYmtpdC1mb250LXNtb290aGluZzphbnRpYWxpYXNlZDtmb250LXNpemU6Ljg3NXJlbTtsaW5lLWhlaWdodDoyLjI1cmVtO2ZvbnQtd2VpZ2h0OjUwMDtsZXR0ZXItc3BhY2luZzouMDg5Mjg1NzE0M2VtO3RleHQtZGVjb3JhdGlvbjpub25lO3RleHQtdHJhbnNmb3JtOnVwcGVyY2FzZTtwYWRkaW5nOjAgOHB4IDAgOHB4O3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6aW5saW5lLWZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7Ym94LXNpemluZzpib3JkZXItYm94O21pbi13aWR0aDo2NHB4O2JvcmRlcjpub25lO291dGxpbmU6bm9uZTtsaW5lLWhlaWdodDppbmhlcml0O3VzZXItc2VsZWN0Om5vbmU7LXdlYmtpdC1hcHBlYXJhbmNlOm5vbmU7b3ZlcmZsb3c6dmlzaWJsZTt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7Ym9yZGVyLXJhZGl1czo0cHh9Lm1kYy1idXR0b24gLm1kYy1lbGV2YXRpb24tb3ZlcmxheXt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO3RvcDowO2xlZnQ6MH0ubWRjLWJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lcntwYWRkaW5nOjA7Ym9yZGVyOjB9Lm1kYy1idXR0b246YWN0aXZle291dGxpbmU6bm9uZX0ubWRjLWJ1dHRvbjpob3ZlcntjdXJzb3I6cG9pbnRlcn0ubWRjLWJ1dHRvbjpkaXNhYmxlZHtjdXJzb3I6ZGVmYXVsdDtwb2ludGVyLWV2ZW50czpub25lfS5tZGMtYnV0dG9uIC5tZGMtYnV0dG9uX19yaXBwbGV7Ym9yZGVyLXJhZGl1czo0cHh9Lm1kYy1idXR0b246bm90KDpkaXNhYmxlZCl7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudH0ubWRjLWJ1dHRvbjpkaXNhYmxlZHtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50fS5tZGMtYnV0dG9uIC5tZGMtYnV0dG9uX19pY29ue21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjhweDtkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDoxOHB4O2hlaWdodDoxOHB4O2ZvbnQtc2l6ZToxOHB4O3ZlcnRpY2FsLWFsaWduOnRvcH1bZGlyPXJ0bF0gLm1kYy1idXR0b24gLm1kYy1idXR0b25fX2ljb24sLm1kYy1idXR0b24gLm1kYy1idXR0b25fX2ljb25bZGlyPXJ0bF17bWFyZ2luLWxlZnQ6OHB4O21hcmdpbi1yaWdodDowfS5tZGMtYnV0dG9uIC5tZGMtYnV0dG9uX190b3VjaHtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlO3JpZ2h0OjA7aGVpZ2h0OjQ4cHg7bGVmdDowO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpfS5tZGMtYnV0dG9uOm5vdCg6ZGlzYWJsZWQpe2NvbG9yOiM2MjAwZWU7Y29sb3I6dmFyKC0tbWRjLXRoZW1lLXByaW1hcnksICM2MjAwZWUpfS5tZGMtYnV0dG9uOmRpc2FibGVke2NvbG9yOnJnYmEoMCwwLDAsLjM4KX0ubWRjLWJ1dHRvbl9fbGFiZWwrLm1kYy1idXR0b25fX2ljb257bWFyZ2luLWxlZnQ6OHB4O21hcmdpbi1yaWdodDowfVtkaXI9cnRsXSAubWRjLWJ1dHRvbl9fbGFiZWwrLm1kYy1idXR0b25fX2ljb24sLm1kYy1idXR0b25fX2xhYmVsKy5tZGMtYnV0dG9uX19pY29uW2Rpcj1ydGxde21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjhweH1zdmcubWRjLWJ1dHRvbl9faWNvbntmaWxsOmN1cnJlbnRDb2xvcn0ubWRjLWJ1dHRvbi0tcmFpc2VkIC5tZGMtYnV0dG9uX19pY29uLC5tZGMtYnV0dG9uLS11bmVsZXZhdGVkIC5tZGMtYnV0dG9uX19pY29uLC5tZGMtYnV0dG9uLS1vdXRsaW5lZCAubWRjLWJ1dHRvbl9faWNvbnttYXJnaW4tbGVmdDotNHB4O21hcmdpbi1yaWdodDo4cHh9W2Rpcj1ydGxdIC5tZGMtYnV0dG9uLS1yYWlzZWQgLm1kYy1idXR0b25fX2ljb24sLm1kYy1idXR0b24tLXJhaXNlZCAubWRjLWJ1dHRvbl9faWNvbltkaXI9cnRsXSxbZGlyPXJ0bF0gLm1kYy1idXR0b24tLXVuZWxldmF0ZWQgLm1kYy1idXR0b25fX2ljb24sLm1kYy1idXR0b24tLXVuZWxldmF0ZWQgLm1kYy1idXR0b25fX2ljb25bZGlyPXJ0bF0sW2Rpcj1ydGxdIC5tZGMtYnV0dG9uLS1vdXRsaW5lZCAubWRjLWJ1dHRvbl9faWNvbiwubWRjLWJ1dHRvbi0tb3V0bGluZWQgLm1kYy1idXR0b25fX2ljb25bZGlyPXJ0bF17bWFyZ2luLWxlZnQ6OHB4O21hcmdpbi1yaWdodDotNHB4fS5tZGMtYnV0dG9uLS1yYWlzZWQgLm1kYy1idXR0b25fX2xhYmVsKy5tZGMtYnV0dG9uX19pY29uLC5tZGMtYnV0dG9uLS11bmVsZXZhdGVkIC5tZGMtYnV0dG9uX19sYWJlbCsubWRjLWJ1dHRvbl9faWNvbiwubWRjLWJ1dHRvbi0tb3V0bGluZWQgLm1kYy1idXR0b25fX2xhYmVsKy5tZGMtYnV0dG9uX19pY29ue21hcmdpbi1sZWZ0OjhweDttYXJnaW4tcmlnaHQ6LTRweH1bZGlyPXJ0bF0gLm1kYy1idXR0b24tLXJhaXNlZCAubWRjLWJ1dHRvbl9fbGFiZWwrLm1kYy1idXR0b25fX2ljb24sLm1kYy1idXR0b24tLXJhaXNlZCAubWRjLWJ1dHRvbl9fbGFiZWwrLm1kYy1idXR0b25fX2ljb25bZGlyPXJ0bF0sW2Rpcj1ydGxdIC5tZGMtYnV0dG9uLS11bmVsZXZhdGVkIC5tZGMtYnV0dG9uX19sYWJlbCsubWRjLWJ1dHRvbl9faWNvbiwubWRjLWJ1dHRvbi0tdW5lbGV2YXRlZCAubWRjLWJ1dHRvbl9fbGFiZWwrLm1kYy1idXR0b25fX2ljb25bZGlyPXJ0bF0sW2Rpcj1ydGxdIC5tZGMtYnV0dG9uLS1vdXRsaW5lZCAubWRjLWJ1dHRvbl9fbGFiZWwrLm1kYy1idXR0b25fX2ljb24sLm1kYy1idXR0b24tLW91dGxpbmVkIC5tZGMtYnV0dG9uX19sYWJlbCsubWRjLWJ1dHRvbl9faWNvbltkaXI9cnRsXXttYXJnaW4tbGVmdDotNHB4O21hcmdpbi1yaWdodDo4cHh9Lm1kYy1idXR0b24tLXJhaXNlZCwubWRjLWJ1dHRvbi0tdW5lbGV2YXRlZHtwYWRkaW5nOjAgMTZweCAwIDE2cHh9Lm1kYy1idXR0b24tLXJhaXNlZDpub3QoOmRpc2FibGVkKSwubWRjLWJ1dHRvbi0tdW5lbGV2YXRlZDpub3QoOmRpc2FibGVkKXtiYWNrZ3JvdW5kLWNvbG9yOiM2MjAwZWU7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1tZGMtdGhlbWUtcHJpbWFyeSwgIzYyMDBlZSl9Lm1kYy1idXR0b24tLXJhaXNlZDpub3QoOmRpc2FibGVkKSwubWRjLWJ1dHRvbi0tdW5lbGV2YXRlZDpub3QoOmRpc2FibGVkKXtjb2xvcjojZmZmO2NvbG9yOnZhcigtLW1kYy10aGVtZS1vbi1wcmltYXJ5LCAjZmZmKX0ubWRjLWJ1dHRvbi0tcmFpc2VkOmRpc2FibGVkLC5tZGMtYnV0dG9uLS11bmVsZXZhdGVkOmRpc2FibGVke2JhY2tncm91bmQtY29sb3I6cmdiYSgwLDAsMCwuMTIpfS5tZGMtYnV0dG9uLS1yYWlzZWQ6ZGlzYWJsZWQsLm1kYy1idXR0b24tLXVuZWxldmF0ZWQ6ZGlzYWJsZWR7Y29sb3I6cmdiYSgwLDAsMCwuMzgpfS5tZGMtYnV0dG9uLS1yYWlzZWR7Ym94LXNoYWRvdzowcHggM3B4IDFweCAtMnB4IHJnYmEoMCwgMCwgMCwgMC4yKSwwcHggMnB4IDJweCAwcHggcmdiYSgwLCAwLCAwLCAwLjE0KSwwcHggMXB4IDVweCAwcHggcmdiYSgwLDAsMCwuMTIpO3RyYW5zaXRpb246Ym94LXNoYWRvdyAyODBtcyBjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpfS5tZGMtYnV0dG9uLS1yYWlzZWQ6aG92ZXIsLm1kYy1idXR0b24tLXJhaXNlZDpmb2N1c3tib3gtc2hhZG93OjBweCAycHggNHB4IC0xcHggcmdiYSgwLCAwLCAwLCAwLjIpLDBweCA0cHggNXB4IDBweCByZ2JhKDAsIDAsIDAsIDAuMTQpLDBweCAxcHggMTBweCAwcHggcmdiYSgwLDAsMCwuMTIpfS5tZGMtYnV0dG9uLS1yYWlzZWQ6YWN0aXZle2JveC1zaGFkb3c6MHB4IDVweCA1cHggLTNweCByZ2JhKDAsIDAsIDAsIDAuMiksMHB4IDhweCAxMHB4IDFweCByZ2JhKDAsIDAsIDAsIDAuMTQpLDBweCAzcHggMTRweCAycHggcmdiYSgwLDAsMCwuMTIpfS5tZGMtYnV0dG9uLS1yYWlzZWQ6ZGlzYWJsZWR7Ym94LXNoYWRvdzowcHggMHB4IDBweCAwcHggcmdiYSgwLCAwLCAwLCAwLjIpLDBweCAwcHggMHB4IDBweCByZ2JhKDAsIDAsIDAsIDAuMTQpLDBweCAwcHggMHB4IDBweCByZ2JhKDAsMCwwLC4xMil9Lm1kYy1idXR0b24tLW91dGxpbmVke3BhZGRpbmc6MCAxNXB4IDAgMTVweDtib3JkZXItd2lkdGg6MXB4O2JvcmRlci1zdHlsZTpzb2xpZH0ubWRjLWJ1dHRvbi0tb3V0bGluZWQgLm1kYy1idXR0b25fX3JpcHBsZXt0b3A6LTFweDtsZWZ0Oi0xcHg7Ym9yZGVyOjFweCBzb2xpZCB0cmFuc3BhcmVudH0ubWRjLWJ1dHRvbi0tb3V0bGluZWQ6bm90KDpkaXNhYmxlZCl7Ym9yZGVyLWNvbG9yOnJnYmEoMCwwLDAsLjEyKX0ubWRjLWJ1dHRvbi0tb3V0bGluZWQ6ZGlzYWJsZWR7Ym9yZGVyLWNvbG9yOnJnYmEoMCwwLDAsLjEyKX0ubWRjLWJ1dHRvbi0tdG91Y2h7bWFyZ2luLXRvcDo2cHg7bWFyZ2luLWJvdHRvbTo2cHh9QGtleWZyYW1lcyBtZGMtcmlwcGxlLWZnLXJhZGl1cy1pbntmcm9te2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKTt0cmFuc2Zvcm06dHJhbnNsYXRlKHZhcigtLW1kYy1yaXBwbGUtZmctdHJhbnNsYXRlLXN0YXJ0LCAwKSkgc2NhbGUoMSl9dG97dHJhbnNmb3JtOnRyYW5zbGF0ZSh2YXIoLS1tZGMtcmlwcGxlLWZnLXRyYW5zbGF0ZS1lbmQsIDApKSBzY2FsZSh2YXIoLS1tZGMtcmlwcGxlLWZnLXNjYWxlLCAxKSl9fUBrZXlmcmFtZXMgbWRjLXJpcHBsZS1mZy1vcGFjaXR5LWlue2Zyb217YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpsaW5lYXI7b3BhY2l0eTowfXRve29wYWNpdHk6dmFyKC0tbWRjLXJpcHBsZS1mZy1vcGFjaXR5LCAwKX19QGtleWZyYW1lcyBtZGMtcmlwcGxlLWZnLW9wYWNpdHktb3V0e2Zyb217YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpsaW5lYXI7b3BhY2l0eTp2YXIoLS1tZGMtcmlwcGxlLWZnLW9wYWNpdHksIDApfXRve29wYWNpdHk6MH19Lm1kYy1idXR0b257LS1tZGMtcmlwcGxlLWZnLXNpemU6IDA7LS1tZGMtcmlwcGxlLWxlZnQ6IDA7LS1tZGMtcmlwcGxlLXRvcDogMDstLW1kYy1yaXBwbGUtZmctc2NhbGU6IDE7LS1tZGMtcmlwcGxlLWZnLXRyYW5zbGF0ZS1lbmQ6IDA7LS1tZGMtcmlwcGxlLWZnLXRyYW5zbGF0ZS1zdGFydDogMDstd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6cmdiYSgwLDAsMCwwKX0ubWRjLWJ1dHRvbiAubWRjLWJ1dHRvbl9fcmlwcGxlOjpiZWZvcmUsLm1kYy1idXR0b24gLm1kYy1idXR0b25fX3JpcHBsZTo6YWZ0ZXJ7cG9zaXRpb246YWJzb2x1dGU7Ym9yZGVyLXJhZGl1czo1MCU7b3BhY2l0eTowO3BvaW50ZXItZXZlbnRzOm5vbmU7Y29udGVudDoiIn0ubWRjLWJ1dHRvbiAubWRjLWJ1dHRvbl9fcmlwcGxlOjpiZWZvcmV7dHJhbnNpdGlvbjpvcGFjaXR5IDE1bXMgbGluZWFyLGJhY2tncm91bmQtY29sb3IgMTVtcyBsaW5lYXI7ei1pbmRleDoxfS5tZGMtYnV0dG9uLm1kYy1yaXBwbGUtdXBncmFkZWQgLm1kYy1idXR0b25fX3JpcHBsZTo6YmVmb3Jle3RyYW5zZm9ybTpzY2FsZSh2YXIoLS1tZGMtcmlwcGxlLWZnLXNjYWxlLCAxKSl9Lm1kYy1idXR0b24ubWRjLXJpcHBsZS11cGdyYWRlZCAubWRjLWJ1dHRvbl9fcmlwcGxlOjphZnRlcnt0b3A6MDtsZWZ0OjA7dHJhbnNmb3JtOnNjYWxlKDApO3RyYW5zZm9ybS1vcmlnaW46Y2VudGVyIGNlbnRlcn0ubWRjLWJ1dHRvbi5tZGMtcmlwcGxlLXVwZ3JhZGVkLS11bmJvdW5kZWQgLm1kYy1idXR0b25fX3JpcHBsZTo6YWZ0ZXJ7dG9wOnZhcigtLW1kYy1yaXBwbGUtdG9wLCAwKTtsZWZ0OnZhcigtLW1kYy1yaXBwbGUtbGVmdCwgMCl9Lm1kYy1idXR0b24ubWRjLXJpcHBsZS11cGdyYWRlZC0tZm9yZWdyb3VuZC1hY3RpdmF0aW9uIC5tZGMtYnV0dG9uX19yaXBwbGU6OmFmdGVye2FuaW1hdGlvbjptZGMtcmlwcGxlLWZnLXJhZGl1cy1pbiAyMjVtcyBmb3J3YXJkcyxtZGMtcmlwcGxlLWZnLW9wYWNpdHktaW4gNzVtcyBmb3J3YXJkc30ubWRjLWJ1dHRvbi5tZGMtcmlwcGxlLXVwZ3JhZGVkLS1mb3JlZ3JvdW5kLWRlYWN0aXZhdGlvbiAubWRjLWJ1dHRvbl9fcmlwcGxlOjphZnRlcnthbmltYXRpb246bWRjLXJpcHBsZS1mZy1vcGFjaXR5LW91dCAxNTBtczt0cmFuc2Zvcm06dHJhbnNsYXRlKHZhcigtLW1kYy1yaXBwbGUtZmctdHJhbnNsYXRlLWVuZCwgMCkpIHNjYWxlKHZhcigtLW1kYy1yaXBwbGUtZmctc2NhbGUsIDEpKX0ubWRjLWJ1dHRvbiAubWRjLWJ1dHRvbl9fcmlwcGxlOjpiZWZvcmUsLm1kYy1idXR0b24gLm1kYy1idXR0b25fX3JpcHBsZTo6YWZ0ZXJ7dG9wOmNhbGMoNTAlIC0gMTAwJSk7bGVmdDpjYWxjKDUwJSAtIDEwMCUpO3dpZHRoOjIwMCU7aGVpZ2h0OjIwMCV9Lm1kYy1idXR0b24ubWRjLXJpcHBsZS11cGdyYWRlZCAubWRjLWJ1dHRvbl9fcmlwcGxlOjphZnRlcnt3aWR0aDp2YXIoLS1tZGMtcmlwcGxlLWZnLXNpemUsIDEwMCUpO2hlaWdodDp2YXIoLS1tZGMtcmlwcGxlLWZnLXNpemUsIDEwMCUpfS5tZGMtYnV0dG9uIC5tZGMtYnV0dG9uX19yaXBwbGU6OmJlZm9yZSwubWRjLWJ1dHRvbiAubWRjLWJ1dHRvbl9fcmlwcGxlOjphZnRlcntiYWNrZ3JvdW5kLWNvbG9yOiM2MjAwZWU7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1tZGMtdGhlbWUtcHJpbWFyeSwgIzYyMDBlZSl9Lm1kYy1idXR0b246aG92ZXIgLm1kYy1idXR0b25fX3JpcHBsZTo6YmVmb3Jle29wYWNpdHk6LjA0fS5tZGMtYnV0dG9uLm1kYy1yaXBwbGUtdXBncmFkZWQtLWJhY2tncm91bmQtZm9jdXNlZCAubWRjLWJ1dHRvbl9fcmlwcGxlOjpiZWZvcmUsLm1kYy1idXR0b246bm90KC5tZGMtcmlwcGxlLXVwZ3JhZGVkKTpmb2N1cyAubWRjLWJ1dHRvbl9fcmlwcGxlOjpiZWZvcmV7dHJhbnNpdGlvbi1kdXJhdGlvbjo3NW1zO29wYWNpdHk6LjEyfS5tZGMtYnV0dG9uOm5vdCgubWRjLXJpcHBsZS11cGdyYWRlZCkgLm1kYy1idXR0b25fX3JpcHBsZTo6YWZ0ZXJ7dHJhbnNpdGlvbjpvcGFjaXR5IDE1MG1zIGxpbmVhcn0ubWRjLWJ1dHRvbjpub3QoLm1kYy1yaXBwbGUtdXBncmFkZWQpOmFjdGl2ZSAubWRjLWJ1dHRvbl9fcmlwcGxlOjphZnRlcnt0cmFuc2l0aW9uLWR1cmF0aW9uOjc1bXM7b3BhY2l0eTouMTJ9Lm1kYy1idXR0b24ubWRjLXJpcHBsZS11cGdyYWRlZHstLW1kYy1yaXBwbGUtZmctb3BhY2l0eTogMC4xMn0ubWRjLWJ1dHRvbiAubWRjLWJ1dHRvbl9fcmlwcGxle3Bvc2l0aW9uOmFic29sdXRlO2JveC1zaXppbmc6Y29udGVudC1ib3g7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtvdmVyZmxvdzpoaWRkZW59Lm1kYy1idXR0b246bm90KC5tZGMtYnV0dG9uLS1vdXRsaW5lZCkgLm1kYy1idXR0b25fX3JpcHBsZXt0b3A6MDtsZWZ0OjB9Lm1kYy1idXR0b24tLXJhaXNlZCAubWRjLWJ1dHRvbl9fcmlwcGxlOjpiZWZvcmUsLm1kYy1idXR0b24tLXJhaXNlZCAubWRjLWJ1dHRvbl9fcmlwcGxlOjphZnRlciwubWRjLWJ1dHRvbi0tdW5lbGV2YXRlZCAubWRjLWJ1dHRvbl9fcmlwcGxlOjpiZWZvcmUsLm1kYy1idXR0b24tLXVuZWxldmF0ZWQgLm1kYy1idXR0b25fX3JpcHBsZTo6YWZ0ZXJ7YmFja2dyb3VuZC1jb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6dmFyKC0tbWRjLXRoZW1lLW9uLXByaW1hcnksICNmZmYpfS5tZGMtYnV0dG9uLS1yYWlzZWQ6aG92ZXIgLm1kYy1idXR0b25fX3JpcHBsZTo6YmVmb3JlLC5tZGMtYnV0dG9uLS11bmVsZXZhdGVkOmhvdmVyIC5tZGMtYnV0dG9uX19yaXBwbGU6OmJlZm9yZXtvcGFjaXR5Oi4wOH0ubWRjLWJ1dHRvbi0tcmFpc2VkLm1kYy1yaXBwbGUtdXBncmFkZWQtLWJhY2tncm91bmQtZm9jdXNlZCAubWRjLWJ1dHRvbl9fcmlwcGxlOjpiZWZvcmUsLm1kYy1idXR0b24tLXJhaXNlZDpub3QoLm1kYy1yaXBwbGUtdXBncmFkZWQpOmZvY3VzIC5tZGMtYnV0dG9uX19yaXBwbGU6OmJlZm9yZSwubWRjLWJ1dHRvbi0tdW5lbGV2YXRlZC5tZGMtcmlwcGxlLXVwZ3JhZGVkLS1iYWNrZ3JvdW5kLWZvY3VzZWQgLm1kYy1idXR0b25fX3JpcHBsZTo6YmVmb3JlLC5tZGMtYnV0dG9uLS11bmVsZXZhdGVkOm5vdCgubWRjLXJpcHBsZS11cGdyYWRlZCk6Zm9jdXMgLm1kYy1idXR0b25fX3JpcHBsZTo6YmVmb3Jle3RyYW5zaXRpb24tZHVyYXRpb246NzVtcztvcGFjaXR5Oi4yNH0ubWRjLWJ1dHRvbi0tcmFpc2VkOm5vdCgubWRjLXJpcHBsZS11cGdyYWRlZCkgLm1kYy1idXR0b25fX3JpcHBsZTo6YWZ0ZXIsLm1kYy1idXR0b24tLXVuZWxldmF0ZWQ6bm90KC5tZGMtcmlwcGxlLXVwZ3JhZGVkKSAubWRjLWJ1dHRvbl9fcmlwcGxlOjphZnRlcnt0cmFuc2l0aW9uOm9wYWNpdHkgMTUwbXMgbGluZWFyfS5tZGMtYnV0dG9uLS1yYWlzZWQ6bm90KC5tZGMtcmlwcGxlLXVwZ3JhZGVkKTphY3RpdmUgLm1kYy1idXR0b25fX3JpcHBsZTo6YWZ0ZXIsLm1kYy1idXR0b24tLXVuZWxldmF0ZWQ6bm90KC5tZGMtcmlwcGxlLXVwZ3JhZGVkKTphY3RpdmUgLm1kYy1idXR0b25fX3JpcHBsZTo6YWZ0ZXJ7dHJhbnNpdGlvbi1kdXJhdGlvbjo3NW1zO29wYWNpdHk6LjI0fS5tZGMtYnV0dG9uLS1yYWlzZWQubWRjLXJpcHBsZS11cGdyYWRlZCwubWRjLWJ1dHRvbi0tdW5lbGV2YXRlZC5tZGMtcmlwcGxlLXVwZ3JhZGVkey0tbWRjLXJpcHBsZS1mZy1vcGFjaXR5OiAwLjI0fS5tZGMtYnV0dG9ue2hlaWdodDozNnB4fS5tYXRlcmlhbC1pY29uc3tmb250LWZhbWlseTp2YXIoLS1tZGMtaWNvbi1mb250LCAiTWF0ZXJpYWwgSWNvbnMiKTtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zdHlsZTpub3JtYWw7Zm9udC1zaXplOnZhcigtLW1kYy1pY29uLXNpemUsIDI0cHgpO2xpbmUtaGVpZ2h0OjE7bGV0dGVyLXNwYWNpbmc6bm9ybWFsO3RleHQtdHJhbnNmb3JtOm5vbmU7ZGlzcGxheTppbmxpbmUtYmxvY2s7d2hpdGUtc3BhY2U6bm93cmFwO3dvcmQtd3JhcDpub3JtYWw7ZGlyZWN0aW9uOmx0cjstd2Via2l0LWZvbnQtc21vb3RoaW5nOmFudGlhbGlhc2VkO3RleHQtcmVuZGVyaW5nOm9wdGltaXplTGVnaWJpbGl0eTstbW96LW9zeC1mb250LXNtb290aGluZzpncmF5c2NhbGU7Zm9udC1mZWF0dXJlLXNldHRpbmdzOiJsaWdhIn06aG9zdHtkaXNwbGF5OmlubGluZS1mbGV4O291dGxpbmU6bm9uZTt2ZXJ0aWNhbC1hbGlnbjp0b3B9Omhvc3QoW2Rpc2FibGVkXSl7cG9pbnRlci1ldmVudHM6bm9uZX0ubWRjLWJ1dHRvbntmbGV4OmF1dG87b3ZlcmZsb3c6aGlkZGVuO3RleHQtdHJhbnNmb3JtOnZhcigtLW1kYy1idXR0b24tdGV4dC10cmFuc2Zvcm0sIHVwcGVyY2FzZSk7bGV0dGVyLXNwYWNpbmc6dmFyKC0tbWRjLWJ1dHRvbi1sZXR0ZXItc3BhY2luZywgMC4wODkyODU3MTQzZW0pO3BhZGRpbmc6MCB2YXIoLS1tZGMtYnV0dG9uLWhvcml6b250YWwtcGFkZGluZywgOHB4KSAwIHZhcigtLW1kYy1idXR0b24taG9yaXpvbnRhbC1wYWRkaW5nLCA4cHgpfS5tZGMtYnV0dG9uLm1kYy1idXR0b24tLXJhaXNlZCwubWRjLWJ1dHRvbi5tZGMtYnV0dG9uLS11bmVsZXZhdGVke3BhZGRpbmc6MCB2YXIoLS1tZGMtYnV0dG9uLWhvcml6b250YWwtcGFkZGluZywgMTZweCkgMCB2YXIoLS1tZGMtYnV0dG9uLWhvcml6b250YWwtcGFkZGluZywgMTZweCl9Lm1kYy1idXR0b24ubWRjLWJ1dHRvbi0tb3V0bGluZWR7cGFkZGluZzowIGNhbGModmFyKC0tbWRjLWJ1dHRvbi1ob3Jpem9udGFsLXBhZGRpbmcsIDE2cHgpIC0gdmFyKC0tbWRjLWJ1dHRvbi1vdXRsaW5lLXdpZHRoLCAxcHgpKSAwIGNhbGModmFyKC0tbWRjLWJ1dHRvbi1ob3Jpem9udGFsLXBhZGRpbmcsIDE2cHgpIC0gdmFyKC0tbWRjLWJ1dHRvbi1vdXRsaW5lLXdpZHRoLCAxcHgpKTtib3JkZXItd2lkdGg6dmFyKC0tbWRjLWJ1dHRvbi1vdXRsaW5lLXdpZHRoLCAxcHgpO2JvcmRlci1jb2xvcjp2YXIoLS1tZGMtYnV0dG9uLW91dGxpbmUtY29sb3IsIHZhcigtLW1kYy10aGVtZS1wcmltYXJ5LCAjNjIwMGVlKSl9Lm1kYy1idXR0b24gLm1kYy1idXR0b25fX3JpcHBsZXtib3JkZXItcmFkaXVzOjB9Omhvc3QoW2Rpc2FibGVkXSkgLm1kYy1idXR0b24ubWRjLWJ1dHRvbi0tcmFpc2VkLDpob3N0KFtkaXNhYmxlZF0pIC5tZGMtYnV0dG9uLm1kYy1idXR0b24tLXVuZWxldmF0ZWR7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1tZGMtYnV0dG9uLWRpc2FibGVkLWZpbGwtY29sb3IsIHJnYmEoMCwgMCwgMCwgMC4xMikpO2NvbG9yOnZhcigtLW1kYy1idXR0b24tZGlzYWJsZWQtaW5rLWNvbG9yLCByZ2JhKDAsIDAsIDAsIDAuMzgpKX06aG9zdChbZGlzYWJsZWRdKSAubWRjLWJ1dHRvbjpub3QoLm1kYy1idXR0b24tLXJhaXNlZCk6bm90KC5tZGMtYnV0dG9uLS11bmVsZXZhdGVkKXtjb2xvcjp2YXIoLS1tZGMtYnV0dG9uLWRpc2FibGVkLWluay1jb2xvciwgcmdiYSgwLCAwLCAwLCAwLjM4KSl9Omhvc3QoW2Rpc2FibGVkXSkgLm1kYy1idXR0b24ubWRjLWJ1dHRvbi0tb3V0bGluZWR7Ym9yZGVyLWNvbG9yOnZhcigtLW1kYy1idXR0b24tZGlzYWJsZWQtaW5rLWNvbG9yLCByZ2JhKDAsIDAsIDAsIDAuMzgpKTtib3JkZXItY29sb3I6dmFyKC0tbWRjLWJ1dHRvbi1kaXNhYmxlZC1vdXRsaW5lLWNvbG9yLCB2YXIoLS1tZGMtYnV0dG9uLWRpc2FibGVkLWluay1jb2xvciwgcmdiYSgwLCAwLCAwLCAwLjM4KSkpfWA7bGV0IEh0PWNsYXNzIGV4dGVuZHMgTnR7fTtIdC5zdHlsZXM9T3QsSHQ9cihbUSgibXdjLWJ1dHRvbiIpXSxIdCk7Y29uc3QgVnQ9dD0+KGUsaSk9PntpZihlLmNvbnN0cnVjdG9yLl9vYnNlcnZlcnMpe2lmKCFlLmNvbnN0cnVjdG9yLmhhc093blByb3BlcnR5KCJfb2JzZXJ2ZXJzIikpe2NvbnN0IHQ9ZS5jb25zdHJ1Y3Rvci5fb2JzZXJ2ZXJzO2UuY29uc3RydWN0b3IuX29ic2VydmVycz1uZXcgTWFwLHQuZm9yRWFjaCgodCxpKT0+ZS5jb25zdHJ1Y3Rvci5fb2JzZXJ2ZXJzLnNldChpLHQpKX19ZWxzZXtlLmNvbnN0cnVjdG9yLl9vYnNlcnZlcnM9bmV3IE1hcDtjb25zdCB0PWUudXBkYXRlZDtlLnVwZGF0ZWQ9ZnVuY3Rpb24oZSl7dC5jYWxsKHRoaXMsZSksZS5mb3JFYWNoKCh0LGUpPT57Y29uc3QgaT10aGlzLmNvbnN0cnVjdG9yLl9vYnNlcnZlcnMuZ2V0KGUpO3ZvaWQgMCE9PWkmJmkuY2FsbCh0aGlzLHRoaXNbZV0sdCl9KX19ZS5jb25zdHJ1Y3Rvci5fb2JzZXJ2ZXJzLnNldChpLHQpfQovKioKICAgIEBsaWNlbnNlCiAgICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLgoKICAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAiTGljZW5zZSIpOwogICAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLgogICAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CgogICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAoKICAgIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUKICAgIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICJBUyBJUyIgQkFTSVMsCiAgICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4KICAgIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQKICAgIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLgogICAgKi87Y29uc3QgRHQ9KCk9Pnt9LEZ0PXtnZXQgcGFzc2l2ZSgpe3JldHVybiExfX07ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigieCIsRHQsRnQpLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIngiLER0KTsKLyoqCiAgICBAbGljZW5zZQogICAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC4KCiAgICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKICAgIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4KICAgIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdAoKICAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKCiAgICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCiAgICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAiQVMgSVMiIEJBU0lTLAogICAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuCiAgICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCiAgICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4KICAgICovCmNsYXNzIE10IGV4dGVuZHMgbHR7Y3JlYXRlRm91bmRhdGlvbigpe3ZvaWQgMCE9PXRoaXMubWRjRm91bmRhdGlvbiYmdGhpcy5tZGNGb3VuZGF0aW9uLmRlc3Ryb3koKSx0aGlzLm1kY0ZvdW5kYXRpb249bmV3IHRoaXMubWRjRm91bmRhdGlvbkNsYXNzKHRoaXMuY3JlYXRlQWRhcHRlcigpKSx0aGlzLm1kY0ZvdW5kYXRpb24uaW5pdCgpfWZpcnN0VXBkYXRlZCgpe3RoaXMuY3JlYXRlRm91bmRhdGlvbigpfX0KLyoqCiAgICBAbGljZW5zZQogICAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC4KCiAgICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKICAgIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4KICAgIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdAoKICAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKCiAgICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCiAgICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAiQVMgSVMiIEJBU0lTLAogICAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuCiAgICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCiAgICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4KICAgICovY2xhc3MgTHQgZXh0ZW5kcyBNdHtjcmVhdGVSZW5kZXJSb290KCl7cmV0dXJuIHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiJvcGVuIixkZWxlZ2F0ZXNGb2N1czohMH0pfWNsaWNrKCl7dGhpcy5mb3JtRWxlbWVudCYmKHRoaXMuZm9ybUVsZW1lbnQuZm9jdXMoKSx0aGlzLmZvcm1FbGVtZW50LmNsaWNrKCkpfXNldEFyaWFMYWJlbCh0KXt0aGlzLmZvcm1FbGVtZW50JiZ0aGlzLmZvcm1FbGVtZW50LnNldEF0dHJpYnV0ZSgiYXJpYS1sYWJlbCIsdCl9Zmlyc3RVcGRhdGVkKCl7c3VwZXIuZmlyc3RVcGRhdGVkKCksdGhpcy5tZGNSb290LmFkZEV2ZW50TGlzdGVuZXIoImNoYW5nZSIsdD0+e3RoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoImNoYW5nZSIsdCkpfSl9fQovKioKICAgICAqIEBsaWNlbnNlCiAgICAgKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLgogICAgICoKICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkKICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlICJTb2Z0d2FyZSIpLCB0byBkZWFsCiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzCiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsCiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMKICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6CiAgICAgKgogICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4KICAgICAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLgogICAgICoKICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAiQVMgSVMiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SCiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwKICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRQogICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUgogICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwKICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4KICAgICAqIFRIRSBTT0ZUV0FSRS4KICAgICAqL3ZhciBVdD17YW5pbWF0aW9uOntwcmVmaXhlZDoiLXdlYmtpdC1hbmltYXRpb24iLHN0YW5kYXJkOiJhbmltYXRpb24ifSx0cmFuc2Zvcm06e3ByZWZpeGVkOiItd2Via2l0LXRyYW5zZm9ybSIsc3RhbmRhcmQ6InRyYW5zZm9ybSJ9LHRyYW5zaXRpb246e3ByZWZpeGVkOiItd2Via2l0LXRyYW5zaXRpb24iLHN0YW5kYXJkOiJ0cmFuc2l0aW9uIn19LHp0PXthbmltYXRpb25lbmQ6e2Nzc1Byb3BlcnR5OiJhbmltYXRpb24iLHByZWZpeGVkOiJ3ZWJraXRBbmltYXRpb25FbmQiLHN0YW5kYXJkOiJhbmltYXRpb25lbmQifSxhbmltYXRpb25pdGVyYXRpb246e2Nzc1Byb3BlcnR5OiJhbmltYXRpb24iLHByZWZpeGVkOiJ3ZWJraXRBbmltYXRpb25JdGVyYXRpb24iLHN0YW5kYXJkOiJhbmltYXRpb25pdGVyYXRpb24ifSxhbmltYXRpb25zdGFydDp7Y3NzUHJvcGVydHk6ImFuaW1hdGlvbiIscHJlZml4ZWQ6IndlYmtpdEFuaW1hdGlvblN0YXJ0IixzdGFuZGFyZDoiYW5pbWF0aW9uc3RhcnQifSx0cmFuc2l0aW9uZW5kOntjc3NQcm9wZXJ0eToidHJhbnNpdGlvbiIscHJlZml4ZWQ6IndlYmtpdFRyYW5zaXRpb25FbmQiLHN0YW5kYXJkOiJ0cmFuc2l0aW9uZW5kIn19O2Z1bmN0aW9uIEJ0KHQpe3JldHVybiBCb29sZWFuKHQuZG9jdW1lbnQpJiYiZnVuY3Rpb24iPT10eXBlb2YgdC5kb2N1bWVudC5jcmVhdGVFbGVtZW50fQovKioKICAgICAqIEBsaWNlbnNlCiAgICAgKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLgogICAgICoKICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkKICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlICJTb2Z0d2FyZSIpLCB0byBkZWFsCiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzCiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsCiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMKICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6CiAgICAgKgogICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4KICAgICAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLgogICAgICoKICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAiQVMgSVMiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SCiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwKICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRQogICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUgogICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwKICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4KICAgICAqIFRIRSBTT0ZUV0FSRS4KICAgICAqLwp2YXIganQ9e0FDVElWRToibWRjLXNsaWRlci0tYWN0aXZlIixESVNBQkxFRDoibWRjLXNsaWRlci0tZGlzYWJsZWQiLERJU0NSRVRFOiJtZGMtc2xpZGVyLS1kaXNjcmV0ZSIsRk9DVVM6Im1kYy1zbGlkZXItLWZvY3VzIixIQVNfVFJBQ0tfTUFSS0VSOiJtZGMtc2xpZGVyLS1kaXNwbGF5LW1hcmtlcnMiLElOX1RSQU5TSVQ6Im1kYy1zbGlkZXItLWluLXRyYW5zaXQiLElTX0RJU0NSRVRFOiJtZGMtc2xpZGVyLS1kaXNjcmV0ZSJ9LCR0PXtBUklBX0RJU0FCTEVEOiJhcmlhLWRpc2FibGVkIixBUklBX1ZBTFVFTUFYOiJhcmlhLXZhbHVlbWF4IixBUklBX1ZBTFVFTUlOOiJhcmlhLXZhbHVlbWluIixBUklBX1ZBTFVFTk9XOiJhcmlhLXZhbHVlbm93IixDSEFOR0VfRVZFTlQ6Ik1EQ1NsaWRlcjpjaGFuZ2UiLElOUFVUX0VWRU5UOiJNRENTbGlkZXI6aW5wdXQiLFBJTl9WQUxVRV9NQVJLRVJfU0VMRUNUT1I6Ii5tZGMtc2xpZGVyX19waW4tdmFsdWUtbWFya2VyIixTVEVQX0RBVEFfQVRUUjoiZGF0YS1zdGVwIixUSFVNQl9DT05UQUlORVJfU0VMRUNUT1I6Ii5tZGMtc2xpZGVyX190aHVtYi1jb250YWluZXIiLFRSQUNLX01BUktFUl9DT05UQUlORVJfU0VMRUNUT1I6Ii5tZGMtc2xpZGVyX190cmFjay1tYXJrZXItY29udGFpbmVyIixUUkFDS19TRUxFQ1RPUjoiLm1kYy1zbGlkZXJfX3RyYWNrIn0scXQ9e1BBR0VfRkFDVE9SOjR9LEd0PVsibW91c2Vkb3duIiwicG9pbnRlcmRvd24iLCJ0b3VjaHN0YXJ0Il0sV3Q9WyJtb3VzZXVwIiwicG9pbnRlcnVwIiwidG91Y2hlbmQiXSxYdD17bW91c2Vkb3duOiJtb3VzZW1vdmUiLHBvaW50ZXJkb3duOiJwb2ludGVybW92ZSIsdG91Y2hzdGFydDoidG91Y2htb3ZlIn0sS3Q9IkFycm93RG93biIsSnQ9IkFycm93TGVmdCIsWXQ9IkFycm93UmlnaHQiLFp0PSJBcnJvd1VwIixRdD0iRW5kIix0ZT0iSG9tZSIsZWU9IlBhZ2VEb3duIixpZT0iUGFnZVVwIixuZT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGkpe3ZhciByPXQuY2FsbCh0aGlzLG4oe30sZS5kZWZhdWx0QWRhcHRlcixpKSl8fHRoaXM7cmV0dXJuIHIuc2F2ZWRUYWJJbmRleF89TmFOLHIuYWN0aXZlXz0hMSxyLmluVHJhbnNpdF89ITEsci5pc0Rpc2NyZXRlXz0hMSxyLmhhc1RyYWNrTWFya2VyXz0hMSxyLmhhbmRsaW5nVGh1bWJUYXJnZXRFdnRfPSExLHIubWluXz0wLHIubWF4Xz0xMDAsci5zdGVwXz0wLHIudmFsdWVfPTAsci5kaXNhYmxlZF89ITEsci5wcmV2ZW50Rm9jdXNTdGF0ZV89ITEsci50aHVtYkNvbnRhaW5lclBvaW50ZXJIYW5kbGVyXz1mdW5jdGlvbigpe3JldHVybiByLmhhbmRsaW5nVGh1bWJUYXJnZXRFdnRfPSEwfSxyLmludGVyYWN0aW9uU3RhcnRIYW5kbGVyXz1mdW5jdGlvbih0KXtyZXR1cm4gci5oYW5kbGVEb3duXyh0KX0sci5rZXlkb3duSGFuZGxlcl89ZnVuY3Rpb24odCl7cmV0dXJuIHIuaGFuZGxlS2V5ZG93bl8odCl9LHIuZm9jdXNIYW5kbGVyXz1mdW5jdGlvbigpe3JldHVybiByLmhhbmRsZUZvY3VzXygpfSxyLmJsdXJIYW5kbGVyXz1mdW5jdGlvbigpe3JldHVybiByLmhhbmRsZUJsdXJfKCl9LHIucmVzaXplSGFuZGxlcl89ZnVuY3Rpb24oKXtyZXR1cm4gci5sYXlvdXQoKX0scn1yZXR1cm4gaShlLHQpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJjc3NDbGFzc2VzIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGp0fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJzdHJpbmdzIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuICR0fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJudW1iZXJzIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHF0fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJkZWZhdWx0QWRhcHRlciIse2dldDpmdW5jdGlvbigpe3JldHVybntoYXNDbGFzczpmdW5jdGlvbigpe3JldHVybiExfSxhZGRDbGFzczpmdW5jdGlvbigpe30scmVtb3ZlQ2xhc3M6ZnVuY3Rpb24oKXt9LGdldEF0dHJpYnV0ZTpmdW5jdGlvbigpe3JldHVybiBudWxsfSxzZXRBdHRyaWJ1dGU6ZnVuY3Rpb24oKXt9LHJlbW92ZUF0dHJpYnV0ZTpmdW5jdGlvbigpe30sY29tcHV0ZUJvdW5kaW5nUmVjdDpmdW5jdGlvbigpe3JldHVybnt0b3A6MCxyaWdodDowLGJvdHRvbTowLGxlZnQ6MCx3aWR0aDowLGhlaWdodDowfX0sZ2V0VGFiSW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gMH0scmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ZnVuY3Rpb24oKXt9LGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ZnVuY3Rpb24oKXt9LHJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXI6ZnVuY3Rpb24oKXt9LGRlcmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlcjpmdW5jdGlvbigpe30scmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyOmZ1bmN0aW9uKCl7fSxkZXJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlcjpmdW5jdGlvbigpe30scmVnaXN0ZXJSZXNpemVIYW5kbGVyOmZ1bmN0aW9uKCl7fSxkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjpmdW5jdGlvbigpe30sbm90aWZ5SW5wdXQ6ZnVuY3Rpb24oKXt9LG5vdGlmeUNoYW5nZTpmdW5jdGlvbigpe30sc2V0VGh1bWJDb250YWluZXJTdHlsZVByb3BlcnR5OmZ1bmN0aW9uKCl7fSxzZXRUcmFja1N0eWxlUHJvcGVydHk6ZnVuY3Rpb24oKXt9LHNldE1hcmtlclZhbHVlOmZ1bmN0aW9uKCl7fSxzZXRUcmFja01hcmtlcnM6ZnVuY3Rpb24oKXt9LGlzUlRMOmZ1bmN0aW9uKCl7cmV0dXJuITF9fX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxlLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLmlzRGlzY3JldGVfPXRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoanQuSVNfRElTQ1JFVEUpLHRoaXMuaGFzVHJhY2tNYXJrZXJfPXRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoanQuSEFTX1RSQUNLX01BUktFUiksR3QuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dC5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihlLHQuaW50ZXJhY3Rpb25TdGFydEhhbmRsZXJfKSx0LmFkYXB0ZXJfLnJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIoZSx0LnRodW1iQ29udGFpbmVyUG9pbnRlckhhbmRsZXJfKX0pKSx0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCJrZXlkb3duIix0aGlzLmtleWRvd25IYW5kbGVyXyksdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigiZm9jdXMiLHRoaXMuZm9jdXNIYW5kbGVyXyksdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigiYmx1ciIsdGhpcy5ibHVySGFuZGxlcl8pLHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pLHRoaXMubGF5b3V0KCksdGhpcy5pc0Rpc2NyZXRlXyYmMD09PXRoaXMuZ2V0U3RlcCgpJiYodGhpcy5zdGVwXz0xKX0sZS5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3ZhciB0PXRoaXM7R3QuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dC5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGUsdC5pbnRlcmFjdGlvblN0YXJ0SGFuZGxlcl8pLHQuYWRhcHRlcl8uZGVyZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyKGUsdC50aHVtYkNvbnRhaW5lclBvaW50ZXJIYW5kbGVyXyl9KSksdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCJrZXlkb3duIix0aGlzLmtleWRvd25IYW5kbGVyXyksdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCJmb2N1cyIsdGhpcy5mb2N1c0hhbmRsZXJfKSx0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoImJsdXIiLHRoaXMuYmx1ckhhbmRsZXJfKSx0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pfSxlLnByb3RvdHlwZS5zZXR1cFRyYWNrTWFya2VyPWZ1bmN0aW9uKCl7dGhpcy5pc0Rpc2NyZXRlXyYmdGhpcy5oYXNUcmFja01hcmtlcl8mJjAhPT10aGlzLmdldFN0ZXAoKSYmdGhpcy5hZGFwdGVyXy5zZXRUcmFja01hcmtlcnModGhpcy5nZXRTdGVwKCksdGhpcy5nZXRNYXgoKSx0aGlzLmdldE1pbigpKX0sZS5wcm90b3R5cGUubGF5b3V0PWZ1bmN0aW9uKCl7dGhpcy5yZWN0Xz10aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKSx0aGlzLnVwZGF0ZVVJRm9yQ3VycmVudFZhbHVlXygpfSxlLnByb3RvdHlwZS5nZXRWYWx1ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlX30sZS5wcm90b3R5cGUuc2V0VmFsdWU9ZnVuY3Rpb24odCl7dGhpcy5zZXRWYWx1ZV8odCwhMSl9LGUucHJvdG90eXBlLmdldE1heD1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1heF99LGUucHJvdG90eXBlLnNldE1heD1mdW5jdGlvbih0KXtpZih0PHRoaXMubWluXyl0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCBzZXQgbWF4IHRvIGJlIGxlc3MgdGhhbiB0aGUgc2xpZGVyJ3MgbWluaW11bSB2YWx1ZSIpO3RoaXMubWF4Xz10LHRoaXMuc2V0VmFsdWVfKHRoaXMudmFsdWVfLCExLCEwKSx0aGlzLmFkYXB0ZXJfLnNldEF0dHJpYnV0ZSgkdC5BUklBX1ZBTFVFTUFYLFN0cmluZyh0aGlzLm1heF8pKSx0aGlzLnNldHVwVHJhY2tNYXJrZXIoKX0sZS5wcm90b3R5cGUuZ2V0TWluPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWluX30sZS5wcm90b3R5cGUuc2V0TWluPWZ1bmN0aW9uKHQpe2lmKHQ+dGhpcy5tYXhfKXRocm93IG5ldyBFcnJvcigiQ2Fubm90IHNldCBtaW4gdG8gYmUgZ3JlYXRlciB0aGFuIHRoZSBzbGlkZXIncyBtYXhpbXVtIHZhbHVlIik7dGhpcy5taW5fPXQsdGhpcy5zZXRWYWx1ZV8odGhpcy52YWx1ZV8sITEsITApLHRoaXMuYWRhcHRlcl8uc2V0QXR0cmlidXRlKCR0LkFSSUFfVkFMVUVNSU4sU3RyaW5nKHRoaXMubWluXykpLHRoaXMuc2V0dXBUcmFja01hcmtlcigpfSxlLnByb3RvdHlwZS5nZXRTdGVwPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RlcF99LGUucHJvdG90eXBlLnNldFN0ZXA9ZnVuY3Rpb24odCl7aWYodDwwKXRocm93IG5ldyBFcnJvcigiU3RlcCBjYW5ub3QgYmUgc2V0IHRvIGEgbmVnYXRpdmUgbnVtYmVyIik7dGhpcy5pc0Rpc2NyZXRlXyYmKCJudW1iZXIiIT10eXBlb2YgdHx8dDwxKSYmKHQ9MSksdGhpcy5zdGVwXz10LHRoaXMuc2V0VmFsdWVfKHRoaXMudmFsdWVfLCExLCEwKSx0aGlzLnNldHVwVHJhY2tNYXJrZXIoKX0sZS5wcm90b3R5cGUuaXNEaXNhYmxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc2FibGVkX30sZS5wcm90b3R5cGUuc2V0RGlzYWJsZWQ9ZnVuY3Rpb24odCl7dGhpcy5kaXNhYmxlZF89dCx0aGlzLnRvZ2dsZUNsYXNzXyhqdC5ESVNBQkxFRCx0aGlzLmRpc2FibGVkXyksdGhpcy5kaXNhYmxlZF8/KHRoaXMuc2F2ZWRUYWJJbmRleF89dGhpcy5hZGFwdGVyXy5nZXRUYWJJbmRleCgpLHRoaXMuYWRhcHRlcl8uc2V0QXR0cmlidXRlKCR0LkFSSUFfRElTQUJMRUQsInRydWUiKSx0aGlzLmFkYXB0ZXJfLnJlbW92ZUF0dHJpYnV0ZSgidGFiaW5kZXgiKSk6KHRoaXMuYWRhcHRlcl8ucmVtb3ZlQXR0cmlidXRlKCR0LkFSSUFfRElTQUJMRUQpLGlzTmFOKHRoaXMuc2F2ZWRUYWJJbmRleF8pfHx0aGlzLmFkYXB0ZXJfLnNldEF0dHJpYnV0ZSgidGFiaW5kZXgiLFN0cmluZyh0aGlzLnNhdmVkVGFiSW5kZXhfKSkpfSxlLnByb3RvdHlwZS5oYW5kbGVEb3duXz1mdW5jdGlvbih0KXt2YXIgZT10aGlzO2lmKCF0aGlzLmRpc2FibGVkXyl7dGhpcy5wcmV2ZW50Rm9jdXNTdGF0ZV89ITAsdGhpcy5zZXRJblRyYW5zaXRfKCF0aGlzLmhhbmRsaW5nVGh1bWJUYXJnZXRFdnRfKSx0aGlzLmhhbmRsaW5nVGh1bWJUYXJnZXRFdnRfPSExLHRoaXMuc2V0QWN0aXZlXyghMCk7dmFyIGk9ZnVuY3Rpb24odCl7ZS5oYW5kbGVNb3ZlXyh0KX0sbj1YdFt0LnR5cGVdLHI9ZnVuY3Rpb24oKXtlLmhhbmRsZVVwXygpLGUuYWRhcHRlcl8uZGVyZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXIobixpKSxXdC5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gZS5hZGFwdGVyXy5kZXJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlcih0LHIpfSkpfTt0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlcihuLGkpLFd0LmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBlLmFkYXB0ZXJfLnJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlcih0LHIpfSkpLHRoaXMuc2V0VmFsdWVGcm9tRXZ0Xyh0KX19LGUucHJvdG90eXBlLmhhbmRsZU1vdmVfPWZ1bmN0aW9uKHQpe3QucHJldmVudERlZmF1bHQoKSx0aGlzLnNldFZhbHVlRnJvbUV2dF8odCl9LGUucHJvdG90eXBlLmhhbmRsZVVwXz1mdW5jdGlvbigpe3RoaXMuc2V0QWN0aXZlXyghMSksdGhpcy5hZGFwdGVyXy5ub3RpZnlDaGFuZ2UoKX0sZS5wcm90b3R5cGUuZ2V0UGFnZVhfPWZ1bmN0aW9uKHQpe3JldHVybiB0LnRhcmdldFRvdWNoZXMmJnQudGFyZ2V0VG91Y2hlcy5sZW5ndGg+MD90LnRhcmdldFRvdWNoZXNbMF0ucGFnZVg6dC5wYWdlWH0sZS5wcm90b3R5cGUuc2V0VmFsdWVGcm9tRXZ0Xz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldFBhZ2VYXyh0KSxpPXRoaXMuY29tcHV0ZVZhbHVlRnJvbVBhZ2VYXyhlKTt0aGlzLnNldFZhbHVlXyhpLCEwKX0sZS5wcm90b3R5cGUuY29tcHV0ZVZhbHVlRnJvbVBhZ2VYXz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLm1heF8saT10aGlzLm1pbl8sbj0odC10aGlzLnJlY3RfLmxlZnQpL3RoaXMucmVjdF8ud2lkdGg7cmV0dXJuIHRoaXMuYWRhcHRlcl8uaXNSVEwoKSYmKG49MS1uKSxpK24qKGUtaSl9LGUucHJvdG90eXBlLmhhbmRsZUtleWRvd25fPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0S2V5SWRfKHQpLGk9dGhpcy5nZXRWYWx1ZUZvcktleUlkXyhlKTtpc05hTihpKXx8KHQucHJldmVudERlZmF1bHQoKSx0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGp0LkZPQ1VTKSx0aGlzLnNldFZhbHVlXyhpLCEwKSx0aGlzLmFkYXB0ZXJfLm5vdGlmeUNoYW5nZSgpKX0sZS5wcm90b3R5cGUuZ2V0S2V5SWRfPWZ1bmN0aW9uKHQpe3JldHVybiB0LmtleT09PUp0fHwzNz09PXQua2V5Q29kZT9KdDp0LmtleT09PVl0fHwzOT09PXQua2V5Q29kZT9ZdDp0LmtleT09PVp0fHwzOD09PXQua2V5Q29kZT9adDp0LmtleT09PUt0fHw0MD09PXQua2V5Q29kZT9LdDp0LmtleT09PXRlfHwzNj09PXQua2V5Q29kZT90ZTp0LmtleT09PVF0fHwzNT09PXQua2V5Q29kZT9RdDp0LmtleT09PWllfHwzMz09PXQua2V5Q29kZT9pZTp0LmtleT09PWVlfHwzND09PXQua2V5Q29kZT9lZToiIn0sZS5wcm90b3R5cGUuZ2V0VmFsdWVGb3JLZXlJZF89ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5tYXhfLGk9dGhpcy5taW5fLG49dGhpcy5zdGVwX3x8KGUtaSkvMTAwO3N3aXRjaCh0aGlzLmFkYXB0ZXJfLmlzUlRMKCkmJih0PT09SnR8fHQ9PT1ZdCkmJihuPS1uKSx0KXtjYXNlIEp0OmNhc2UgS3Q6cmV0dXJuIHRoaXMudmFsdWVfLW47Y2FzZSBZdDpjYXNlIFp0OnJldHVybiB0aGlzLnZhbHVlXytuO2Nhc2UgdGU6cmV0dXJuIHRoaXMubWluXztjYXNlIFF0OnJldHVybiB0aGlzLm1heF87Y2FzZSBpZTpyZXR1cm4gdGhpcy52YWx1ZV8rbipxdC5QQUdFX0ZBQ1RPUjtjYXNlIGVlOnJldHVybiB0aGlzLnZhbHVlXy1uKnF0LlBBR0VfRkFDVE9SO2RlZmF1bHQ6cmV0dXJuIE5hTn19LGUucHJvdG90eXBlLmhhbmRsZUZvY3VzXz1mdW5jdGlvbigpe3RoaXMucHJldmVudEZvY3VzU3RhdGVffHx0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGp0LkZPQ1VTKX0sZS5wcm90b3R5cGUuaGFuZGxlQmx1cl89ZnVuY3Rpb24oKXt0aGlzLnByZXZlbnRGb2N1c1N0YXRlXz0hMSx0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGp0LkZPQ1VTKX0sZS5wcm90b3R5cGUuc2V0VmFsdWVfPWZ1bmN0aW9uKHQsZSxpKXtpZih2b2lkIDA9PT1pJiYoaT0hMSksdCE9PXRoaXMudmFsdWVffHxpKXt2YXIgbj10aGlzLm1pbl8scj10aGlzLm1heF8sbz10PT09bnx8dD09PXI7dGhpcy5zdGVwXyYmIW8mJih0PXRoaXMucXVhbnRpemVfKHQpKSx0PG4/dD1uOnQ+ciYmKHQ9ciksdGhpcy52YWx1ZV89dCx0aGlzLmFkYXB0ZXJfLnNldEF0dHJpYnV0ZSgkdC5BUklBX1ZBTFVFTk9XLFN0cmluZyh0aGlzLnZhbHVlXykpLHRoaXMudXBkYXRlVUlGb3JDdXJyZW50VmFsdWVfKCksZSYmKHRoaXMuYWRhcHRlcl8ubm90aWZ5SW5wdXQoKSx0aGlzLmlzRGlzY3JldGVfJiZ0aGlzLmFkYXB0ZXJfLnNldE1hcmtlclZhbHVlKHQpKX19LGUucHJvdG90eXBlLnF1YW50aXplXz1mdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5yb3VuZCh0L3RoaXMuc3RlcF8pKnRoaXMuc3RlcF99LGUucHJvdG90eXBlLnVwZGF0ZVVJRm9yQ3VycmVudFZhbHVlXz1mdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10aGlzLm1heF8saT10aGlzLm1pbl8sbj0odGhpcy52YWx1ZV8taSkvKGUtaSkscj1uKnRoaXMucmVjdF8ud2lkdGg7dGhpcy5hZGFwdGVyXy5pc1JUTCgpJiYocj10aGlzLnJlY3RfLndpZHRoLXIpO3ZhciBvPWZ1bmN0aW9uKHQsZSl7aWYoQnQodCkmJmUgaW4gVXQpe3ZhciBpPXQuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iiksbj1VdFtlXSxyPW4uc3RhbmRhcmQsbz1uLnByZWZpeGVkO3JldHVybiByIGluIGkuc3R5bGU/cjpvfXJldHVybiBlfSh3aW5kb3csInRyYW5zZm9ybSIpLGE9ZnVuY3Rpb24odCxlKXtpZihCdCh0KSYmZSBpbiB6dCl7dmFyIGk9dC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxuPXp0W2VdLHI9bi5zdGFuZGFyZCxvPW4ucHJlZml4ZWQ7cmV0dXJuIG4uY3NzUHJvcGVydHkgaW4gaS5zdHlsZT9yOm99cmV0dXJuIGV9KHdpbmRvdywidHJhbnNpdGlvbmVuZCIpO2lmKHRoaXMuaW5UcmFuc2l0Xyl7dmFyIHM9ZnVuY3Rpb24oKXt0LnNldEluVHJhbnNpdF8oITEpLHQuYWRhcHRlcl8uZGVyZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyKGEscyl9O3RoaXMuYWRhcHRlcl8ucmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlcihhLHMpfXJlcXVlc3RBbmltYXRpb25GcmFtZSgoZnVuY3Rpb24oKXt0LmFkYXB0ZXJfLnNldFRodW1iQ29udGFpbmVyU3R5bGVQcm9wZXJ0eShvLCJ0cmFuc2xhdGVYKCIrcisicHgpIHRyYW5zbGF0ZVgoLTUwJSkiKSx0LmFkYXB0ZXJfLnNldFRyYWNrU3R5bGVQcm9wZXJ0eShvLCJzY2FsZVgoIituKyIpIil9KSl9LGUucHJvdG90eXBlLnNldEFjdGl2ZV89ZnVuY3Rpb24odCl7dGhpcy5hY3RpdmVfPXQsdGhpcy50b2dnbGVDbGFzc18oanQuQUNUSVZFLHRoaXMuYWN0aXZlXyl9LGUucHJvdG90eXBlLnNldEluVHJhbnNpdF89ZnVuY3Rpb24odCl7dGhpcy5pblRyYW5zaXRfPXQsdGhpcy50b2dnbGVDbGFzc18oanQuSU5fVFJBTlNJVCx0aGlzLmluVHJhbnNpdF8pfSxlLnByb3RvdHlwZS50b2dnbGVDbGFzc189ZnVuY3Rpb24odCxlKXtlP3RoaXMuYWRhcHRlcl8uYWRkQ2xhc3ModCk6dGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyh0KX0sZX0oZnQpOwovKioKICAgICAqIEBsaWNlbnNlCiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogICAgICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0CiAgICAgKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHQKICAgICAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQKICAgICAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dAogICAgICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0CiAgICAgKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dAogICAgICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc28KICAgICAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQKICAgICAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dAogICAgICovCmNvbnN0IHJlPW5ldyBXZWFrTWFwLG9lPWEodD0+ZT0+e2lmKCEoZSBpbnN0YW5jZW9mIGspfHxlIGluc3RhbmNlb2YgUnx8InN0eWxlIiE9PWUuY29tbWl0dGVyLm5hbWV8fGUuY29tbWl0dGVyLnBhcnRzLmxlbmd0aD4xKXRocm93IG5ldyBFcnJvcigiVGhlIGBzdHlsZU1hcGAgZGlyZWN0aXZlIG11c3QgYmUgdXNlZCBpbiB0aGUgc3R5bGUgYXR0cmlidXRlIGFuZCBtdXN0IGJlIHRoZSBvbmx5IHBhcnQgaW4gdGhlIGF0dHJpYnV0ZS4iKTtjb25zdHtjb21taXR0ZXI6aX09ZSx7c3R5bGU6bn09aS5lbGVtZW50O3JlLmhhcyhlKXx8KG4uY3NzVGV4dD1pLnN0cmluZ3Muam9pbigiICIpKTtjb25zdCByPXJlLmdldChlKTtmb3IoY29uc3QgZSBpbiByKWUgaW4gdHx8KC0xPT09ZS5pbmRleE9mKCItIik/bltlXT1udWxsOm4ucmVtb3ZlUHJvcGVydHkoZSkpO2Zvcihjb25zdCBlIGluIHQpLTE9PT1lLmluZGV4T2YoIi0iKT9uW2VdPXRbZV06bi5zZXRQcm9wZXJ0eShlLHRbZV0pO3JlLnNldChlLHQpfSk7Y2xhc3MgYWUgZXh0ZW5kcyBMdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5tZGNGb3VuZGF0aW9uQ2xhc3M9bmUsdGhpcy52YWx1ZT0wLHRoaXMubWluPTAsdGhpcy5tYXg9MTAwLHRoaXMuc3RlcD0wLHRoaXMuZGlzYWJsZWQ9ITEsdGhpcy5waW49ITEsdGhpcy5tYXJrZXJzPSExLHRoaXMucGluTWFya2VyVGV4dD0iIix0aGlzLnRyYWNrTWFya2VyQ29udGFpbmVyU3R5bGVzPXt9LHRoaXMudGh1bWJDb250YWluZXJTdHlsZXM9e30sdGhpcy50cmFja1N0eWxlcz17fSx0aGlzLmlzRm91bmRhdGlvbkRlc3Ryb3llZD0hMX1yZW5kZXIoKXtjb25zdCB0PTAhPT10aGlzLnN0ZXAsZT17Im1kYy1zbGlkZXItLWRpc2NyZXRlIjp0LCJtZGMtc2xpZGVyLS1kaXNwbGF5LW1hcmtlcnMiOnRoaXMubWFya2VycyYmdH07bGV0IGk9IiI7dCYmdGhpcy5tYXJrZXJzJiYoaT1NYAogICAgICAgIDxkaXYKICAgICAgICAgICAgY2xhc3M9Im1kYy1zbGlkZXJfX3RyYWNrLW1hcmtlci1jb250YWluZXIiCiAgICAgICAgICAgIHN0eWxlPSIke29lKHRoaXMudHJhY2tNYXJrZXJDb250YWluZXJTdHlsZXMpfSI+CiAgICAgICAgPC9kaXY+YCk7bGV0IG49IiI7cmV0dXJuIHRoaXMucGluJiYobj1NYAogICAgICA8ZGl2IGNsYXNzPSJtZGMtc2xpZGVyX19waW4iPgogICAgICAgIDxzcGFuIGNsYXNzPSJtZGMtc2xpZGVyX19waW4tdmFsdWUtbWFya2VyIj4ke3RoaXMucGluTWFya2VyVGV4dH08L3NwYW4+CiAgICAgIDwvZGl2PmApLE1gCiAgICAgIDxkaXYgY2xhc3M9Im1kYy1zbGlkZXIgJHtQdChlKX0iCiAgICAgICAgICAgdGFiaW5kZXg9IjAiIHJvbGU9InNsaWRlciIKICAgICAgICAgICBhcmlhLXZhbHVlbWluPSIke3RoaXMubWlufSIgYXJpYS12YWx1ZW1heD0iJHt0aGlzLm1heH0iCiAgICAgICAgICAgYXJpYS12YWx1ZW5vdz0iJHt0aGlzLnZhbHVlfSIgYXJpYS1kaXNhYmxlZD0iJHt0aGlzLmRpc2FibGVkfSIKICAgICAgICAgICBkYXRhLXN0ZXA9IiR7dGhpcy5zdGVwfSIKICAgICAgICAgICBAbW91c2Vkb3duPSR7dGhpcy5sYXlvdXR9CiAgICAgICAgICAgQHRvdWNoc3RhcnQ9JHt0aGlzLmxheW91dH0+CiAgICAgICAgPGRpdiBjbGFzcz0ibWRjLXNsaWRlcl9fdHJhY2stY29udGFpbmVyIj4KICAgICAgICAgIDxkaXYKICAgICAgICAgICAgICBjbGFzcz0ibWRjLXNsaWRlcl9fdHJhY2siCiAgICAgICAgICAgICAgc3R5bGU9IiR7b2UodGhpcy50cmFja1N0eWxlcyl9Ij4KICAgICAgICAgIDwvZGl2PgogICAgICAgICAgJHtpfQogICAgICAgIDwvZGl2PgogICAgICAgIDxkaXYKICAgICAgICAgICAgY2xhc3M9Im1kYy1zbGlkZXJfX3RodW1iLWNvbnRhaW5lciIKICAgICAgICAgICAgc3R5bGU9IiR7b2UodGhpcy50aHVtYkNvbnRhaW5lclN0eWxlcyl9Ij4KICAgICAgICAgIDwhLS0gVE9ETzogdXNlIGNhY2hlKCkgZGlyZWN0aXZlIC0tPgogICAgICAgICAgJHtufQogICAgICAgICAgPHN2ZyBjbGFzcz0ibWRjLXNsaWRlcl9fdGh1bWIiIHdpZHRoPSIyMSIgaGVpZ2h0PSIyMSI+CiAgICAgICAgICAgIDxjaXJjbGUgY3g9IjEwLjUiIGN5PSIxMC41IiByPSI3Ljg3NSI+PC9jaXJjbGU+CiAgICAgICAgICA8L3N2Zz4KICAgICAgICA8ZGl2IGNsYXNzPSJtZGMtc2xpZGVyX19mb2N1cy1yaW5nIj48L2Rpdj4KICAgICAgPC9kaXY+CiAgICA8L2Rpdj5gfWNvbm5lY3RlZENhbGxiYWNrKCl7c3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKSx0aGlzLm1kY1Jvb3QmJnRoaXMuaXNGb3VuZGF0aW9uRGVzdHJveWVkJiYodGhpcy5pc0ZvdW5kYXRpb25EZXN0cm95ZWQ9ITEsdGhpcy5tZGNGb3VuZGF0aW9uLmluaXQoKSl9ZGlzY29ubmVjdGVkQ2FsbGJhY2soKXtzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpLHRoaXMuaXNGb3VuZGF0aW9uRGVzdHJveWVkPSEwLHRoaXMubWRjRm91bmRhdGlvbi5kZXN0cm95KCl9Y3JlYXRlQWRhcHRlcigpe3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sKHQ9dGhpcy5tZGNSb290LHthZGRDbGFzczplPT57dC5jbGFzc0xpc3QuYWRkKGUpfSxyZW1vdmVDbGFzczplPT57dC5jbGFzc0xpc3QucmVtb3ZlKGUpfSxoYXNDbGFzczplPT50LmNsYXNzTGlzdC5jb250YWlucyhlKX0pKSx7Z2V0QXR0cmlidXRlOnQ9PnRoaXMubWRjUm9vdC5nZXRBdHRyaWJ1dGUodCksc2V0QXR0cmlidXRlOih0LGUpPT50aGlzLm1kY1Jvb3Quc2V0QXR0cmlidXRlKHQsZSkscmVtb3ZlQXR0cmlidXRlOnQ9PnRoaXMubWRjUm9vdC5yZW1vdmVBdHRyaWJ1dGUodCksY29tcHV0ZUJvdW5kaW5nUmVjdDooKT0+e2NvbnN0IHQ9dGhpcy5tZGNSb290LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybntib3R0b206dC5ib3R0b20saGVpZ2h0OnQuaGVpZ2h0LGxlZnQ6dC5sZWZ0K3dpbmRvdy5wYWdlWE9mZnNldCxyaWdodDp0LnJpZ2h0LHRvcDp0LnRvcCx3aWR0aDp0LndpZHRofX0sZ2V0VGFiSW5kZXg6KCk9PnRoaXMubWRjUm9vdC50YWJJbmRleCxyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjoodCxlKT0+e2NvbnN0IGk9InRvdWNoc3RhcnQiPT09dD9wdCgpOnZvaWQgMDt0aGlzLm1kY1Jvb3QuYWRkRXZlbnRMaXN0ZW5lcih0LGUsaSl9LGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6KHQsZSk9PnRoaXMubWRjUm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKHQsZSkscmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlcjoodCxlKT0+e2NvbnN0IGk9InRvdWNoc3RhcnQiPT09dD9wdCgpOnZvaWQgMDt0aGlzLnRodW1iQ29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIodCxlLGkpfSxkZXJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXI6KHQsZSk9PnRoaXMudGh1bWJDb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LGUpLHJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlcjoodCxlKT0+ZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKHQsZSksZGVyZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXI6KHQsZSk9PmRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LGUpLHJlZ2lzdGVyUmVzaXplSGFuZGxlcjp0PT53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigicmVzaXplIix0LHB0KCkpLGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOnQ9PndpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCJyZXNpemUiLHQpLG5vdGlmeUlucHV0OigpPT57Y29uc3QgdD10aGlzLm1kY0ZvdW5kYXRpb24uZ2V0VmFsdWUoKTt0IT09dGhpcy52YWx1ZSYmKHRoaXMudmFsdWU9dCx0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCJpbnB1dCIse2RldGFpbDp0aGlzLGNvbXBvc2VkOiEwLGJ1YmJsZXM6ITAsY2FuY2VsYWJsZTohMH0pKSl9LG5vdGlmeUNoYW5nZTooKT0+e3RoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoImNoYW5nZSIse2RldGFpbDp0aGlzLGNvbXBvc2VkOiEwLGJ1YmJsZXM6ITAsY2FuY2VsYWJsZTohMH0pKX0sc2V0VGh1bWJDb250YWluZXJTdHlsZVByb3BlcnR5Oih0LGUpPT57dGhpcy50aHVtYkNvbnRhaW5lclN0eWxlc1t0XT1lLHRoaXMucmVxdWVzdFVwZGF0ZSgpfSxzZXRUcmFja1N0eWxlUHJvcGVydHk6KHQsZSk9Pnt0aGlzLnRyYWNrU3R5bGVzW3RdPWUsdGhpcy5yZXF1ZXN0VXBkYXRlKCl9LHNldE1hcmtlclZhbHVlOnQ9PnRoaXMucGluTWFya2VyVGV4dD10LnRvTG9jYWxlU3RyaW5nKCksc2V0VHJhY2tNYXJrZXJzOih0LGUsaSk9Pntjb25zdCBuPXQudG9Mb2NhbGVTdHJpbmcoKSxyPWBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsIGN1cnJlbnRDb2xvciAycHgsIHRyYW5zcGFyZW50IDApICR7YDAgY2VudGVyIC8gY2FsYygoMTAwJSAtIDJweCkgLyAke2AoKCR7ZS50b0xvY2FsZVN0cmluZygpfSAtICR7aS50b0xvY2FsZVN0cmluZygpfSkgLyAke259KWB9KSAxMDAlIHJlcGVhdC14YH1gO3RoaXMudHJhY2tNYXJrZXJDb250YWluZXJTdHlsZXMuYmFja2dyb3VuZD1yLHRoaXMucmVxdWVzdFVwZGF0ZSgpfSxpc1JUTDooKT0+InJ0bCI9PT1nZXRDb21wdXRlZFN0eWxlKHRoaXMubWRjUm9vdCkuZGlyZWN0aW9ufSk7dmFyIHR9cmVzZXRGb3VuZGF0aW9uKCl7dGhpcy5tZGNGb3VuZGF0aW9uJiYodGhpcy5tZGNGb3VuZGF0aW9uLmRlc3Ryb3koKSx0aGlzLm1kY0ZvdW5kYXRpb24uaW5pdCgpKX1sYXlvdXQoKXt0aGlzLm1kY0ZvdW5kYXRpb24ubGF5b3V0KCl9fXZhciBzZTsKLyoqCiAgICBAbGljZW5zZQogICAgQ29weXJpZ2h0IChjKSAyMDE5IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KICAgIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdAogICAgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0IFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQKICAgIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dCBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUKICAgIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0IENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzCiAgICBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzbyBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50CiAgICBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHQKICAgICovcihbaXQoIi5tZGMtc2xpZGVyIildLGFlLnByb3RvdHlwZSwibWRjUm9vdCIsdm9pZCAwKSxyKFtpdCgiLm1kYy1zbGlkZXIiKV0sYWUucHJvdG90eXBlLCJmb3JtRWxlbWVudCIsdm9pZCAwKSxyKFtpdCgiLm1kYy1zbGlkZXJfX3RodW1iLWNvbnRhaW5lciIpXSxhZS5wcm90b3R5cGUsInRodW1iQ29udGFpbmVyIix2b2lkIDApLHIoW2l0KCIubWRjLXNsaWRlcl9fcGluLXZhbHVlLW1hcmtlciIpXSxhZS5wcm90b3R5cGUsInBpbk1hcmtlciIsdm9pZCAwKSxyKFtldCh7dHlwZTpOdW1iZXJ9KSxWdCgoZnVuY3Rpb24odCl7dGhpcy5tZGNGb3VuZGF0aW9uLnNldFZhbHVlKHQpfSkpXSxhZS5wcm90b3R5cGUsInZhbHVlIix2b2lkIDApLHIoW2V0KHt0eXBlOk51bWJlcn0pLFZ0KChmdW5jdGlvbih0KXt0aGlzLm1kY0ZvdW5kYXRpb24uc2V0TWluKHQpfSkpXSxhZS5wcm90b3R5cGUsIm1pbiIsdm9pZCAwKSxyKFtldCh7dHlwZTpOdW1iZXJ9KSxWdCgoZnVuY3Rpb24odCl7dGhpcy5tZGNGb3VuZGF0aW9uLnNldE1heCh0KX0pKV0sYWUucHJvdG90eXBlLCJtYXgiLHZvaWQgMCkscihbZXQoe3R5cGU6TnVtYmVyfSksVnQoKGZ1bmN0aW9uKHQsZSl7MCE9PWUhPT0oMCE9PXQpJiZ0aGlzLnJlc2V0Rm91bmRhdGlvbigpLHRoaXMubWRjRm91bmRhdGlvbi5zZXRTdGVwKHQpfSkpXSxhZS5wcm90b3R5cGUsInN0ZXAiLHZvaWQgMCkscihbZXQoe3R5cGU6Qm9vbGVhbixyZWZsZWN0OiEwfSksVnQoKGZ1bmN0aW9uKHQpe3RoaXMubWRjRm91bmRhdGlvbi5zZXREaXNhYmxlZCh0KX0pKV0sYWUucHJvdG90eXBlLCJkaXNhYmxlZCIsdm9pZCAwKSxyKFtldCh7dHlwZTpCb29sZWFuLHJlZmxlY3Q6ITB9KV0sYWUucHJvdG90eXBlLCJwaW4iLHZvaWQgMCkscihbZXQoe3R5cGU6Qm9vbGVhbixyZWZsZWN0OiEwfSksVnQoKGZ1bmN0aW9uKCl7dGhpcy5tZGNGb3VuZGF0aW9uLnNldHVwVHJhY2tNYXJrZXIoKX0pKV0sYWUucHJvdG90eXBlLCJtYXJrZXJzIix2b2lkIDApLHIoW2V0KHt0eXBlOlN0cmluZ30pXSxhZS5wcm90b3R5cGUsInBpbk1hcmtlclRleHQiLHZvaWQgMCkscihbZXQoe3R5cGU6T2JqZWN0fSldLGFlLnByb3RvdHlwZSwidHJhY2tNYXJrZXJDb250YWluZXJTdHlsZXMiLHZvaWQgMCkscihbZXQoe3R5cGU6T2JqZWN0fSldLGFlLnByb3RvdHlwZSwidGh1bWJDb250YWluZXJTdHlsZXMiLHZvaWQgMCkscihbZXQoe3R5cGU6T2JqZWN0fSldLGFlLnByb3RvdHlwZSwidHJhY2tTdHlsZXMiLHZvaWQgMCkscihbKHNlPXtjYXB0dXJlOiEwLHBhc3NpdmU6ITB9LCh0LGUpPT52b2lkIDAhPT1lPygodCxlLGkpPT57T2JqZWN0LmFzc2lnbihlW2ldLHQpfSkoc2UsdCxlKTooKHQsZSk9Pk9iamVjdC5hc3NpZ24oe30sZSx7ZmluaXNoZXIoaSl7T2JqZWN0LmFzc2lnbihpLnByb3RvdHlwZVtlLmtleV0sdCl9fSkpKHNlLHQpKV0sYWUucHJvdG90eXBlLCJsYXlvdXQiLG51bGwpOwovKioKICAgIEBsaWNlbnNlCiAgICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLgoKICAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAiTGljZW5zZSIpOwogICAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLgogICAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CgogICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAoKICAgIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUKICAgIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICJBUyBJUyIgQkFTSVMsCiAgICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4KICAgIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQKICAgIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLgogICAgKi8KY29uc3QgZGU9ZHRgQGtleWZyYW1lcyBtZGMtc2xpZGVyLWVtcGhhc2l6ZXswJXthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2Utb3V0fTUwJXthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2UtaW47dHJhbnNmb3JtOnNjYWxlKDAuODUpfTEwMCV7dHJhbnNmb3JtOnNjYWxlKDAuNTcxKX19Lm1kYy1zbGlkZXJ7cG9zaXRpb246cmVsYXRpdmU7d2lkdGg6MTAwJTtoZWlnaHQ6NDhweDtjdXJzb3I6cG9pbnRlcjt0b3VjaC1hY3Rpb246cGFuLXg7LXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOnJnYmEoMCwwLDAsMCl9Lm1kYy1zbGlkZXI6bm90KC5tZGMtc2xpZGVyLS1kaXNhYmxlZCkgLm1kYy1zbGlkZXJfX3RyYWNre2JhY2tncm91bmQtY29sb3I6IzAxODc4NjtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLW1kYy10aGVtZS1zZWNvbmRhcnksICMwMTg3ODYpfS5tZGMtc2xpZGVyOm5vdCgubWRjLXNsaWRlci0tZGlzYWJsZWQpIC5tZGMtc2xpZGVyX190cmFjay1jb250YWluZXJ7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDEsMTM1LDEzNCwuMjYpfS5tZGMtc2xpZGVyOm5vdCgubWRjLXNsaWRlci0tZGlzYWJsZWQpIC5tZGMtc2xpZGVyX190cmFjay1tYXJrZXItY29udGFpbmVye2JhY2tncm91bmQtY29sb3I6IzAxODc4NjtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLW1kYy10aGVtZS1zZWNvbmRhcnksICMwMTg3ODYpfS5tZGMtc2xpZGVyOm5vdCgubWRjLXNsaWRlci0tZGlzYWJsZWQpIC5tZGMtc2xpZGVyX190aHVtYntmaWxsOiMwMTg3ODY7ZmlsbDp2YXIoLS1tZGMtdGhlbWUtc2Vjb25kYXJ5LCAjMDE4Nzg2KTtzdHJva2U6IzAxODc4NjtzdHJva2U6dmFyKC0tbWRjLXRoZW1lLXNlY29uZGFyeSwgIzAxODc4Nil9Lm1kYy1zbGlkZXI6bm90KC5tZGMtc2xpZGVyLS1kaXNhYmxlZCkgLm1kYy1zbGlkZXJfX2ZvY3VzLXJpbmd7YmFja2dyb3VuZC1jb2xvcjojMDE4Nzg2O2JhY2tncm91bmQtY29sb3I6dmFyKC0tbWRjLXRoZW1lLXNlY29uZGFyeSwgIzAxODc4Nil9Lm1kYy1zbGlkZXI6bm90KC5tZGMtc2xpZGVyLS1kaXNhYmxlZCkgLm1kYy1zbGlkZXJfX3BpbntiYWNrZ3JvdW5kLWNvbG9yOiMwMTg3ODY7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1tZGMtdGhlbWUtc2Vjb25kYXJ5LCAjMDE4Nzg2KX0ubWRjLXNsaWRlcjpub3QoLm1kYy1zbGlkZXItLWRpc2FibGVkKSAubWRjLXNsaWRlcl9fcGlue2NvbG9yOiNmZmY7Y29sb3I6dmFyKC0tbWRjLXRoZW1lLXRleHQtcHJpbWFyeS1vbi1kYXJrLCB3aGl0ZSl9Lm1kYy1zbGlkZXItLWRpc2FibGVke2N1cnNvcjphdXRvfS5tZGMtc2xpZGVyLS1kaXNhYmxlZCAubWRjLXNsaWRlcl9fdHJhY2t7YmFja2dyb3VuZC1jb2xvcjojOWE5YTlhfS5tZGMtc2xpZGVyLS1kaXNhYmxlZCAubWRjLXNsaWRlcl9fdHJhY2stY29udGFpbmVye2JhY2tncm91bmQtY29sb3I6cmdiYSgxNTQsMTU0LDE1NCwuMjYpfS5tZGMtc2xpZGVyLS1kaXNhYmxlZCAubWRjLXNsaWRlcl9fdHJhY2stbWFya2VyLWNvbnRhaW5lcntiYWNrZ3JvdW5kLWNvbG9yOiM5YTlhOWF9Lm1kYy1zbGlkZXItLWRpc2FibGVkIC5tZGMtc2xpZGVyX190aHVtYntmaWxsOiM5YTlhOWE7c3Ryb2tlOiM5YTlhOWF9Lm1kYy1zbGlkZXItLWRpc2FibGVkIC5tZGMtc2xpZGVyX190aHVtYntzdHJva2U6I2ZmZjtzdHJva2U6dmFyKC0tbWRjLXNsaWRlci1iZy1jb2xvci1iZWhpbmQtY29tcG9uZW50LCB3aGl0ZSl9Lm1kYy1zbGlkZXI6Zm9jdXN7b3V0bGluZTpub25lfS5tZGMtc2xpZGVyX190cmFjay1jb250YWluZXJ7cG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTt3aWR0aDoxMDAlO2hlaWdodDoycHg7b3ZlcmZsb3c6aGlkZGVufS5tZGMtc2xpZGVyX190cmFja3twb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO3RyYW5zZm9ybS1vcmlnaW46bGVmdCB0b3A7d2lsbC1jaGFuZ2U6dHJhbnNmb3JtfS5tZGMtc2xpZGVyW2Rpcj1ydGxdIC5tZGMtc2xpZGVyX190cmFjayxbZGlyPXJ0bF0gLm1kYy1zbGlkZXIgLm1kYy1zbGlkZXJfX3RyYWNre3RyYW5zZm9ybS1vcmlnaW46cmlnaHQgdG9wfS5tZGMtc2xpZGVyX190cmFjay1tYXJrZXItY29udGFpbmVye2Rpc3BsYXk6ZmxleDttYXJnaW4tcmlnaHQ6MDttYXJnaW4tbGVmdDotMXB4O3Zpc2liaWxpdHk6aGlkZGVufS5tZGMtc2xpZGVyW2Rpcj1ydGxdIC5tZGMtc2xpZGVyX190cmFjay1tYXJrZXItY29udGFpbmVyLFtkaXI9cnRsXSAubWRjLXNsaWRlciAubWRjLXNsaWRlcl9fdHJhY2stbWFya2VyLWNvbnRhaW5lcnttYXJnaW4tcmlnaHQ6LTFweDttYXJnaW4tbGVmdDowfS5tZGMtc2xpZGVyX190cmFjay1tYXJrZXItY29udGFpbmVyOjphZnRlcntkaXNwbGF5OmJsb2NrO3dpZHRoOjJweDtoZWlnaHQ6MnB4O2NvbnRlbnQ6IiJ9Lm1kYy1zbGlkZXJfX3RyYWNrLW1hcmtlcntmbGV4OjF9Lm1kYy1zbGlkZXJfX3RyYWNrLW1hcmtlcjo6YWZ0ZXJ7ZGlzcGxheTpibG9jazt3aWR0aDoycHg7aGVpZ2h0OjJweDtjb250ZW50OiIifS5tZGMtc2xpZGVyX190cmFjay1tYXJrZXI6Zmlyc3QtY2hpbGQ6OmFmdGVye3dpZHRoOjNweH0ubWRjLXNsaWRlcl9fdGh1bWItY29udGFpbmVye3Bvc2l0aW9uOmFic29sdXRlO3RvcDoxNXB4O2xlZnQ6MDt3aWR0aDoyMXB4O2hlaWdodDoxMDAlO3VzZXItc2VsZWN0Om5vbmU7d2lsbC1jaGFuZ2U6dHJhbnNmb3JtfS5tZGMtc2xpZGVyX190aHVtYntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7dHJhbnNmb3JtOnNjYWxlKDAuNTcxKTtzdHJva2Utd2lkdGg6My41O3RyYW5zaXRpb246dHJhbnNmb3JtIDEwMG1zIGVhc2Utb3V0LGZpbGwgMTAwbXMgZWFzZS1vdXQsc3Ryb2tlIDEwMG1zIGVhc2Utb3V0fS5tZGMtc2xpZGVyX19mb2N1cy1yaW5ne3dpZHRoOjIxcHg7aGVpZ2h0OjIxcHg7Ym9yZGVyLXJhZGl1czo1MCU7b3BhY2l0eTowO3RyYW5zaXRpb246dHJhbnNmb3JtIDI2Ni42N21zIGVhc2Utb3V0LG9wYWNpdHkgMjY2LjY3bXMgZWFzZS1vdXQsYmFja2dyb3VuZC1jb2xvciAyNjYuNjdtcyBlYXNlLW91dH0ubWRjLXNsaWRlcl9fcGlue2Rpc3BsYXk6ZmxleDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7d2lkdGg6MjZweDtoZWlnaHQ6MjZweDttYXJnaW4tdG9wOi0ycHg7bWFyZ2luLWxlZnQ6LTJweDt0cmFuc2Zvcm06cm90YXRlKC00NWRlZykgc2NhbGUoMCkgdHJhbnNsYXRlKDAsIDApO2JvcmRlci1yYWRpdXM6NTAlIDUwJSA1MCUgMCU7ei1pbmRleDoxO3RyYW5zaXRpb246dHJhbnNmb3JtIDEwMG1zIGVhc2Utb3V0fS5tZGMtc2xpZGVyX19waW4tdmFsdWUtbWFya2Vye2ZvbnQtZmFtaWx5OlJvYm90bywgc2Fucy1zZXJpZjstbW96LW9zeC1mb250LXNtb290aGluZzpncmF5c2NhbGU7LXdlYmtpdC1mb250LXNtb290aGluZzphbnRpYWxpYXNlZDtmb250LXNpemU6Ljg3NXJlbTtsaW5lLWhlaWdodDoxLjI1cmVtO2ZvbnQtd2VpZ2h0OjQwMDtsZXR0ZXItc3BhY2luZzouMDE3ODU3MTQyOWVtO3RleHQtZGVjb3JhdGlvbjppbmhlcml0O3RleHQtdHJhbnNmb3JtOmluaGVyaXQ7dHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyl9Lm1kYy1zbGlkZXItLWFjdGl2ZSAubWRjLXNsaWRlcl9fdGh1bWJ7dHJhbnNmb3JtOnNjYWxlM2QoMSwgMSwgMSl9Lm1kYy1zbGlkZXItLWZvY3VzIC5tZGMtc2xpZGVyX190aHVtYnthbmltYXRpb246bWRjLXNsaWRlci1lbXBoYXNpemUgMjY2LjY3bXMgbGluZWFyfS5tZGMtc2xpZGVyLS1mb2N1cyAubWRjLXNsaWRlcl9fZm9jdXMtcmluZ3t0cmFuc2Zvcm06c2NhbGUzZCgxLjU1LCAxLjU1LCAxLjU1KTtvcGFjaXR5Oi4yNX0ubWRjLXNsaWRlci0taW4tdHJhbnNpdCAubWRjLXNsaWRlcl9fdGh1bWJ7dHJhbnNpdGlvbi1kZWxheToxNDBtc30ubWRjLXNsaWRlci0taW4tdHJhbnNpdCAubWRjLXNsaWRlcl9fdGh1bWItY29udGFpbmVyLC5tZGMtc2xpZGVyLS1pbi10cmFuc2l0IC5tZGMtc2xpZGVyX190cmFjaywubWRjLXNsaWRlcjpmb2N1czpub3QoLm1kYy1zbGlkZXItLWFjdGl2ZSkgLm1kYy1zbGlkZXJfX3RodW1iLWNvbnRhaW5lciwubWRjLXNsaWRlcjpmb2N1czpub3QoLm1kYy1zbGlkZXItLWFjdGl2ZSkgLm1kYy1zbGlkZXJfX3RyYWNre3RyYW5zaXRpb246dHJhbnNmb3JtIDgwbXMgZWFzZX0ubWRjLXNsaWRlci0tZGlzY3JldGUubWRjLXNsaWRlci0tYWN0aXZlIC5tZGMtc2xpZGVyX190aHVtYnt0cmFuc2Zvcm06c2NhbGUoY2FsYygxMiAvIDIxKSl9Lm1kYy1zbGlkZXItLWRpc2NyZXRlLm1kYy1zbGlkZXItLWFjdGl2ZSAubWRjLXNsaWRlcl9fcGlue3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKSBzY2FsZSgxKSB0cmFuc2xhdGUoMTlweCwgLTIwcHgpfS5tZGMtc2xpZGVyLS1kaXNjcmV0ZS5tZGMtc2xpZGVyLS1mb2N1cyAubWRjLXNsaWRlcl9fdGh1bWJ7YW5pbWF0aW9uOm5vbmV9Lm1kYy1zbGlkZXItLWRpc2NyZXRlLm1kYy1zbGlkZXItLWRpc3BsYXktbWFya2VycyAubWRjLXNsaWRlcl9fdHJhY2stbWFya2VyLWNvbnRhaW5lcnt2aXNpYmlsaXR5OnZpc2libGV9Omhvc3R7ZGlzcGxheTppbmxpbmUtYmxvY2s7bWluLXdpZHRoOjEyMHB4O291dGxpbmU6bm9uZX1gO2xldCBjZT1jbGFzcyBleHRlbmRzIGFle307Y2Uuc3R5bGVzPWRlLGNlPXIoW1EoIm13Yy1zbGlkZXIiKV0sY2UpOwovKioKICAgICAqIEBsaWNlbnNlCiAgICAgKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLgogICAgICoKICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkKICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlICJTb2Z0d2FyZSIpLCB0byBkZWFsCiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzCiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsCiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMKICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6CiAgICAgKgogICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4KICAgICAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLgogICAgICoKICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAiQVMgSVMiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SCiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwKICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRQogICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUgogICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwKICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4KICAgICAqIFRIRSBTT0ZUV0FSRS4KICAgICAqLwp2YXIgbGU9e1JPT1Q6Im1kYy1mb3JtLWZpZWxkIn0sdWU9e0xBQkVMX1NFTEVDVE9SOiIubWRjLWZvcm0tZmllbGQgPiBsYWJlbCJ9LHBlPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoaSl7dmFyIHI9dC5jYWxsKHRoaXMsbih7fSxlLmRlZmF1bHRBZGFwdGVyLGkpKXx8dGhpcztyZXR1cm4gci5jbGlja0hhbmRsZXJfPWZ1bmN0aW9uKCl7cmV0dXJuIHIuaGFuZGxlQ2xpY2tfKCl9LHJ9cmV0dXJuIGkoZSx0KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiY3NzQ2xhc3NlcyIse2dldDpmdW5jdGlvbigpe3JldHVybiBsZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwic3RyaW5ncyIse2dldDpmdW5jdGlvbigpe3JldHVybiB1ZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiZGVmYXVsdEFkYXB0ZXIiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm57YWN0aXZhdGVJbnB1dFJpcHBsZTpmdW5jdGlvbigpe30sZGVhY3RpdmF0ZUlucHV0UmlwcGxlOmZ1bmN0aW9uKCl7fSxkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOmZ1bmN0aW9uKCl7fSxyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjpmdW5jdGlvbigpe319fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGUucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oKXt0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCJjbGljayIsdGhpcy5jbGlja0hhbmRsZXJfKX0sZS5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigiY2xpY2siLHRoaXMuY2xpY2tIYW5kbGVyXyl9LGUucHJvdG90eXBlLmhhbmRsZUNsaWNrXz1mdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy5hZGFwdGVyXy5hY3RpdmF0ZUlucHV0UmlwcGxlKCkscmVxdWVzdEFuaW1hdGlvbkZyYW1lKChmdW5jdGlvbigpe3JldHVybiB0LmFkYXB0ZXJfLmRlYWN0aXZhdGVJbnB1dFJpcHBsZSgpfSkpfSxlfShmdCk7Y2xhc3MgbWUgZXh0ZW5kcyBNdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5hbGlnbkVuZD0hMSx0aGlzLmxhYmVsPSIiLHRoaXMubWRjRm91bmRhdGlvbkNsYXNzPXBlfWNyZWF0ZUFkYXB0ZXIoKXtyZXR1cm57cmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6KHQsZSk9Pnt0aGlzLmxhYmVsRWwuYWRkRXZlbnRMaXN0ZW5lcih0LGUpfSxkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOih0LGUpPT57dGhpcy5sYWJlbEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodCxlKX0sYWN0aXZhdGVJbnB1dFJpcHBsZTooKT0+e2NvbnN0IHQ9dGhpcy5pbnB1dDt0IGluc3RhbmNlb2YgTHQmJnQucmlwcGxlJiZ0LnJpcHBsZS5hY3RpdmF0ZSgpfSxkZWFjdGl2YXRlSW5wdXRSaXBwbGU6KCk9Pntjb25zdCB0PXRoaXMuaW5wdXQ7dCBpbnN0YW5jZW9mIEx0JiZ0LnJpcHBsZSYmdC5yaXBwbGUuZGVhY3RpdmF0ZSgpfX19Z2V0IGlucHV0KCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7Zm9yKGNvbnN0IGkgb2YgdC5hc3NpZ25lZE5vZGVzKHtmbGF0dGVuOiEwfSkpaWYoaS5ub2RlVHlwZT09PU5vZGUuRUxFTUVOVF9OT0RFKXtjb25zdCB0PWk7aWYobXQodCxlKSlyZXR1cm4gdH1yZXR1cm4gbnVsbH0odGhpcy5zbG90RWwsIioiKX1yZW5kZXIoKXtyZXR1cm4gTWAKICAgICAgPGRpdiBjbGFzcz0ibWRjLWZvcm0tZmllbGQgJHtQdCh7Im1kYy1mb3JtLWZpZWxkLS1hbGlnbi1lbmQiOnRoaXMuYWxpZ25FbmR9KX0iPgogICAgICAgIDxzbG90Pjwvc2xvdD4KICAgICAgICA8bGFiZWwgY2xhc3M9Im1kYy1sYWJlbCIKICAgICAgICAgICAgICAgQGNsaWNrPSIke3RoaXMuX2xhYmVsQ2xpY2t9Ij4ke3RoaXMubGFiZWx9PC9sYWJlbD4KICAgICAgPC9kaXY+YH1fbGFiZWxDbGljaygpe2NvbnN0IHQ9dGhpcy5pbnB1dDt0JiYodC5mb2N1cygpLHQuY2xpY2soKSl9fXIoW2V0KHt0eXBlOkJvb2xlYW59KV0sbWUucHJvdG90eXBlLCJhbGlnbkVuZCIsdm9pZCAwKSxyKFtldCh7dHlwZTpTdHJpbmd9KSxWdCgoYXN5bmMgZnVuY3Rpb24odCl7Y29uc3QgZT10aGlzLmlucHV0O2UmJigiaW5wdXQiPT09ZS5sb2NhbE5hbWU/ZS5zZXRBdHRyaWJ1dGUoImFyaWEtbGFiZWwiLHQpOmUgaW5zdGFuY2VvZiBMdCYmKGF3YWl0IGUudXBkYXRlQ29tcGxldGUsZS5zZXRBcmlhTGFiZWwodCkpKX0pKV0sbWUucHJvdG90eXBlLCJsYWJlbCIsdm9pZCAwKSxyKFtpdCgiLm1kYy1mb3JtLWZpZWxkIildLG1lLnByb3RvdHlwZSwibWRjUm9vdCIsdm9pZCAwKSxyKFtpdCgic2xvdCIpXSxtZS5wcm90b3R5cGUsInNsb3RFbCIsdm9pZCAwKSxyKFtpdCgibGFiZWwiKV0sbWUucHJvdG90eXBlLCJsYWJlbEVsIix2b2lkIDApOwovKioKICAgIEBsaWNlbnNlCiAgICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLgoKICAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAiTGljZW5zZSIpOwogICAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLgogICAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CgogICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAoKICAgIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUKICAgIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICJBUyBJUyIgQkFTSVMsCiAgICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4KICAgIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQKICAgIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLgogICAgKi8KY29uc3QgaGU9ZHRgLm1kYy1mb3JtLWZpZWxke2ZvbnQtZmFtaWx5OlJvYm90bywgc2Fucy1zZXJpZjstbW96LW9zeC1mb250LXNtb290aGluZzpncmF5c2NhbGU7LXdlYmtpdC1mb250LXNtb290aGluZzphbnRpYWxpYXNlZDtmb250LXNpemU6Ljg3NXJlbTtsaW5lLWhlaWdodDoxLjI1cmVtO2ZvbnQtd2VpZ2h0OjQwMDtsZXR0ZXItc3BhY2luZzouMDE3ODU3MTQyOWVtO3RleHQtZGVjb3JhdGlvbjppbmhlcml0O3RleHQtdHJhbnNmb3JtOmluaGVyaXQ7Y29sb3I6cmdiYSgwLDAsMCwuODcpO2NvbG9yOnZhcigtLW1kYy10aGVtZS10ZXh0LXByaW1hcnktb24tYmFja2dyb3VuZCwgcmdiYSgwLCAwLCAwLCAwLjg3KSk7ZGlzcGxheTppbmxpbmUtZmxleDthbGlnbi1pdGVtczpjZW50ZXI7dmVydGljYWwtYWxpZ246bWlkZGxlfS5tZGMtZm9ybS1maWVsZD5sYWJlbHttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDphdXRvO3BhZGRpbmctbGVmdDo0cHg7cGFkZGluZy1yaWdodDowO29yZGVyOjB9W2Rpcj1ydGxdIC5tZGMtZm9ybS1maWVsZD5sYWJlbCwubWRjLWZvcm0tZmllbGQ+bGFiZWxbZGlyPXJ0bF17bWFyZ2luLWxlZnQ6YXV0bzttYXJnaW4tcmlnaHQ6MH1bZGlyPXJ0bF0gLm1kYy1mb3JtLWZpZWxkPmxhYmVsLC5tZGMtZm9ybS1maWVsZD5sYWJlbFtkaXI9cnRsXXtwYWRkaW5nLWxlZnQ6MDtwYWRkaW5nLXJpZ2h0OjRweH0ubWRjLWZvcm0tZmllbGQtLWFsaWduLWVuZD5sYWJlbHttYXJnaW4tbGVmdDphdXRvO21hcmdpbi1yaWdodDowO3BhZGRpbmctbGVmdDowO3BhZGRpbmctcmlnaHQ6NHB4O29yZGVyOi0xfVtkaXI9cnRsXSAubWRjLWZvcm0tZmllbGQtLWFsaWduLWVuZD5sYWJlbCwubWRjLWZvcm0tZmllbGQtLWFsaWduLWVuZD5sYWJlbFtkaXI9cnRsXXttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDphdXRvfVtkaXI9cnRsXSAubWRjLWZvcm0tZmllbGQtLWFsaWduLWVuZD5sYWJlbCwubWRjLWZvcm0tZmllbGQtLWFsaWduLWVuZD5sYWJlbFtkaXI9cnRsXXtwYWRkaW5nLWxlZnQ6NHB4O3BhZGRpbmctcmlnaHQ6MH0ubWRjLWZvcm0tZmllbGR7YWxpZ24taXRlbXM6Y2VudGVyfTo6c2xvdHRlZCgqKXtmb250LWZhbWlseTpSb2JvdG8sIHNhbnMtc2VyaWY7LW1vei1vc3gtZm9udC1zbW9vdGhpbmc6Z3JheXNjYWxlOy13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWQ7Zm9udC1zaXplOi44NzVyZW07bGluZS1oZWlnaHQ6MS4yNXJlbTtmb250LXdlaWdodDo0MDA7bGV0dGVyLXNwYWNpbmc6LjAxNzg1NzE0MjllbTt0ZXh0LWRlY29yYXRpb246aW5oZXJpdDt0ZXh0LXRyYW5zZm9ybTppbmhlcml0O2NvbG9yOnJnYmEoMCwwLDAsLjg3KTtjb2xvcjp2YXIoLS1tZGMtdGhlbWUtdGV4dC1wcmltYXJ5LW9uLWJhY2tncm91bmQsIHJnYmEoMCwgMCwgMCwgMC44NykpfTo6c2xvdHRlZChtd2Mtc3dpdGNoKXttYXJnaW4tcmlnaHQ6MTBweH1bZGlyPXJ0bF0gOjpzbG90dGVkKG13Yy1zd2l0Y2gpLDo6c2xvdHRlZChtd2Mtc3dpdGNoKVtkaXI9cnRsXXttYXJnaW4tbGVmdDoxMHB4fWA7bGV0IGZlPWNsYXNzIGV4dGVuZHMgbWV7fTtmZS5zdHlsZXM9aGUsZmU9cihbUSgibXdjLWZvcm1maWVsZCIpXSxmZSk7dmFyIF9lPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLGdldCBCdXR0b24oKXtyZXR1cm4gSHR9LGdldCBTbGlkZXIoKXtyZXR1cm4gY2V9LGdldCBGb3JtZmllbGQoKXtyZXR1cm4gZmV9fSk7ZnVuY3Rpb24gYmUodCxlLGksbil7cmV0dXJuIG5ldyhpfHwoaT1Qcm9taXNlKSkoKGZ1bmN0aW9uKHIsbyl7ZnVuY3Rpb24gYSh0KXt0cnl7ZChuLm5leHQodCkpfWNhdGNoKHQpe28odCl9fWZ1bmN0aW9uIHModCl7dHJ5e2Qobi50aHJvdyh0KSl9Y2F0Y2godCl7byh0KX19ZnVuY3Rpb24gZCh0KXt0LmRvbmU/cih0LnZhbHVlKTpuZXcgaSgoZnVuY3Rpb24oZSl7ZSh0LnZhbHVlKX0pKS50aGVuKGEscyl9ZCgobj1uLmFwcGx5KHQsZXx8W10pKS5uZXh0KCkpfSkpfWZ1bmN0aW9uIGdlKHQsZSl7dmFyIGksbixyLG8sYT17bGFiZWw6MCxzZW50OmZ1bmN0aW9uKCl7aWYoMSZyWzBdKXRocm93IHJbMV07cmV0dXJuIHJbMV19LHRyeXM6W10sb3BzOltdfTtyZXR1cm4gbz17bmV4dDpzKDApLHRocm93OnMoMSkscmV0dXJuOnMoMil9LCJmdW5jdGlvbiI9PXR5cGVvZiBTeW1ib2wmJihvW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLG87ZnVuY3Rpb24gcyhvKXtyZXR1cm4gZnVuY3Rpb24ocyl7cmV0dXJuIGZ1bmN0aW9uKG8pe2lmKGkpdGhyb3cgbmV3IFR5cGVFcnJvcigiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLiIpO2Zvcig7YTspdHJ5e2lmKGk9MSxuJiYocj0yJm9bMF0/bi5yZXR1cm46b1swXT9uLnRocm93fHwoKHI9bi5yZXR1cm4pJiZyLmNhbGwobiksMCk6bi5uZXh0KSYmIShyPXIuY2FsbChuLG9bMV0pKS5kb25lKXJldHVybiByO3N3aXRjaChuPTAsciYmKG89WzImb1swXSxyLnZhbHVlXSksb1swXSl7Y2FzZSAwOmNhc2UgMTpyPW87YnJlYWs7Y2FzZSA0OnJldHVybiBhLmxhYmVsKysse3ZhbHVlOm9bMV0sZG9uZTohMX07Y2FzZSA1OmEubGFiZWwrKyxuPW9bMV0sbz1bMF07Y29udGludWU7Y2FzZSA3Om89YS5vcHMucG9wKCksYS50cnlzLnBvcCgpO2NvbnRpbnVlO2RlZmF1bHQ6aWYoIShyPShyPWEudHJ5cykubGVuZ3RoPjAmJnJbci5sZW5ndGgtMV0pJiYoNj09PW9bMF18fDI9PT1vWzBdKSl7YT0wO2NvbnRpbnVlfWlmKDM9PT1vWzBdJiYoIXJ8fG9bMV0+clswXSYmb1sxXTxyWzNdKSl7YS5sYWJlbD1vWzFdO2JyZWFrfWlmKDY9PT1vWzBdJiZhLmxhYmVsPHJbMV0pe2EubGFiZWw9clsxXSxyPW87YnJlYWt9aWYociYmYS5sYWJlbDxyWzJdKXthLmxhYmVsPXJbMl0sYS5vcHMucHVzaChvKTticmVha31yWzJdJiZhLm9wcy5wb3AoKSxhLnRyeXMucG9wKCk7Y29udGludWV9bz1lLmNhbGwodCxhKX1jYXRjaCh0KXtvPVs2LHRdLG49MH1maW5hbGx5e2k9cj0wfWlmKDUmb1swXSl0aHJvdyBvWzFdO3JldHVybnt2YWx1ZTpvWzBdP29bMV06dm9pZCAwLGRvbmU6ITB9fShbbyxzXSl9fX12YXIgdmU9WyJ0ZXh0L3BsYWluIiwidGV4dC9odG1sIl0seWU9ZnVuY3Rpb24oKXsoY29uc29sZS53YXJufHxjb25zb2xlLmxvZykuY2FsbChhcmd1bWVudHMpfS5iaW5kKGNvbnNvbGUsIltjbGlwYm9hcmQtcG9seWZpbGxdIikseGU9ITAsd2U9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dGhpcy5tPXt9fXJldHVybiB0LnByb3RvdHlwZS5zZXREYXRhPWZ1bmN0aW9uKHQsZSl7eGUmJi0xPT09dmUuaW5kZXhPZih0KSYmeWUoIlVua25vd24gZGF0YSB0eXBlOiAiK3QsIkNhbGwgY2xpcGJvYXJkLnN1cHByZXNzV2FybmluZ3MoKSB0byBzdXBwcmVzcyB0aGlzIHdhcm5pbmcuIiksdGhpcy5tW3RdPWV9LHQucHJvdG90eXBlLmdldERhdGE9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubVt0XX0sdC5wcm90b3R5cGUuZm9yRWFjaD1mdW5jdGlvbih0KXtmb3IodmFyIGUgaW4gdGhpcy5tKXQodGhpcy5tW2VdLGUpfSx0fSgpLFNlPWZ1bmN0aW9uKHQpe30sQWU9ITAsQ2U9ZnVuY3Rpb24oKXsoY29uc29sZS53YXJufHxjb25zb2xlLmxvZykuYXBwbHkoY29uc29sZSxhcmd1bWVudHMpfS5iaW5kKCJbY2xpcGJvYXJkLXBvbHlmaWxsXSIpLGtlPSJ0ZXh0L3BsYWluIjtmdW5jdGlvbiBFZSh0KXtyZXR1cm4gYmUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlO3JldHVybiBnZSh0aGlzLChmdW5jdGlvbihpKXtpZihBZSYmIXQuZ2V0RGF0YShrZSkmJkNlKCJjbGlwYm9hcmQud3JpdGUoKSB3YXMgY2FsbGVkIHdpdGhvdXQgYSBgdGV4dC9wbGFpbmAgZGF0YSB0eXBlLiBPbiBzb21lIHBsYXRmb3JtcywgdGhpcyBtYXkgcmVzdWx0IGluIGFuIGVtcHR5IGNsaXBib2FyZC4gQ2FsbCBjbGlwYm9hcmQuc3VwcHJlc3NXYXJuaW5ncygpIHRvIHN1cHByZXNzIHRoaXMgd2FybmluZy4iKSxWZSgpKXtpZihmdW5jdGlvbih0KXt2YXIgZT10LmdldERhdGEoa2UpO2lmKHZvaWQgMCE9PWUpcmV0dXJuIHdpbmRvdy5jbGlwYm9hcmREYXRhLnNldERhdGEoIlRleHQiLGUpO3Rocm93IG5ldyBFcnJvcigiTm8gYHRleHQvcGxhaW5gIHZhbHVlIHdhcyBzcGVjaWZpZWQuIil9KHQpKXJldHVyblsyXTt0aHJvdyBuZXcgRXJyb3IoIkNvcHlpbmcgZmFpbGVkLCBwb3NzaWJseSBiZWNhdXNlIHRoZSB1c2VyIHJlamVjdGVkIGl0LiIpfWlmKFJlKHQpKXJldHVybiBTZSgicmVndWxhciBleGVjQ29weSB3b3JrZWQiKSxbMl07aWYobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJFZGdlIik+LTEpcmV0dXJuIFNlKCdVQSAiRWRnZSIgPT4gYXNzdW1pbmcgc3VjY2VzcycpLFsyXTtpZihQZShkb2N1bWVudC5ib2R5LHQpKXJldHVybiBTZSgiY29weVVzaW5nVGVtcFNlbGVjdGlvbiB3b3JrZWQiKSxbMl07aWYoZnVuY3Rpb24odCl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7ZS5zZXRBdHRyaWJ1dGUoInN0eWxlIiwiLXdlYmtpdC11c2VyLXNlbGVjdDogdGV4dCAhaW1wb3J0YW50IiksZS50ZXh0Q29udGVudD0idGVtcG9yYXJ5IGVsZW1lbnQiLGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZSk7dmFyIGk9UGUoZSx0KTtyZXR1cm4gZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlKSxpfSh0KSlyZXR1cm4gU2UoImNvcHlVc2luZ1RlbXBFbGVtIHdvcmtlZCIpLFsyXTtpZih2b2lkIDAhPT0oZT10LmdldERhdGEoa2UpKSYmZnVuY3Rpb24odCl7U2UoImNvcHlUZXh0VXNpbmdET00iKTt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtlLnNldEF0dHJpYnV0ZSgic3R5bGUiLCItd2Via2l0LXVzZXItc2VsZWN0OiB0ZXh0ICFpbXBvcnRhbnQiKTt2YXIgaT1lO2UuYXR0YWNoU2hhZG93JiYoU2UoIlVzaW5nIHNoYWRvdyBET00uIiksaT1lLmF0dGFjaFNoYWRvdyh7bW9kZToib3BlbiJ9KSk7dmFyIG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic3BhbiIpO24uaW5uZXJUZXh0PXQsaS5hcHBlbmRDaGlsZChuKSxkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGUpLE5lKG4pO3ZhciByPWRvY3VtZW50LmV4ZWNDb21tYW5kKCJjb3B5Iik7cmV0dXJuIE9lKCksZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlKSxyfShlKSlyZXR1cm4gU2UoImNvcHlUZXh0VXNpbmdET00gd29ya2VkIiksWzJdO3Rocm93IG5ldyBFcnJvcigiQ29weSBjb21tYW5kIGZhaWxlZC4iKX0pKX0pKX1mdW5jdGlvbiBUZSgpe3JldHVybiBiZSh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIGdlKHRoaXMsKGZ1bmN0aW9uKHQpe2lmKG5hdmlnYXRvci5jbGlwYm9hcmQmJm5hdmlnYXRvci5jbGlwYm9hcmQucmVhZFRleHQpcmV0dXJuIFNlKCJVc2luZyBgbmF2aWdhdG9yLmNsaXBib2FyZC5yZWFkVGV4dCgpYC4iKSxbMixuYXZpZ2F0b3IuY2xpcGJvYXJkLnJlYWRUZXh0KCldO2lmKFZlKCkpcmV0dXJuIFNlKCJSZWFkaW5nIHRleHQgdXNpbmcgSUUgc3RyYXRlZ3kuIiksWzIsRGUoKV07dGhyb3cgbmV3IEVycm9yKCJSZWFkIGlzIG5vdCBzdXBwb3J0ZWQgaW4geW91ciBicm93c2VyLiIpfSkpfSkpfXZhciBJZT1mdW5jdGlvbigpe3RoaXMuc3VjY2Vzcz0hMX07ZnVuY3Rpb24gUmUodCl7dmFyIGU9bmV3IEllLGk9ZnVuY3Rpb24odCxlLGkpe1NlKCJsaXN0ZW5lciBjYWxsZWQiKSx0LnN1Y2Nlc3M9ITAsZS5mb3JFYWNoKChmdW5jdGlvbihlLG4pe3ZhciByPWkuY2xpcGJvYXJkRGF0YTtyLnNldERhdGEobixlKSxuPT09a2UmJnIuZ2V0RGF0YShuKSE9PWUmJihTZSgic2V0dGluZyB0ZXh0L3BsYWluIGZhaWxlZCIpLHQuc3VjY2Vzcz0hMSl9KSksaS5wcmV2ZW50RGVmYXVsdCgpfS5iaW5kKHRoaXMsZSx0KTtkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCJjb3B5IixpKTt0cnl7ZG9jdW1lbnQuZXhlY0NvbW1hbmQoImNvcHkiKX1maW5hbGx5e2RvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoImNvcHkiLGkpfXJldHVybiBlLnN1Y2Nlc3N9ZnVuY3Rpb24gUGUodCxlKXtOZSh0KTt2YXIgaT1SZShlKTtyZXR1cm4gT2UoKSxpfWZ1bmN0aW9uIE5lKHQpe3ZhciBlPWRvY3VtZW50LmdldFNlbGVjdGlvbigpO2lmKGUpe3ZhciBpPWRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7aS5zZWxlY3ROb2RlQ29udGVudHModCksZS5yZW1vdmVBbGxSYW5nZXMoKSxlLmFkZFJhbmdlKGkpfX1mdW5jdGlvbiBPZSgpe3ZhciB0PWRvY3VtZW50LmdldFNlbGVjdGlvbigpO3QmJnQucmVtb3ZlQWxsUmFuZ2VzKCl9ZnVuY3Rpb24gSGUodCl7dmFyIGU9bmV3IHdlO3JldHVybiBlLnNldERhdGEoa2UsdCksZX1mdW5jdGlvbiBWZSgpe3JldHVybiJ1bmRlZmluZWQiPT10eXBlb2YgQ2xpcGJvYXJkRXZlbnQmJnZvaWQgMCE9PXdpbmRvdy5jbGlwYm9hcmREYXRhJiZ2b2lkIDAhPT13aW5kb3cuY2xpcGJvYXJkRGF0YS5zZXREYXRhfWZ1bmN0aW9uIERlKCl7cmV0dXJuIGJlKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gZ2UodGhpcywoZnVuY3Rpb24oZSl7aWYoIiI9PT0odD13aW5kb3cuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCJUZXh0IikpKXRocm93IG5ldyBFcnJvcigiRW1wdHkgY2xpcGJvYXJkIG9yIGNvdWxkIG5vdCByZWFkIHBsYWluIHRleHQgZnJvbSBjbGlwYm9hcmQiKTtyZXR1cm5bMix0XX0pKX0pKX12YXIgRmU9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsRFQ6d2UscmVhZDpmdW5jdGlvbigpe3JldHVybiBiZSh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIGdlKHRoaXMsKGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHQ9SGUsWzQsVGUoKV07Y2FzZSAxOnJldHVyblsyLHQuYXBwbHkodm9pZCAwLFtlLnNlbnQoKV0pXX19KSl9KSl9LHJlYWRUZXh0OlRlLHNldERlYnVnTG9nOmZ1bmN0aW9uKHQpe1NlPXR9LHN1cHByZXNzV2FybmluZ3M6ZnVuY3Rpb24oKXtBZT0hMSx4ZT0hMX0sd3JpdGU6RWUsd3JpdGVUZXh0OmZ1bmN0aW9uKHQpe3JldHVybiBiZSh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIGdlKHRoaXMsKGZ1bmN0aW9uKGUpe3JldHVybiBuYXZpZ2F0b3IuY2xpcGJvYXJkJiZuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dD8oU2UoIlVzaW5nIGBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCgpYC4iKSxbMixuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0KV0pOlsyLEVlKEhlKHQpKV19KSl9KSl9fSksTWU9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsY2xpcGJvYXJkUG9seWZpbGw6RmV9KTt0LmNvbXBvbmVudHM9X2UsdC51dGlsaXRpZXM9TWUsT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pfSkpOwo='

    document.addEventListener(
      'x-pwgen-handle-password',
      ({ detail }) => {
        console.log(detail.msg)
      }
    )

    // handle back button
    window.onpopstate = () => {
      if (document.location !== document.querySelector('base').href) {
        document.location = document.location
      }
    }
  </script>
</body>
</html>
